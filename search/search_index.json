{
    "docs": [
        {
            "location": "/", 
            "text": "", 
            "title": "Home"
        }, 
        {
            "location": "/android-reference/", 
            "text": "Android SDK Reference", 
            "title": "Android SDK Reference"
        }, 
        {
            "location": "/android-reference/#android-sdk-reference", 
            "text": "", 
            "title": "Android SDK Reference"
        }, 
        {
            "location": "/appa-other/", 
            "text": "Appendix A - Other", 
            "title": "Appendix A - Other"
        }, 
        {
            "location": "/appa-other/#appendix-a-other", 
            "text": "", 
            "title": "Appendix A - Other"
        }, 
        {
            "location": "/appb-emv/", 
            "text": "Appendix B - EMV Reference", 
            "title": "Appendix B - EMV Reference"
        }, 
        {
            "location": "/appb-emv/#appendix-b-emv-reference", 
            "text": "", 
            "title": "Appendix B - EMV Reference"
        }, 
        {
            "location": "/appc-payment/", 
            "text": "Guide to Basic Payment Processing", 
            "title": "Guide to Basic Payment Processing"
        }, 
        {
            "location": "/appc-payment/#guide-to-basic-payment-processing", 
            "text": "", 
            "title": "Guide to Basic Payment Processing"
        }, 
        {
            "location": "/basics/", 
            "text": "The Basics\n\n\nThis chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support.\n\n\nWhat does it do?\n\n\nThe Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods.\n\n\nWhich payments methods are supported?\n\n\nCash\n\n\nIf you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality.\n\n\nCard\n\n\nYou can also use the SDK to create functionality to accept payments from:\n\n\n\n\nVisa\n\n\nMastercard\n\n\n\n\nAlternative Payment Methods\n\n\nThe following alternative payment methods can also be accepted:\n\n\n\n\nAlipay\n\n\nWeChat Pay\n\n\n\n\nWhich transaction types are supported?\n\n\nThe following payment operations are supported:\n\n\n\n\nPurchase\n\n\nCapture\n\n\nReversal\n\n\nRefund (both partial and full)\n\n\n\n\nWhat are the prerequisites for using the SDK?\n\n\nThese are the prerequisites for both iOS and Android:\n\n\n\n\niOS - v9.0 or higher\n\n\nAndroid - v4.0 or higher\n\n\nAndroid Studio\n\n\n\n\nHow do I find and install the SDK?\n\n\nThe two SDKs are available here:\n\n\n\n\nJFrog Bintray for Android\n.\n\n\nGithub repository for iOS\n\n\n\n\nSetup instructions are provided on this site:\n\n\n\n\nfor Android, see the \nSet up on Android\n section of this website, starting with the \nAutomated Setup with JitPack\n chapter\n\n\nfor iOS, see the \nSet up on iOS\n section of this website, starting with the \nAutomated Setup with Cocoapods\n chapter\n\n\n\n\nIs there sample code?\n\n\nYes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using \nGists\n, a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The \nIntegrating the SDK\n section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages:\n\n\n\n\niOS: Objective-C\n\n\niOS: Swift\n\n\nAndroid: Java\n\n\n\n\nIs there demo application?\n\n\nYes. You can check standalone demo application for both platforms.\n\n\n\n\niOS Wirecard ePOS Demo\n\n\nAndroid Wirecard ePOS Demo\n\n\n\n\nIs there integration testing code?\n\n\nYes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See \nAndroid Integration Tests\n and \niOS Integration Tests\n. \n\n\nHow do I get technical support?\n\n\nPlease email: \n\n\nWhich hardware is supported?\n\n\nPrinters\n\n\n\n\nDatecs printer \nDPP-250\n\n\nStarMicronics \nTSP650\n\n\n\n\nCash Drawer or Multi-function Devices\n\n\n\n\nStarMicronics \nmPOP\n\n\nStarMicronics \nSMD2\n\n\n\n\nHandheld Scanners\n\n\n\n\nSocketMobile \nSeries 7\n\n\n\n\nLicense\n\n\nWirecard ePOS SDK is available under the MIT license. See the LICENSE file for more info.", 
            "title": "The Basics"
        }, 
        {
            "location": "/basics/#the-basics", 
            "text": "This chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support.", 
            "title": "The Basics"
        }, 
        {
            "location": "/basics/#what-does-it-do", 
            "text": "The Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods.", 
            "title": "What does it do?"
        }, 
        {
            "location": "/basics/#which-payments-methods-are-supported", 
            "text": "", 
            "title": "Which payments methods are supported?"
        }, 
        {
            "location": "/basics/#cash", 
            "text": "If you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality.", 
            "title": "Cash"
        }, 
        {
            "location": "/basics/#card", 
            "text": "You can also use the SDK to create functionality to accept payments from:   Visa  Mastercard", 
            "title": "Card"
        }, 
        {
            "location": "/basics/#alternative-payment-methods", 
            "text": "The following alternative payment methods can also be accepted:   Alipay  WeChat Pay", 
            "title": "Alternative Payment Methods"
        }, 
        {
            "location": "/basics/#which-transaction-types-are-supported", 
            "text": "The following payment operations are supported:   Purchase  Capture  Reversal  Refund (both partial and full)", 
            "title": "Which transaction types are supported?"
        }, 
        {
            "location": "/basics/#what-are-the-prerequisites-for-using-the-sdk", 
            "text": "These are the prerequisites for both iOS and Android:   iOS - v9.0 or higher  Android - v4.0 or higher  Android Studio", 
            "title": "What are the prerequisites for using the SDK?"
        }, 
        {
            "location": "/basics/#how-do-i-find-and-install-the-sdk", 
            "text": "The two SDKs are available here:   JFrog Bintray for Android .  Github repository for iOS   Setup instructions are provided on this site:   for Android, see the  Set up on Android  section of this website, starting with the  Automated Setup with JitPack  chapter  for iOS, see the  Set up on iOS  section of this website, starting with the  Automated Setup with Cocoapods  chapter", 
            "title": "How do I find and install the SDK?"
        }, 
        {
            "location": "/basics/#is-there-sample-code", 
            "text": "Yes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using  Gists , a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The  Integrating the SDK  section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages:   iOS: Objective-C  iOS: Swift  Android: Java", 
            "title": "Is there sample code?"
        }, 
        {
            "location": "/basics/#is-there-demo-application", 
            "text": "Yes. You can check standalone demo application for both platforms.   iOS Wirecard ePOS Demo  Android Wirecard ePOS Demo", 
            "title": "Is there demo application?"
        }, 
        {
            "location": "/basics/#is-there-integration-testing-code", 
            "text": "Yes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See  Android Integration Tests  and  iOS Integration Tests .", 
            "title": "Is there integration testing code?"
        }, 
        {
            "location": "/basics/#how-do-i-get-technical-support", 
            "text": "Please email:", 
            "title": "How do I get technical support?"
        }, 
        {
            "location": "/basics/#which-hardware-is-supported", 
            "text": "", 
            "title": "Which hardware is supported?"
        }, 
        {
            "location": "/basics/#printers", 
            "text": "Datecs printer  DPP-250  StarMicronics  TSP650", 
            "title": "Printers"
        }, 
        {
            "location": "/basics/#cash-drawer-or-multi-function-devices", 
            "text": "StarMicronics  mPOP  StarMicronics  SMD2", 
            "title": "Cash Drawer or Multi-function Devices"
        }, 
        {
            "location": "/basics/#handheld-scanners", 
            "text": "SocketMobile  Series 7", 
            "title": "Handheld Scanners"
        }, 
        {
            "location": "/basics/#license", 
            "text": "Wirecard ePOS SDK is available under the MIT license. See the LICENSE file for more info.", 
            "title": "License"
        }, 
        {
            "location": "/fake-external-link/", 
            "text": "", 
            "title": "Fake external link"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nGlossary of Acronyms\n\n\nCNP\n \u2013 Chip and PIN\n\n\nCVM\n - Card Verification Method\n\n\nDUKPT\n \u2013 Derived Unique Key Per Transaction\n\n\nEFT\n - Electronic Funds Transfer\n\n\nEMV\n - Europay, Mastercard, Visa. See \nEMV\n below.\n\n\nERP\n \u2013 Enterprise Resource Planning\n\n\nFW\n - Firmware\n\n\nHSM\n - Hardware Security Module. See \nHSM\n below.  \n\n\nmPOS\n - mobile Point of Sale\n\n\nMFI\n \u2013 Made for iPhone.\n\n\nPCI DSS\n \u2013 Payment Card Industry Data Security Standard\n\n\nREST\n \u2013 Representational State Transfer\n\n\nSEPA\n - Single Euro Payments Area\n\n\nUUID\n \u2013 Unique User Identifier\n\n\nGlossary of Terminology\n\n\nA\n\n\nAcquiring Platform\n \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the \nAcquirer\n and handles the \ninterchange\n with the \ncard schemes\n so that, ultimately, the transaction is debited from the account of the Cardholder. For Wirecard ePOS SDK, a \nmerchant\n requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's \nPayment \n Risk\n division provides its own Acquiring Platform with the Wirecard \nAcquiring and Processing\n unit.\n\n\nAcquirer\n - Entities that collect card payments that have been accepted by merchants, and then aggregate and separate those payments and forward them on to \nIssuers\n for processing. Also known as \nMerchant Acquirers\n.\n\n\nAcquiring and Processing\n - Unit of Wirecard that provides an \nAcquiring Platform\n.\n\n\nAlipay\n \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The Wirecard ePOS SDK supports payments made through Alipay.\n\n\nauthorize\n - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale. \n\n\nB\n\n\nback-end\n - Refers to the new \nSwitch\n back-end. With Wirecard ePOS SDK, you create a \nfront-end\n \npayment acceptance app\n and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the \nGateway\n, which in turn, forwards the transaction on to the \nAcquirer\n and, ultimately, to the \nIssuer\n so that the consumer can pay the Issuer. In addition, many merchants also have an \nERP\n system connected which augments the back-end functionality provided by Switch.\n\n\nbarcode\n - One of two possible types of codes that can be scanned with a \npistol scanner\n. The other type is a \nQR code\n.\n\n\nbasket\n - A user-defined collection of items for purchase, also referred to as a \ncart\n or \nshopping cart\n.\n\n\nBusiness ByDesign\n - See \nSAP Business ByDesign\n.\n\n\nC\n\n\ncardholder\n - Consumer who uses a debit or credit card as their method of payment.\n\n\nCard Issuer\n - See \nIssuer\n.\n\n\ncard reader\n - See \nterminal\n.\n\n\ncart\n - See \nbasket\n.\n\n\ncash\n - Physical money in the form of bank notes or coins.\n\n\ncash in/out\n - See \npay in/out\n.\n\n\ncash payments\n - Payment with bank notes or coins. The opposite of \ncashless payments\n.\n\n\ncash register\n - Refers to an actual piece of hardware that provides cash register functionality. \nCash Register\n (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code.\n\n\nCash Register\n - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component.\n\n\nCashier\n - User of a cash register. Each Cashier must be associated with a Cash Register.\n\n\ncashless payment\n - Payment that involves a card, and does not involve bank notes or coins. The opposite of \ncash payments\n.\n\n\nChip and PIN cards\n - See \nEMV cards\n.\n\n\nChip and Signature cards\n - See \nEMV cards\n.\n\n\nconsumer\n - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a \ncardholder\n.\n\n\ncustomer\n - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including \nSAP Business By Design\n. See \nmember\n.\n\n\nD\n\n\ndevice\n - The physical hardware used by the merchant who has the payment acceptance app installed.\n\n\nE\n\n\nelectronic payments\n - Same as \ncashless payments\n. Contrast with \ncash payments\n.\n\n\nEMV\n - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others.\n\n\nEMV Cards\n \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called \nChip and PIN\n or \nChip and Signature\n cards.\n\n\nF\n\n\nFirmware\n \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the \npayment acceptance app\n that you create.\n\n\nfront-end\n - The \npayment acceptance app\n that is created by \npartners\n using the Wirecard ePOS SDK is typically referred to as the front-end to distinguish it from the \nSwitch\n \nback-end\n, which handles the processing and routing of transactions.\n\n\nfull refund\n - A return to the consumer of the full amount that they paid in the original sale. \n\n\nG\n\n\nGateway\n - Wirecard component that is responsible for the initial processing of the transaction and then routing to the \nAcquirer\n. Initial processing includes handling the secure decryption of \nMagStripe\n, \nEMV\n and both offline and online PIN transactions. An \nHSM\n is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the Wirecard ePOS SDK, there is a \nTest Gateway\n to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development.\n\n\ngift card\n \u2013 Physical or online card that provides the consumer with a discount on a purchase.\n\n\nH\n\n\nHSM\n -  A physical device that helps with the decryption of PIN and other card holder data.\n\n\nI\n\n\nInventory Manager\n - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images).\n\n\nIssuing Bank\n - See \nCard Issuer\n.\n\n\nIssuer\n - See \nCard Issuer\n.\n\n\nM\n\n\nmerchant\n - A seller of products, typically with a physical location, which is known as a \nstore\n or \nshop\n. The Wirecard ePOS SDK is used by our \npartners\n to create \npayment acceptance apps\n for merchants.\n\n\nMerchant Acquirer\n - See \nAcquirer\n.\n\n\nmember\n - A term that is sometimes used by ERP back-end systems to refer to customers. See \ncustomer\n.\n\n\nmobile device\n \u2013 Hardware on which apps created with the Wirecard ePOS SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon.\n\n\nSwitch Portal\n - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end.\n\n\nO\n\n\nObjective-C\n - One of the programming languages that is available on the iOS platform. It is also available in the  \nSwift\n language.\n\n\nP\n\n\npartial refund\n - A return to the consumer of a portion of the amount they paid in the original sale.\n\n\npartner\n - Refers to companies that collaborate with Wirecard to create \npayment acceptance apps\n for \nmerchants\n using the Wirecard ePOS SDK.\n\n\npartner team\n - One or more persons at a partner company responsible for creating a \npayment acceptance app\n using the Wirecard ePOS SDK. Typically, a partner team consists of a project manager and one or more developers. This Wirecard ePOS SDK documentation was created for our partner teams.\n\n\npay in/out\n \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out.\n\n\npayment gateway\n - See \nGateway\n.\n\n\npayment method\n - Form of payment used in a sale. With the Wirecard ePOS SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay.\n\n\nPayment \n Risk\n - Division of Wirecard that handles \nAcquiring and Processing\n services.\n\n\npayment acceptance app\n - App that Wirecard \npartners\n create with the Wirecard ePOS SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the Wirecard ePOS SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the Wirecard ePOS SDK is always referred to as the \npayment acceptance app\n. \n\n\npayment gateway\n \u2013 Transaction processing and routing. See \nGateway\n.\n\n\npistol scanner\n - Handheld scanner used to scan \nbarcodes\n and \nQR codes\n.\n\n\nplatform\n - Refers to the operating system on which the Wirecard ePOS SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK.\n\n\nproduct catalogue\n - A set of products. Also commonly referred to as inventory. See \nInventory Manager\n.\n\n\nPublic Test\n \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK.\n\n\npurchase\n - The most common \ntransaction type\n. A purchase involves the \nconsumer\n buying something from a \nmerchant\n. Other types of transactions include \nreturn\n, \nauthorize\n, \npre-authorize\n.\n\n\nQ\n\n\nQR code\n - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a \npistol scanner\n. See also \nbarcode\n.\n\n\nR\n\n\nreturn\n - Can be a \nreverse\n or a \nrefund\n.\n\n\nreverse\n - A cancellation of a sale, which can be performed if the sale has not yet been processed by the \nAcquiring Platform\n.\n\n\nrefund\n - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds.\n\n\nS\n\n\nsale\n - The initial interaction between the merchant user and a \nconsumer\n. In terms of the SDK code, sales begin with a \nSale Request\n and completes with a \nSale Response\n.\n\n\nSale Response\n - SDK object that has the results of the sale after processing by the back-end.\n\n\nSale Request\n - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a \npurchase\n, but it can also be a \nreturn\n, an \nauthorize\n, or a \npre-authorize\n.\n\n\nSAP Business ByDesign\n - A cloud-based \nERP\n solution for small to medium-sized businesses. This software can be used to augment the \nSwitch\n \nback-end\n which is provided as part of the SDK.\n\n\nscanner\n - See \npistol scanner\n.\n\n\nSEPA\n \u2013 The\u00a0Single Euro Payments Area\u00a0(SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros.\n\n\nshift\n \u2013 Working time of a merchant user. Starts with the open and ends with the close.\n\n\nshop\n - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location.\n\n\nshopping cart\n - See \nbasket\n.\n\n\nShift Report\n - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report.\n\n\nShift Activity\n \u2013 \nPay in/out\n activity between the open and close of a shift.\n\n\nStar Micronics\n - Vendor of payment acceptance hardware.\n\n\nStarIO\n - See \nStar Micronics\n.\n\n\nstore\n - See \nshop\n.\n\n\nSwift\n - One of the programming languages that is available on the iOS platform. See also \nObjective-C\n. \n\n\nSwitch\n - The back-end of the Wirecard ePOS SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information.\n\n\nT\n\n\nterminal\n \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader.\n\n\ntransaction\n - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit.\n\n\ntransaction type\n - Indicates the nature of a transaction, such as a \npurchase\n or an \nauthorize\n.\n\n\nU\n\n\nuser\n - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as \nCashiers\n.\n\n\nV\n\n\nvendor\n \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Miura, BBPOS, Star and Datecs.\n\n\nW\n\n\nWeChat Pay\n - One of the most popular alternative payment methods available in China, this is a digital wallet service.\n\n\nZ\n\n\nZ-Report\n \u2013 See \nShift Report\n.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary-of-acronyms", 
            "text": "CNP  \u2013 Chip and PIN  CVM  - Card Verification Method  DUKPT  \u2013 Derived Unique Key Per Transaction  EFT  - Electronic Funds Transfer  EMV  - Europay, Mastercard, Visa. See  EMV  below.  ERP  \u2013 Enterprise Resource Planning  FW  - Firmware  HSM  - Hardware Security Module. See  HSM  below.    mPOS  - mobile Point of Sale  MFI  \u2013 Made for iPhone.  PCI DSS  \u2013 Payment Card Industry Data Security Standard  REST  \u2013 Representational State Transfer  SEPA  - Single Euro Payments Area  UUID  \u2013 Unique User Identifier", 
            "title": "Glossary of Acronyms"
        }, 
        {
            "location": "/glossary/#glossary-of-terminology", 
            "text": "", 
            "title": "Glossary of Terminology"
        }, 
        {
            "location": "/glossary/#a", 
            "text": "Acquiring Platform  \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the  Acquirer  and handles the  interchange  with the  card schemes  so that, ultimately, the transaction is debited from the account of the Cardholder. For Wirecard ePOS SDK, a  merchant  requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's  Payment   Risk  division provides its own Acquiring Platform with the Wirecard  Acquiring and Processing  unit.  Acquirer  - Entities that collect card payments that have been accepted by merchants, and then aggregate and separate those payments and forward them on to  Issuers  for processing. Also known as  Merchant Acquirers .  Acquiring and Processing  - Unit of Wirecard that provides an  Acquiring Platform .  Alipay  \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The Wirecard ePOS SDK supports payments made through Alipay.  authorize  - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale.", 
            "title": "A"
        }, 
        {
            "location": "/glossary/#b", 
            "text": "back-end  - Refers to the new  Switch  back-end. With Wirecard ePOS SDK, you create a  front-end   payment acceptance app  and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the  Gateway , which in turn, forwards the transaction on to the  Acquirer  and, ultimately, to the  Issuer  so that the consumer can pay the Issuer. In addition, many merchants also have an  ERP  system connected which augments the back-end functionality provided by Switch.  barcode  - One of two possible types of codes that can be scanned with a  pistol scanner . The other type is a  QR code .  basket  - A user-defined collection of items for purchase, also referred to as a  cart  or  shopping cart .  Business ByDesign  - See  SAP Business ByDesign .", 
            "title": "B"
        }, 
        {
            "location": "/glossary/#c", 
            "text": "cardholder  - Consumer who uses a debit or credit card as their method of payment.  Card Issuer  - See  Issuer .  card reader  - See  terminal .  cart  - See  basket .  cash  - Physical money in the form of bank notes or coins.  cash in/out  - See  pay in/out .  cash payments  - Payment with bank notes or coins. The opposite of  cashless payments .  cash register  - Refers to an actual piece of hardware that provides cash register functionality.  Cash Register  (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code.  Cash Register  - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component.  Cashier  - User of a cash register. Each Cashier must be associated with a Cash Register.  cashless payment  - Payment that involves a card, and does not involve bank notes or coins. The opposite of  cash payments .  Chip and PIN cards  - See  EMV cards .  Chip and Signature cards  - See  EMV cards .  consumer  - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a  cardholder .  customer  - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including  SAP Business By Design . See  member .", 
            "title": "C"
        }, 
        {
            "location": "/glossary/#d", 
            "text": "device  - The physical hardware used by the merchant who has the payment acceptance app installed.", 
            "title": "D"
        }, 
        {
            "location": "/glossary/#e", 
            "text": "electronic payments  - Same as  cashless payments . Contrast with  cash payments .  EMV  - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others.  EMV Cards  \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called  Chip and PIN  or  Chip and Signature  cards.", 
            "title": "E"
        }, 
        {
            "location": "/glossary/#f", 
            "text": "Firmware  \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the  payment acceptance app  that you create.  front-end  - The  payment acceptance app  that is created by  partners  using the Wirecard ePOS SDK is typically referred to as the front-end to distinguish it from the  Switch   back-end , which handles the processing and routing of transactions.  full refund  - A return to the consumer of the full amount that they paid in the original sale.", 
            "title": "F"
        }, 
        {
            "location": "/glossary/#g", 
            "text": "Gateway  - Wirecard component that is responsible for the initial processing of the transaction and then routing to the  Acquirer . Initial processing includes handling the secure decryption of  MagStripe ,  EMV  and both offline and online PIN transactions. An  HSM  is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the Wirecard ePOS SDK, there is a  Test Gateway  to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development.  gift card  \u2013 Physical or online card that provides the consumer with a discount on a purchase.", 
            "title": "G"
        }, 
        {
            "location": "/glossary/#h", 
            "text": "HSM  -  A physical device that helps with the decryption of PIN and other card holder data.", 
            "title": "H"
        }, 
        {
            "location": "/glossary/#i", 
            "text": "Inventory Manager  - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images).  Issuing Bank  - See  Card Issuer .  Issuer  - See  Card Issuer .", 
            "title": "I"
        }, 
        {
            "location": "/glossary/#m", 
            "text": "merchant  - A seller of products, typically with a physical location, which is known as a  store  or  shop . The Wirecard ePOS SDK is used by our  partners  to create  payment acceptance apps  for merchants.  Merchant Acquirer  - See  Acquirer .  member  - A term that is sometimes used by ERP back-end systems to refer to customers. See  customer .  mobile device  \u2013 Hardware on which apps created with the Wirecard ePOS SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon.  Switch Portal  - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end.", 
            "title": "M"
        }, 
        {
            "location": "/glossary/#o", 
            "text": "Objective-C  - One of the programming languages that is available on the iOS platform. It is also available in the   Swift  language.", 
            "title": "O"
        }, 
        {
            "location": "/glossary/#p", 
            "text": "partial refund  - A return to the consumer of a portion of the amount they paid in the original sale.  partner  - Refers to companies that collaborate with Wirecard to create  payment acceptance apps  for  merchants  using the Wirecard ePOS SDK.  partner team  - One or more persons at a partner company responsible for creating a  payment acceptance app  using the Wirecard ePOS SDK. Typically, a partner team consists of a project manager and one or more developers. This Wirecard ePOS SDK documentation was created for our partner teams.  pay in/out  \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out.  payment gateway  - See  Gateway .  payment method  - Form of payment used in a sale. With the Wirecard ePOS SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay.  Payment   Risk  - Division of Wirecard that handles  Acquiring and Processing  services.  payment acceptance app  - App that Wirecard  partners  create with the Wirecard ePOS SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the Wirecard ePOS SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the Wirecard ePOS SDK is always referred to as the  payment acceptance app .   payment gateway  \u2013 Transaction processing and routing. See  Gateway .  pistol scanner  - Handheld scanner used to scan  barcodes  and  QR codes .  platform  - Refers to the operating system on which the Wirecard ePOS SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK.  product catalogue  - A set of products. Also commonly referred to as inventory. See  Inventory Manager .  Public Test  \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK.  purchase  - The most common  transaction type . A purchase involves the  consumer  buying something from a  merchant . Other types of transactions include  return ,  authorize ,  pre-authorize .", 
            "title": "P"
        }, 
        {
            "location": "/glossary/#q", 
            "text": "QR code  - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a  pistol scanner . See also  barcode .", 
            "title": "Q"
        }, 
        {
            "location": "/glossary/#r", 
            "text": "return  - Can be a  reverse  or a  refund .  reverse  - A cancellation of a sale, which can be performed if the sale has not yet been processed by the  Acquiring Platform .  refund  - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds.", 
            "title": "R"
        }, 
        {
            "location": "/glossary/#s", 
            "text": "sale  - The initial interaction between the merchant user and a  consumer . In terms of the SDK code, sales begin with a  Sale Request  and completes with a  Sale Response .  Sale Response  - SDK object that has the results of the sale after processing by the back-end.  Sale Request  - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a  purchase , but it can also be a  return , an  authorize , or a  pre-authorize .  SAP Business ByDesign  - A cloud-based  ERP  solution for small to medium-sized businesses. This software can be used to augment the  Switch   back-end  which is provided as part of the SDK.  scanner  - See  pistol scanner .  SEPA  \u2013 The\u00a0Single Euro Payments Area\u00a0(SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros.  shift  \u2013 Working time of a merchant user. Starts with the open and ends with the close.  shop  - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location.  shopping cart  - See  basket .  Shift Report  - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report.  Shift Activity  \u2013  Pay in/out  activity between the open and close of a shift.  Star Micronics  - Vendor of payment acceptance hardware.  StarIO  - See  Star Micronics .  store  - See  shop .  Swift  - One of the programming languages that is available on the iOS platform. See also  Objective-C .   Switch  - The back-end of the Wirecard ePOS SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information.", 
            "title": "S"
        }, 
        {
            "location": "/glossary/#t", 
            "text": "terminal  \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader.  transaction  - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit.  transaction type  - Indicates the nature of a transaction, such as a  purchase  or an  authorize .", 
            "title": "T"
        }, 
        {
            "location": "/glossary/#u", 
            "text": "user  - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as  Cashiers .", 
            "title": "U"
        }, 
        {
            "location": "/glossary/#v", 
            "text": "vendor  \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Miura, BBPOS, Star and Datecs.", 
            "title": "V"
        }, 
        {
            "location": "/glossary/#w", 
            "text": "WeChat Pay  - One of the most popular alternative payment methods available in China, this is a digital wallet service.", 
            "title": "W"
        }, 
        {
            "location": "/glossary/#z", 
            "text": "Z-Report  \u2013 See  Shift Report .", 
            "title": "Z"
        }, 
        {
            "location": "/int-cash-cashiers-pin/", 
            "text": "Cashiers with PIN\n\n\nThe second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the \nCashiers\n chapter. \n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Cashiers with PIN"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#cashiers-with-pin", 
            "text": "The second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the  Cashiers  chapter.", 
            "title": "Cashiers with PIN"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-cashiers/", 
            "text": "Cashiers\n\n\nCashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales. \n\n\nThere are two methods to obtain the identifier for a Cashier:\n\n\n\n\nObtain the cashier linked to the merchant user who is already logged in.\n\n\nPresent a PIN entry user interface to the merchant user and have them log in.\n\n\n\n\nThis chapter covers the first use case, while the \nnext chapter\n covers the PIN entry validation use case.\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Cashiers"
        }, 
        {
            "location": "/int-cash-cashiers/#cashiers", 
            "text": "Cashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales.   There are two methods to obtain the identifier for a Cashier:   Obtain the cashier linked to the merchant user who is already logged in.  Present a PIN entry user interface to the merchant user and have them log in.   This chapter covers the first use case, while the  next chapter  covers the PIN entry validation use case.", 
            "title": "Cashiers"
        }, 
        {
            "location": "/int-cash-cashiers/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-overview/", 
            "text": "Cash Manager Overview\n\n\nCash Management is an optional feature of the Wirecard ePOS SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature. \n\n\nMost of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the \nCash Drawer Manager\n, which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user.\n\n\nFeatures of Cash Manager\n\n\nMore specifically, the Cash Manager component supports:\n\n\n\n\ncash register management\n\n\nopening and closing of shifts (a shift being a period of time worked by merchant staff)\n\n\nputting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out)\n\n\nreporting on shift activity for each cash register\n\n\nreporting on cash activity (also known as Z-Reports) for each cash register\n\n\n\n\nFor complete information about the hardware required to use Cash Management, see the \nCash Drawer Manager\n chapter. \n\n\nCashier Base\n\n\nYou also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for:\n\n\n\n\nsupport of PIN-authorized users\n\n\nsupport for ERP Integration (such as SAP By Design)", 
            "title": "Int cash overview"
        }, 
        {
            "location": "/int-cash-overview/#cash-manager-overview", 
            "text": "Cash Management is an optional feature of the Wirecard ePOS SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature.   Most of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the  Cash Drawer Manager , which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user.", 
            "title": "Cash Manager Overview"
        }, 
        {
            "location": "/int-cash-overview/#features-of-cash-manager", 
            "text": "More specifically, the Cash Manager component supports:   cash register management  opening and closing of shifts (a shift being a period of time worked by merchant staff)  putting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out)  reporting on shift activity for each cash register  reporting on cash activity (also known as Z-Reports) for each cash register   For complete information about the hardware required to use Cash Management, see the  Cash Drawer Manager  chapter.", 
            "title": "Features of Cash Manager"
        }, 
        {
            "location": "/int-cash-overview/#cashier-base", 
            "text": "You also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for:   support of PIN-authorized users  support for ERP Integration (such as SAP By Design)", 
            "title": "Cashier Base"
        }, 
        {
            "location": "/int-cash-payinout/", 
            "text": "Pay In/Out\n\n\nWe have seen how to \nopen\n and \nclose\n a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the \npay in\n and the \npay out\n, or sometimes it is referred to as the \ncash in\n and \ncash out\n. \n\n\nYou can report on all cash activity during a shift using \nShift Activity\n, or after the shift is closed you can report on all activity using \nShift Report\n. As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the \nCash Registers\n.\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\n\n\nNote\n\n\nThe Android sample code uses an amount of 200 \u20ac. \n\n\n\n\nThe Sample Code\n\n\nPay ins and pay outs are both recorded in an amount field so it is crucial to note that \npay ins are entered using a positive number\n while \npay outs are entered using a negative number\n. \n\n\n\n\nBigDecimal\n is used in the Java code with a sample value of \n200\n \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac\n\n\namount\n is used in the iOS code with a sample value of \n100\n \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac\n\n\n\n\n\n\nCaution\n\n\nAs the code comments make clear, the cash currency \nmust match the currency\n of the selected cash register.\n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Pay In/Out"
        }, 
        {
            "location": "/int-cash-payinout/#pay-inout", 
            "text": "We have seen how to  open  and  close  a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the  pay in  and the  pay out , or sometimes it is referred to as the  cash in  and  cash out .   You can report on all cash activity during a shift using  Shift Activity , or after the shift is closed you can report on all activity using  Shift Report . As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the  Cash Registers .", 
            "title": "Pay In/Out"
        }, 
        {
            "location": "/int-cash-payinout/#the-user-interface", 
            "text": "A typical interface might look like this:    Note  The Android sample code uses an amount of 200 \u20ac.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-payinout/#the-sample-code", 
            "text": "Pay ins and pay outs are both recorded in an amount field so it is crucial to note that  pay ins are entered using a positive number  while  pay outs are entered using a negative number .    BigDecimal  is used in the Java code with a sample value of  200  \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac  amount  is used in the iOS code with a sample value of  100  \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac    Caution  As the code comments make clear, the cash currency  must match the currency  of the selected cash register.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-register/", 
            "text": "Cash Registers\n\n\nThe first step in dealing with cash is to select a cash register that will be used by the \ncash sale request\n. More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a \ncashRegisters\n object stores the valid cash register identifiers.\n\n\n\n\nTip\n\n\nFor complete information about setting up cash register and cash drawer hardware, see \nCash Drawer Manager\n.\n\n\n\n\nThe User Interface\n\n\nAs illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it:\n\n\n\n\n\n\nNote\n\n\nEven though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device. \n\n\n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of \ncashRegisters\n, you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Cash Registers"
        }, 
        {
            "location": "/int-cash-register/#cash-registers", 
            "text": "The first step in dealing with cash is to select a cash register that will be used by the  cash sale request . More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a  cashRegisters  object stores the valid cash register identifiers.   Tip  For complete information about setting up cash register and cash drawer hardware, see  Cash Drawer Manager .", 
            "title": "Cash Registers"
        }, 
        {
            "location": "/int-cash-register/#the-user-interface", 
            "text": "As illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it:    Note  Even though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-register/#the-sample-code", 
            "text": "The sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of  cashRegisters , you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-shift-activity/", 
            "text": "Shift Activity\n\n\nYou can query all \npay in/out\n activity for:\n\n\n\n\na specific shift and \n\n\na specific cash register \n\n\n\n\nAnd then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using \nCash Registers\n.\n\n\nThe Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Shift Activity"
        }, 
        {
            "location": "/int-cash-shift-activity/#shift-activity", 
            "text": "You can query all  pay in/out  activity for:   a specific shift and   a specific cash register    And then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using  Cash Registers .", 
            "title": "Shift Activity"
        }, 
        {
            "location": "/int-cash-shift-activity/#the-code", 
            "text": "", 
            "title": "The Code"
        }, 
        {
            "location": "/int-cash-shift-close/", 
            "text": "Close Shift\n\n\nAt the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the \nopening of their shift\n. \n\n\nFor both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by \nCash Registers\n.\n\n\nDuring the shift, cash that goes in and out of the cash register is recorded by \nPay In/Out\n. \n\n\n\n\nCaution\n\n\nA \nShift Report\n for a shift can only be generated after a shift is closed. \n\n\n\n\nThe User Interface\n\n\nThe user interface is almost the same as the Open Shift one, but with a couple of key changes:\n\n\n\n\nThe Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Close Shift"
        }, 
        {
            "location": "/int-cash-shift-close/#close-shift", 
            "text": "At the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the  opening of their shift .   For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by  Cash Registers .  During the shift, cash that goes in and out of the cash register is recorded by  Pay In/Out .    Caution  A  Shift Report  for a shift can only be generated after a shift is closed.", 
            "title": "Close Shift"
        }, 
        {
            "location": "/int-cash-shift-close/#the-user-interface", 
            "text": "The user interface is almost the same as the Open Shift one, but with a couple of key changes:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-shift-close/#the-code", 
            "text": "", 
            "title": "The Code"
        }, 
        {
            "location": "/int-cash-shift-open/", 
            "text": "Open Shift\n\n\nJust like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in \nPay In/Out\n. \n\n\nYou must also record the amount of cash in the register when the shift is over. This is referred to as \nclosing the shift\n. For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by \nCash Registers\n.\n\n\n\n\nCaution\n\n\nSales can only be performed after a shift is opened.\n\n\n\n\nThe User Interface\n\n\nOnce again, to visualize what a user interface might look like we created a mockup:\n\n\n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to open the shift for a specific cash register, which includes recording:\n\n\n\n\nthe amount of cash in the drawer which is very important for reconciliation purposes (\namount\n in the iOS code and \nopeningAmount\n in the Android code)\n\n\nand optionally, recording a note related to the opening of the drawer (\nnote\n in the iOS code and \nopeningNote\n in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing\").\n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Open Shift"
        }, 
        {
            "location": "/int-cash-shift-open/#open-shift", 
            "text": "Just like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in  Pay In/Out .   You must also record the amount of cash in the register when the shift is over. This is referred to as  closing the shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by  Cash Registers .   Caution  Sales can only be performed after a shift is opened.", 
            "title": "Open Shift"
        }, 
        {
            "location": "/int-cash-shift-open/#the-user-interface", 
            "text": "Once again, to visualize what a user interface might look like we created a mockup:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-shift-open/#the-sample-code", 
            "text": "The sample code demonstrates how to open the shift for a specific cash register, which includes recording:   the amount of cash in the drawer which is very important for reconciliation purposes ( amount  in the iOS code and  openingAmount  in the Android code)  and optionally, recording a note related to the opening of the drawer ( note  in the iOS code and  openingNote  in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing\").", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-shift-report/", 
            "text": "Shift Report\n\n\nAfter a shift is \nclosed\n, cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes:\n\n\n\n\nopening and closing times\n\n\nopening and closing amounts\n\n\ncashier names\n\n\nsale categories (cash, card or coupon)\n\n\nnet amount\n\n\ngross amount per sale (for purchases and returns)\n\n\ntax charged\n\n\n\n\nThe Shift identifier and Cash Register identifier are both required.\n\n\n\n\nNote\n\n\nA Shift Report is also known as a Z-Report.\n\n\n\n\nThe Sample Code\n\n\nOn both platforms, the \ncashShift\n has all of the information needed to create the Shift Report. \n\n\n\n\nCaution\n\n\nOn both platforms, a shift must first be \nclosed\n before you can generate a shift report.\n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Shift Report"
        }, 
        {
            "location": "/int-cash-shift-report/#shift-report", 
            "text": "After a shift is  closed , cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes:   opening and closing times  opening and closing amounts  cashier names  sale categories (cash, card or coupon)  net amount  gross amount per sale (for purchases and returns)  tax charged   The Shift identifier and Cash Register identifier are both required.   Note  A Shift Report is also known as a Z-Report.", 
            "title": "Shift Report"
        }, 
        {
            "location": "/int-cash-shift-report/#the-sample-code", 
            "text": "On both platforms, the  cashShift  has all of the information needed to create the Shift Report.    Caution  On both platforms, a shift must first be  closed  before you can generate a shift report.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-connect/", 
            "text": "Check Connection Status\n\n\nThe connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code.\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Check Connection Status"
        }, 
        {
            "location": "/int-cashdrawer-connect/#check-connection-status", 
            "text": "The connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code.", 
            "title": "Check Connection Status"
        }, 
        {
            "location": "/int-cashdrawer-connect/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-discovery/", 
            "text": "Cash Drawer Discovery\n\n\nThe device discovery functionality of Cash Drawer Manager:\n\n\n\n\ndiscovers any connected Star Micronics or other cash drawer devices\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nhandles the reception of notifications related to:\n\n\nconnection status\n\n\nbattery levels\n\n\n\n\n\n\n\n\nSo, related to the last point above, there are two main tasks for you:\n\n\n\n\nimplement the \nconnectionStatusDidChange\n\n\nimplement the \nbatteryLevelDidChange\n\n\n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Int cashdrawer discovery"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#cash-drawer-discovery", 
            "text": "The device discovery functionality of Cash Drawer Manager:   discovers any connected Star Micronics or other cash drawer devices  registers to receive device status updates  registers to receive action result updates  handles the reception of notifications related to:  connection status  battery levels     So, related to the last point above, there are two main tasks for you:   implement the  connectionStatusDidChange  implement the  batteryLevelDidChange", 
            "title": "Cash Drawer Discovery"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-open/", 
            "text": "Open Cash Drawer\n\n\nThe sample code in this chapter builds on the code in the \nprevious chapter\n by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins. \n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Open Cash Drawer"
        }, 
        {
            "location": "/int-cashdrawer-open/#open-cash-drawer", 
            "text": "The sample code in this chapter builds on the code in the  previous chapter  by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins.", 
            "title": "Open Cash Drawer"
        }, 
        {
            "location": "/int-cashdrawer-open/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-overview/", 
            "text": "Cash Drawer Manager Overview\n\n\nThis section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:\n\n\n\n\ndiscover paired cash drawers\n\n\nopen cash drawers\n\n\nconnect to Bluetooth cash drawers and check their status", 
            "title": "Int cashdrawer overview"
        }, 
        {
            "location": "/int-cashdrawer-overview/#cash-drawer-manager-overview", 
            "text": "This section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:   discover paired cash drawers  open cash drawers  connect to Bluetooth cash drawers and check their status", 
            "title": "Cash Drawer Manager Overview"
        }, 
        {
            "location": "/int-complete/", 
            "text": "A Complete Sale\n\n\nThis chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the EposSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far.\n\n\nThe User Interface\n\n\nHere's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card:\n\n\n\n\nThe iOS Object Model\n\n\nSince this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the \nadd cash transaction\n and the \nadd card transaction\n methods are used to process the split-method payment from the consumer:\n\n\n\n\n\n\nTip\n\n\nJust like in the \nprevious chapter\n, it is recommended you read the bottom lines of code first to see the overall payment flow.\n\n\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "A Complete Sale"
        }, 
        {
            "location": "/int-complete/#a-complete-sale", 
            "text": "This chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the EposSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far.", 
            "title": "A Complete Sale"
        }, 
        {
            "location": "/int-complete/#the-user-interface", 
            "text": "Here's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-complete/#the-ios-object-model", 
            "text": "Since this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the  add cash transaction  and the  add card transaction  methods are used to process the split-method payment from the consumer:    Tip  Just like in the  previous chapter , it is recommended you read the bottom lines of code first to see the overall payment flow.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-complete/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-customermanager/", 
            "text": "Customer Manager (ERP)\n\n\nIf the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on:\n\n\n\n\nthe unique identifier for the member\n\n\nthe first name\n\n\nthe surname\n\n\n\n\nThe unique identifier for a member can typically be collected by:\n\n\n\n\nscanning a membership card belonging to the consumer\n\n\nscanning a barcode belonging to the consumer\n\n\n\n\nYou can also specify whether you want only exact matches are not, as shown in the sample code. \n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\n\n\nNote\n\n\nIn this example, a consumer's membership card is shown, but a card with a barcode is also usable. \n\n\n\n\nThe Sample Code\n\n\nIn the sample code, a unique identifier for the member is used to obtain information for that member. \n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Int customermanager"
        }, 
        {
            "location": "/int-customermanager/#customer-manager-erp", 
            "text": "If the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on:   the unique identifier for the member  the first name  the surname   The unique identifier for a member can typically be collected by:   scanning a membership card belonging to the consumer  scanning a barcode belonging to the consumer   You can also specify whether you want only exact matches are not, as shown in the sample code.", 
            "title": "Customer Manager (ERP)"
        }, 
        {
            "location": "/int-customermanager/#the-user-interface", 
            "text": "A typical interface might look like this:    Note  In this example, a consumer's membership card is shown, but a card with a barcode is also usable.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-customermanager/#the-sample-code", 
            "text": "In the sample code, a unique identifier for the member is used to obtain information for that member.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-device-overview/", 
            "text": "Device Manger Overview\n\n\nxxx\n\n\nxx", 
            "title": "Device Manger Overview"
        }, 
        {
            "location": "/int-device-overview/#device-manger-overview", 
            "text": "xxx  xx", 
            "title": "Device Manger Overview"
        }, 
        {
            "location": "/int-initialization/", 
            "text": "The SDK Initialization\n\n\nAfter you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.\n\n\nUsing the Public Test Environment\n\n\nAll Wirecard partners who develop with the SDK are provided with:\n\n\n\n\na Wirecard card reader hardware device that can be used for testing purposes\n\n\na user name and password that can be used to access the \nPublic Test\n back-end testing environment\n\n\n\n\n\n\nNote\n\n\nYour user's credentials are usually shipped with expired password so you have to change password after first login.\n\n\n\n\nAs part of your initialization code (a sample of which is shown below), you must \npoint\n the SDK to a back-end \nenvironment\n. An environment essentially means a Switch back-end, as described in the \nmPOS Architecture\n. Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing. All endpoints are accessible also in \nSwagger\n. \n\n\n\n\nNote\n\n\nTalk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email \n with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.\n\n\n\n\n\n\nTip\n\n\nWe often use the term \ncredentials\n to refer to both the user name and the password.\n\n\n\n\nThe Wirecard ePOS class\n\n\nThe highest-level class in the object hierarchy is:\n\n\n\n\nWDePOS\n class for iOS platform\n\n\nEposSdk\n class for Android platform \n\n\n\n\nThe first step in using Wirecard ePOS SDK is to instantiate this object as shown in the sample code below.  \n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to initialize the SDK.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \nNote that the \nWDEnvironmentPublicTest\n is passed to \nsetupWithEnvironment\n method. This points your payment app to the Public Test environment. Substitute your actual user name and password where instead of \nyourUsername\n and \nyourPassword\n. Also note that if there is a current user and a current cashier, both are returned. The cashier is important if you are using the Cash Management functionality of the SDK because every cash operation requires an associated cashier.\n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n        \nAs part of the instantiation, notice in the code below that the \nEnv\n is set to \nSWITCH_TEST\n. This points your payment app to the Public Test Switch back-end. To work properly, valid credentials must be passed so substitute in your actual user name instead of \nusername\n and use your actual password instead of \npassword\n in the \nsetCredentials\n method. Also note that the extensions that you should include will depend on the hardware that you will use with the payment app. The Spire \nSpm2\n terminal is Wirecard's standard card reader device. \nDatecs\n is a commonly used printer.\n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon\n        \n\n    \n\n\n\n\n\n\n\n\n\n\nTip\n\n\nAfter initialization of SDK, you can continue with \nUser Manager\n section or go straight to payments in the \nSales Manager Overview\n section.", 
            "title": "The SDK Initialization"
        }, 
        {
            "location": "/int-initialization/#the-sdk-initialization", 
            "text": "After you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.", 
            "title": "The SDK Initialization"
        }, 
        {
            "location": "/int-initialization/#using-the-public-test-environment", 
            "text": "All Wirecard partners who develop with the SDK are provided with:   a Wirecard card reader hardware device that can be used for testing purposes  a user name and password that can be used to access the  Public Test  back-end testing environment    Note  Your user's credentials are usually shipped with expired password so you have to change password after first login.   As part of your initialization code (a sample of which is shown below), you must  point  the SDK to a back-end  environment . An environment essentially means a Switch back-end, as described in the  mPOS Architecture . Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing. All endpoints are accessible also in  Swagger .    Note  Talk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email   with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.    Tip  We often use the term  credentials  to refer to both the user name and the password.", 
            "title": "Using the Public Test Environment"
        }, 
        {
            "location": "/int-initialization/#the-wirecard-epos-class", 
            "text": "The highest-level class in the object hierarchy is:   WDePOS  class for iOS platform  EposSdk  class for Android platform    The first step in using Wirecard ePOS SDK is to instantiate this object as shown in the sample code below.", 
            "title": "The Wirecard ePOS class"
        }, 
        {
            "location": "/int-initialization/#the-sample-code", 
            "text": "The sample code demonstrates how to initialize the SDK.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-inventory-overview/", 
            "text": "Inventory Manager Overview\n\n\nThe collection of items that a merchant sells is known as their \ninventory\n. An inventory is typically made up of what are referred to as \nproducts\n. \n\n\nLocal or ERP Storage of Product Data\n\n\nIt is important to understand that inventory data can be stored either:\n\n\n\n\nlocally on the merchant's device\n\n\nor centrally in the merchant's back-end ERP system\n\n\n\n\nThis makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage.\n\n\nLocal Storage Methods\n\n\nThe following chapters describe how to handle locally stored product-related data:\n\n\n\n\nMaintain Product Catalogues\n\n\nMaintain Product Categories\n\n\nMaintain Products\n\n\nProduct Changes\n\n\nProduct Images Changes\n\n\n\n\nERP Storage Methods\n\n\nThe following chapters describe how to handle product-related data that is stored in an ERP system:\n\n\n\n\nProduct Stocks (ERP)\n\n\nProduct Prices (ERP)\n\n\n\n\n\n\nNote\n\n\nStock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available.\n\n\n\n\nProducts, Categories and Catalogues\n\n\nThe first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop:\n\n\n\n\nIn this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right):\n\n\n\n\nTulips\n\n\nOrchids\n\n\nRoses\n\n\n\n\nWithin the roses category, there are six products available: \n\n\n\n\nMix (colors)\n\n\nOrange\n\n\nPink\n\n\nPink/Purple\n\n\nRed\n\n\nYellow\n\n\n\n\nThe Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for:\n\n\n\n\nproduct catalogues\n\n\nproduct categories\n\n\nproducts", 
            "title": "Int inventory overview"
        }, 
        {
            "location": "/int-inventory-overview/#inventory-manager-overview", 
            "text": "The collection of items that a merchant sells is known as their  inventory . An inventory is typically made up of what are referred to as  products .", 
            "title": "Inventory Manager Overview"
        }, 
        {
            "location": "/int-inventory-overview/#local-or-erp-storage-of-product-data", 
            "text": "It is important to understand that inventory data can be stored either:   locally on the merchant's device  or centrally in the merchant's back-end ERP system   This makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage.", 
            "title": "Local or ERP Storage of Product Data"
        }, 
        {
            "location": "/int-inventory-overview/#local-storage-methods", 
            "text": "The following chapters describe how to handle locally stored product-related data:   Maintain Product Catalogues  Maintain Product Categories  Maintain Products  Product Changes  Product Images Changes", 
            "title": "Local Storage Methods"
        }, 
        {
            "location": "/int-inventory-overview/#erp-storage-methods", 
            "text": "The following chapters describe how to handle product-related data that is stored in an ERP system:   Product Stocks (ERP)  Product Prices (ERP)    Note  Stock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available.", 
            "title": "ERP Storage Methods"
        }, 
        {
            "location": "/int-inventory-overview/#products-categories-and-catalogues", 
            "text": "The first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop:   In this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right):   Tulips  Orchids  Roses   Within the roses category, there are six products available:    Mix (colors)  Orange  Pink  Pink/Purple  Red  Yellow   The Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for:   product catalogues  product categories  products", 
            "title": "Products, Categories and Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/", 
            "text": "Maintain Product Catalogues\n\n\nA \nproduct catalogue\n represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your \nproduct categories\n and, in turn, your \nproducts\n. \n\n\nThe User Interface\n\n\nFor example, if a store merchant sells flowers, the first page of their catalogue might look like this:\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n\n\nNote\n\n\nOn iOS, the Inventory Manager is implement by \ninventoryManagers\n, while on Android it is implemented by \ninventory()\n.\n\n\n\n\n\n\nTip\n\n\nAs mentioned previously, to understand the overall flow of the iOS code look first at the calls to \nsdk.inventoryManager\n, at the bottom of each segment of code, because this section of code defines the overall process flow. \n\n\n\n\n\n\nCaution\n\n\nIf you are integrating with SAP Business ByDesign, only query actions are allowed.\n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Maintain Product Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#maintain-product-catalogues", 
            "text": "A  product catalogue  represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your  product categories  and, in turn, your  products .", 
            "title": "Maintain Product Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#the-user-interface", 
            "text": "For example, if a store merchant sells flowers, the first page of their catalogue might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.   Note  On iOS, the Inventory Manager is implement by  inventoryManagers , while on Android it is implemented by  inventory() .    Tip  As mentioned previously, to understand the overall flow of the iOS code look first at the calls to  sdk.inventoryManager , at the bottom of each segment of code, because this section of code defines the overall process flow.     Caution  If you are integrating with SAP Business ByDesign, only query actions are allowed.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-maint-prod-categories/", 
            "text": "Maintain Product Categories\n\n\nGroups of related products are known as \nproduct categories\n. Typically, a merchant's \nproduct catalogue\n is divided up into product categories. \n\n\nThe User Interface\n\n\nFor example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips:\n\n\n\n\nThe Sample Code\n\n\nOf course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information. \n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Maintain Product Categories"
        }, 
        {
            "location": "/int-maint-prod-categories/#maintain-product-categories", 
            "text": "Groups of related products are known as  product categories . Typically, a merchant's  product catalogue  is divided up into product categories.", 
            "title": "Maintain Product Categories"
        }, 
        {
            "location": "/int-maint-prod-categories/#the-user-interface", 
            "text": "For example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-prod-categories/#the-sample-code", 
            "text": "Of course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-maint-product/", 
            "text": "Maintain Products\n\n\nWe have seen that the full collection of items for sale is known as the \nproduct catalogue\n, and then sub-divisions of items within a catalogue are referred to as \ncategories\n. At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system).\n\n\nThe User Interface\n\n\nUsing the flower catalogue example, within the rose category a merchant might sell six different types of roses:\n\n\n\n\nThe Code\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information. \n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Maintain Products"
        }, 
        {
            "location": "/int-maint-product/#maintain-products", 
            "text": "We have seen that the full collection of items for sale is known as the  product catalogue , and then sub-divisions of items within a catalogue are referred to as  categories . At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system).", 
            "title": "Maintain Products"
        }, 
        {
            "location": "/int-maint-product/#the-user-interface", 
            "text": "Using the flower catalogue example, within the rose category a merchant might sell six different types of roses:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-product/#the-code", 
            "text": "As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.", 
            "title": "The Code"
        }, 
        {
            "location": "/int-ov-a/", 
            "text": "Epos SDK Design Principles\n\n\nWirecard ePOS SDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on \nRxJava's github\n or the official \nReactiveX webpage\n. Every call to Wirecard ePOS SDK returns an object which extends the observer pattern. It allows you to:\n\n\n\n\nchoose between synchronous or asynchronous results\n\n\nmanage execution and result threads\n\n\nmanage a chain of methods by operators \n\n\nand much more\n\n\n\n\n\n\nNote\n\n\nEvery example in this documentation is using asynchronous approach with lambda expressions.\n\n\n\n\nCompletable, Single, Observable\n\n\nMost methods return \nCompletable\n or \nSingle\n object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK.\nObservable objects can return object defined by generics multiple times.\n\n\nCompletableParallel and SingleParallel\n\n\nThese two objects are special because they contain two separate rx streams:\n\n\n\n\nMain stream contains final result of request and \n\n\nSecond stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method.\n\n\n\n\nHere is a recommended usage: \n\n\nimport\n \ncom.jakewharton.rxrelay2.BehaviorRelay\n;\n\n\nimport\n \ncom.jakewharton.rxrelay2.Relay\n;\n\n\nimport\n \nio.reactivex.android.schedulers.AndroidSchedulers\n;\n\n\n\n\nRelay\nEvent\n \neventObservable\n \n=\n \nBehaviorRelay\n.\ncreate\n();\n\n\n\nepos\n.\nmethodReturnsSingleParallel\n()\n\n    \n.\nsubscribeParallel\n(\neventObservable\n)\n\n    \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n    \n.\nsubscribe\n(\nonSuccess\n \n-\n \n{\n\n            \n//do something on success\n\n        \n},\n \nonError\n \n-\n \n{\n\n            \n//show error\n\n        \n}\n\n    \n);\n\n\n\neventObservable\n\n    \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n    \n.\nsubscribe\n(\nevent\n \n-\n \n{\n\n        \n//do something on event\n\n    \n});\n                                      \n\n\n\n\nSynchronous vs Asynchronous\n\n\nYou can choose which principle suits your algorithms best for every method call. \n\n\nSynchronous Methods\n\n\nA synchronous response can be achieved by calling one of these methods:\n\n\n//completable\n\n\nepos\n.\nmethodReturnsCompletable\n().\nblockingAwait\n()\n    \n//returns void or rethrows any exception emitted\n\n\nepos\n.\nmethodReturnsCompletable\n().\nblockingGet\n()\n      \n//returns null or the emitted exception if any\n\n\n\n//single\n\n\nepos\n.\nmethodReturnsSingle\n().\nblockingGet\n()\n           \n//returns success object or rethrows any exception emitted                                  \n\n\n\n\n\nAsynchronous Methods\n\n\nAn asynchronous response can be achieved by calling the \nsubscribe\n method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came. \n\n\n//completable\n\n\nepos\n.\nmethodReturnsCompletable\n().\nsubscribe\n()\n                                                        \n//returns disposable, ignores all responses\n\n\nepos\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nCompletableObserver\n \ns\n)\n                                   \n//returns disposable, all responses came in given CompletableObserver\n\n\nepos\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nAction\n \nonComplete\n,\n \nConsumer\n?\n \nsuper\n \nThrowable\n \nonError\n)\n  \n//returns disposable, successful responses came in onComplete Action and error in onError\n\n\nepos\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nAction\n \nonComplete\n)\n                                       \n//returns disposable, successful response came in given Action, error is ignored\n\n\n\n//single\n\n\nepos\n.\nmethodReturnsSingle\n().\nsubscribe\n()\n                                                                     \n//returns disposable, ignores all responses\n\n\nepos\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nBiConsumer\n?\n \nsuper\n \nT\n,\n \n?\n \nsuper\n \nThrowable\n \nonCallback\n)\n                  \n//returns disposable, all responses came in given composite BiConsumer callback\n\n\nepos\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nConsumer\n?\n \nsuper\n \nT\n \nonSuccess\n)\n                                        \n//returns disposable, successful response came in given Consumer callback, error is ignored\n\n\nepos\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nConsumer\n?\n \nsuper\n \nT\n \nonSuccess\n,\n \nConsumer\n?\n \nsuper\n \nThrowable\n \nonError\n)\n   \n//returns disposable, successful or error response came in given onSuccess or onError Consumer\n\n\nepos\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nSingleObserver\n?\n \nsuper\n \nT\n \nsubscriber\n)\n                                 \n//returns disposable, all responses came in given SingleObserver                                     \n\n\n\n\n\nThreads\n\n\nThere is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to \nschedulers\n and \nRxAndroid\n. \n\n\nYou can change the result thread by calling observeOn method, as shown:\n\n\nepos\n.\nanyObservableMethod\n()\n\n  \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n  \n.\nsubscribe\n(...);\n                                     \n\n\n\n\nOperators\n\n\nOperators are a very powerful RxJava mechanism. See this \npage\n for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the \nandThen\n and \nflatMap\n operators. \n\n\nepos\n.\nmethodReturnsCompletable\n()\n\n    \n.\nandThen\n(\nepos\n.\nmethodReturnsAnotherCompletable\n())\n\n    \n.\nandThen\n(\nepos\n.\nmethodReturnsSingle\n())\n\n    \n.\nflatMap\n(\npreviousResult\n \n-\n \nepos\n.\nmethodReturnsAnotherSingle\n())\n\n    \n.\nsubscribe\n(...);\n\n\n\n\n\nIs there a non Rx way?\n\n\nIf you're not familiar with RxJava and Rx principles, you can use SDK with \"listeners\" as you're used to. Just call \nsubscribe\n method to every SDK method and put listeners as parameters.\n\n\n//completable\n\n\neposSDK\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nnew\n \nAction\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nrun\n()\n \nthrows\n \nException\n \n{\n\n                \n...\n\n            \n}\n\n        \n},\n \nnew\n \nConsumer\nThrowable\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \naccept\n(\nThrowable\n \nthrowable\n)\n \nthrows\n \nException\n \n{\n\n                \n...\n\n            \n}\n\n        \n});\n\n\neposSDK\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nnew\n \nCompletableObserver\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonSubscribe\n(\nDisposable\n \nd\n)\n \n{\n\n                \n...\n\n            \n}\n\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonComplete\n()\n \n{\n\n                \n...\n\n            \n}\n\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonError\n(\nThrowable\n \ne\n)\n \n{\n\n                \n...\n\n            \n}\n\n        \n});\n\n\n\n//single\n\n\neposSDK\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nnew\n \nBiConsumer\nResponse\n,\n \nThrowable\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \naccept\n(\nResponse\n \nresponse\n,\n \nThrowable\n \nthrowable\n)\n \nthrows\n \nException\n \n{\n\n                \n...\n\n            \n}\n\n        \n});\n\n\neposSDK\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nnew\n \nConsumer\nResponse\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \naccept\n(\nResponse\n \nresponse\n)\n \nthrows\n \nException\n \n{\n\n                \n...\n\n            \n}\n\n        \n},\n \nnew\n \nConsumer\nThrowable\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \naccept\n(\nThrowable\n \nthrowable\n)\n \nthrows\n \nException\n \n{\n\n                \n...\n\n            \n}\n\n        \n});\n\n\neposSDK\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nnew\n \nSingleObserver\nResponse\n()\n \n{\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonSubscribe\n(\nDisposable\n \ndisposable\n)\n \n{\n\n                \n...\n\n            \n}\n\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonSuccess\n(\nResponse\n \nresponse\n)\n \n{\n\n                \n...\n\n            \n}\n\n                \n...\n\n            \n@Override\n\n            \npublic\n \nvoid\n \nonError\n(\nThrowable\n \ne\n)\n \n{\n\n\n            \n}\n\n        \n});", 
            "title": "Epos SDK Design Principles"
        }, 
        {
            "location": "/int-ov-a/#epos-sdk-design-principles", 
            "text": "Wirecard ePOS SDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on  RxJava's github  or the official  ReactiveX webpage . Every call to Wirecard ePOS SDK returns an object which extends the observer pattern. It allows you to:   choose between synchronous or asynchronous results  manage execution and result threads  manage a chain of methods by operators   and much more    Note  Every example in this documentation is using asynchronous approach with lambda expressions.", 
            "title": "Epos SDK Design Principles"
        }, 
        {
            "location": "/int-ov-a/#completable-single-observable", 
            "text": "Most methods return  Completable  or  Single  object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK.\nObservable objects can return object defined by generics multiple times.", 
            "title": "Completable, Single, Observable"
        }, 
        {
            "location": "/int-ov-a/#completableparallel-and-singleparallel", 
            "text": "These two objects are special because they contain two separate rx streams:   Main stream contains final result of request and   Second stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method.   Here is a recommended usage:   import   com.jakewharton.rxrelay2.BehaviorRelay ;  import   com.jakewharton.rxrelay2.Relay ;  import   io.reactivex.android.schedulers.AndroidSchedulers ;  Relay Event   eventObservable   =   BehaviorRelay . create ();  epos . methodReturnsSingleParallel () \n     . subscribeParallel ( eventObservable ) \n     . observeOn ( AndroidSchedulers . mainThread ()) \n     . subscribe ( onSuccess   -   { \n             //do something on success \n         },   onError   -   { \n             //show error \n         } \n     );  eventObservable \n     . observeOn ( AndroidSchedulers . mainThread ()) \n     . subscribe ( event   -   { \n         //do something on event \n     });", 
            "title": "CompletableParallel and SingleParallel"
        }, 
        {
            "location": "/int-ov-a/#synchronous-vs-asynchronous", 
            "text": "You can choose which principle suits your algorithms best for every method call.", 
            "title": "Synchronous vs Asynchronous"
        }, 
        {
            "location": "/int-ov-a/#synchronous-methods", 
            "text": "A synchronous response can be achieved by calling one of these methods:  //completable  epos . methodReturnsCompletable (). blockingAwait ()      //returns void or rethrows any exception emitted  epos . methodReturnsCompletable (). blockingGet ()        //returns null or the emitted exception if any  //single  epos . methodReturnsSingle (). blockingGet ()             //returns success object or rethrows any exception emitted", 
            "title": "Synchronous Methods"
        }, 
        {
            "location": "/int-ov-a/#asynchronous-methods", 
            "text": "An asynchronous response can be achieved by calling the  subscribe  method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came.   //completable  epos . methodReturnsCompletable (). subscribe ()                                                          //returns disposable, ignores all responses  epos . methodReturnsCompletable (). subscribe ( CompletableObserver   s )                                     //returns disposable, all responses came in given CompletableObserver  epos . methodReturnsCompletable (). subscribe ( Action   onComplete ,   Consumer ?   super   Throwable   onError )    //returns disposable, successful responses came in onComplete Action and error in onError  epos . methodReturnsCompletable (). subscribe ( Action   onComplete )                                         //returns disposable, successful response came in given Action, error is ignored  //single  epos . methodReturnsSingle (). subscribe ()                                                                       //returns disposable, ignores all responses  epos . methodReturnsSingle (). subscribe ( BiConsumer ?   super   T ,   ?   super   Throwable   onCallback )                    //returns disposable, all responses came in given composite BiConsumer callback  epos . methodReturnsSingle (). subscribe ( Consumer ?   super   T   onSuccess )                                          //returns disposable, successful response came in given Consumer callback, error is ignored  epos . methodReturnsSingle (). subscribe ( Consumer ?   super   T   onSuccess ,   Consumer ?   super   Throwable   onError )     //returns disposable, successful or error response came in given onSuccess or onError Consumer  epos . methodReturnsSingle (). subscribe ( SingleObserver ?   super   T   subscriber )                                   //returns disposable, all responses came in given SingleObserver", 
            "title": "Asynchronous Methods"
        }, 
        {
            "location": "/int-ov-a/#threads", 
            "text": "There is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to  schedulers  and  RxAndroid .   You can change the result thread by calling observeOn method, as shown:  epos . anyObservableMethod () \n   . observeOn ( AndroidSchedulers . mainThread ()) \n   . subscribe (...);", 
            "title": "Threads"
        }, 
        {
            "location": "/int-ov-a/#operators", 
            "text": "Operators are a very powerful RxJava mechanism. See this  page  for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the  andThen  and  flatMap  operators.   epos . methodReturnsCompletable () \n     . andThen ( epos . methodReturnsAnotherCompletable ()) \n     . andThen ( epos . methodReturnsSingle ()) \n     . flatMap ( previousResult   -   epos . methodReturnsAnotherSingle ()) \n     . subscribe (...);", 
            "title": "Operators"
        }, 
        {
            "location": "/int-ov-a/#is-there-a-non-rx-way", 
            "text": "If you're not familiar with RxJava and Rx principles, you can use SDK with \"listeners\" as you're used to. Just call  subscribe  method to every SDK method and put listeners as parameters.  //completable  eposSDK . methodReturnsCompletable (). subscribe ( new   Action ()   { \n             @Override \n             public   void   run ()   throws   Exception   { \n                 ... \n             } \n         },   new   Consumer Throwable ()   { \n             @Override \n             public   void   accept ( Throwable   throwable )   throws   Exception   { \n                 ... \n             } \n         });  eposSDK . methodReturnsCompletable (). subscribe ( new   CompletableObserver ()   { \n             @Override \n             public   void   onSubscribe ( Disposable   d )   { \n                 ... \n             } \n\n             @Override \n             public   void   onComplete ()   { \n                 ... \n             } \n\n             @Override \n             public   void   onError ( Throwable   e )   { \n                 ... \n             } \n         });  //single  eposSDK . methodReturnsSingle (). subscribe ( new   BiConsumer Response ,   Throwable ()   { \n             @Override \n             public   void   accept ( Response   response ,   Throwable   throwable )   throws   Exception   { \n                 ... \n             } \n         });  eposSDK . methodReturnsSingle (). subscribe ( new   Consumer Response ()   { \n             @Override \n             public   void   accept ( Response   response )   throws   Exception   { \n                 ... \n             } \n         },   new   Consumer Throwable ()   { \n             @Override \n             public   void   accept ( Throwable   throwable )   throws   Exception   { \n                 ... \n             } \n         });  eposSDK . methodReturnsSingle (). subscribe ( new   SingleObserver Response ()   { \n             @Override \n             public   void   onSubscribe ( Disposable   disposable )   { \n                 ... \n             } \n\n             @Override \n             public   void   onSuccess ( Response   response )   { \n                 ... \n             } \n                 ... \n             @Override \n             public   void   onError ( Throwable   e )   { \n\n             } \n         });", 
            "title": "Is there a non Rx way?"
        }, 
        {
            "location": "/int-payment/", 
            "text": "Payment\n\n\nAlright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Payment Config object's sale attribute. So now we can get down to the heavy duty work of processing the payment.\n\n\nThe User Interface\n\n\nFrom the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI.\n\n\n \n\n\nIf the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this:\n\n\n\n\nThe iOS Object Model\n\n\nThe payment flow for purchase sales requests is largely handled by the six methods of the \nSales Manager\n component shown below on the right side of the diagram. The completed sale is delivered in the \nSale Response\n object:\n\n\n\n\nas a \nsale\n object if the processing was successful\n\n\nas an \nerror\n object if the processing was not successful\n\n\n\n\n\n\n\n\nTip\n\n\nIn the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six \nSales Manager\n methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow. \n\n\n\n\nThe Android Object Model\n\n\nThe previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this:\n\n\n\n\nThe Sample Code\n\n\n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                            \n\n                            \n\n                            \nObjC\n\n                            \n\n                                \n\n                            \n\n\n                            \n\n                            \n\n                            \nSwift\n\n                            \n\n                                \n\n                            \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \nThe code demonstrates very simplistic usage of each unit of behaviour\n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        Universal Windows Platform SDK coming soon", 
            "title": "Payment"
        }, 
        {
            "location": "/int-payment/#payment", 
            "text": "Alright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Payment Config object's sale attribute. So now we can get down to the heavy duty work of processing the payment.", 
            "title": "Payment"
        }, 
        {
            "location": "/int-payment/#the-user-interface", 
            "text": "From the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI.     If the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-payment/#the-ios-object-model", 
            "text": "The payment flow for purchase sales requests is largely handled by the six methods of the  Sales Manager  component shown below on the right side of the diagram. The completed sale is delivered in the  Sale Response  object:   as a  sale  object if the processing was successful  as an  error  object if the processing was not successful     Tip  In the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six  Sales Manager  methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-payment/#the-android-object-model", 
            "text": "The previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this:", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-payment/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print-paperstatus/", 
            "text": "Check Paper Status\n\n\nThis sample code illustrates how to report on the paper status of an active mPOP printer.\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Check Paper Status"
        }, 
        {
            "location": "/int-print-paperstatus/#check-paper-status", 
            "text": "This sample code illustrates how to report on the paper status of an active mPOP printer.", 
            "title": "Check Paper Status"
        }, 
        {
            "location": "/int-print-paperstatus/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print-receipt/", 
            "text": "Print Receipt\n\n\nThe \nprevious chapter\n examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including:\n\n\n\n\nreporting on the status of a print job\n\n\nreporting on the final status of a print job\n\n\n\n\nWirecard ePOS Receipt and Image\n\n\nAs the code comments indicate, the Wirecard ePOS Receipt object tends to print quicker than the Image (which is a bitmap) so the sample code shown here prints an WDePosReceipt object. The \nnext chapter\n demonstrates how to handle printing of a Image. \n\n\nThe input for a receipt can either be:\n\n\n\n\na Sale Response object from the payment method of Sales Manager\n\n\na Query object from the Sales Manager\n\n\n\n\nThe sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt.\n\n\nA single receipt, or a collection of receipts, can be printed. \n\n\nThe Sample Code\n\n\nAs is the case with much of the sample code in GIST, we start with the first printer object that is found. \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \n\n            \nObjC\n\n            \n\n                \n\n\n            \n\n\n            \n\n            \n\n            \nSwift\n\n            \n\n                \n\n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        Universal Windows Platform SDK coming soon", 
            "title": "Print Receipt"
        }, 
        {
            "location": "/int-print-receipt/#print-receipt", 
            "text": "The  previous chapter  examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including:   reporting on the status of a print job  reporting on the final status of a print job", 
            "title": "Print Receipt"
        }, 
        {
            "location": "/int-print-receipt/#wirecard-epos-receipt-and-image", 
            "text": "As the code comments indicate, the Wirecard ePOS Receipt object tends to print quicker than the Image (which is a bitmap) so the sample code shown here prints an WDePosReceipt object. The  next chapter  demonstrates how to handle printing of a Image.   The input for a receipt can either be:   a Sale Response object from the payment method of Sales Manager  a Query object from the Sales Manager   The sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt.  A single receipt, or a collection of receipts, can be printed.", 
            "title": "Wirecard ePOS Receipt and Image"
        }, 
        {
            "location": "/int-print-receipt/#the-sample-code", 
            "text": "As is the case with much of the sample code in GIST, we start with the first printer object that is found.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print/", 
            "text": "Print Image\n\n\nThis chapter, like the \nprevious one\n, describes how to print a receipt, but here we use the Image object. A single receipt, collection of receipts or any other image, can be printed. \n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to print an image.\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \nThe code is largely the same as the print of receipt, except that the format in the \nshowReturns\n object of Sale Response now uses: \nAcceptReceiptFormatUIImage\n.\n\n        \n\n            \n\n            \n\n            \nObjC\n\n            \n\n                \n\n            \n\n\n            \n\n            \n\n            \nSwift\n\n            \n\n                \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        Universal Windows Platform SDK coming soon", 
            "title": "Print Image"
        }, 
        {
            "location": "/int-print/#print-image", 
            "text": "This chapter, like the  previous one , describes how to print a receipt, but here we use the Image object. A single receipt, collection of receipts or any other image, can be printed.", 
            "title": "Print Image"
        }, 
        {
            "location": "/int-print/#the-sample-code", 
            "text": "The sample code demonstrates how to print an image.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-printer-discovery/", 
            "text": "Printer Discovery\n\n\nThe discover devices functionality of Printer Manager:\n\n\n\n\ndiscovers any connected Datecs DPP-250 handheld printers\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nprepares Printer Manager for the reception of the data after a barcode is scanned\n\n\n\n\nSo, related to the last point above, the main task for you is to implement a method that handles the \ndataReceived\n. \n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer.\n\n\n\n\nWarning\n\n\nIn the iOS code, the base class needs to conform to \nWDPrinting\n. \n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Int printer discovery"
        }, 
        {
            "location": "/int-printer-discovery/#printer-discovery", 
            "text": "The discover devices functionality of Printer Manager:   discovers any connected Datecs DPP-250 handheld printers  registers to receive device status updates  registers to receive action result updates  prepares Printer Manager for the reception of the data after a barcode is scanned   So, related to the last point above, the main task for you is to implement a method that handles the  dataReceived .", 
            "title": "Printer Discovery"
        }, 
        {
            "location": "/int-printer-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-printer-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer.   Warning  In the iOS code, the base class needs to conform to  WDPrinting .", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-printer-overview/", 
            "text": "Printer Manager Overview\n\n\nThis section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:\n\n\n\n\ndiscover printers\n\n\nprint a single receipt or a collection of receipts\n\n\ncheck the paper status of a printer", 
            "title": "Int printer overview"
        }, 
        {
            "location": "/int-printer-overview/#printer-manager-overview", 
            "text": "This section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:   discover printers  print a single receipt or a collection of receipts  check the paper status of a printer", 
            "title": "Printer Manager Overview"
        }, 
        {
            "location": "/int-prod-changes-images/", 
            "text": "Product Image Changes\n\n\nEach product has an associated image. In this chapter, the sample code illustrates how to retrieve either:\n\n\n\n\nall changed product images\n\n\nor an individual product image that has been changed\n\n\n\n\nTo retrieve individual product images, you need to know the unique product identifier.\n\n\nThe Code\n\n\nIf you want to select a single product image change, then you require the unique identifier for that image and you pass it in the \nproductId\n on iOS, or the \nproductExternalId\n on Android.\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n\nNote\n\n\nOn iOS, the catalogue is identified by \nproductCatalogueId\n, whereas on Android, it is identified by \ncatalogueId\n.  \n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Product Image Changes"
        }, 
        {
            "location": "/int-prod-changes-images/#product-image-changes", 
            "text": "Each product has an associated image. In this chapter, the sample code illustrates how to retrieve either:   all changed product images  or an individual product image that has been changed   To retrieve individual product images, you need to know the unique product identifier.", 
            "title": "Product Image Changes"
        }, 
        {
            "location": "/int-prod-changes-images/#the-code", 
            "text": "If you want to select a single product image change, then you require the unique identifier for that image and you pass it in the  productId  on iOS, or the  productExternalId  on Android.  As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Note  On iOS, the catalogue is identified by  productCatalogueId , whereas on Android, it is identified by  catalogueId .", 
            "title": "The Code"
        }, 
        {
            "location": "/int-prod-changes/", 
            "text": "Product Changes\n\n\nIf the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes:\n\n\n\n\na list of products that have changed since the last synchronization date\n\n\na list of deleted products (according to their identifier)\n\n\n\n\nThe Code\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n\nNote\n\n\nOn iOS, the catalogue is identified by \nproductCatalogueId\n, whereas on Android, it is identified by \ncatalogueId\n.  \n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Product Changes"
        }, 
        {
            "location": "/int-prod-changes/#product-changes", 
            "text": "If the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes:   a list of products that have changed since the last synchronization date  a list of deleted products (according to their identifier)", 
            "title": "Product Changes"
        }, 
        {
            "location": "/int-prod-changes/#the-code", 
            "text": "As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Note  On iOS, the catalogue is identified by  productCatalogueId , whereas on Android, it is identified by  catalogueId .", 
            "title": "The Code"
        }, 
        {
            "location": "/int-product-prices-erp/", 
            "text": "Product Prices (ERP)\n\n\nIf the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed. \n\n\nThe Sample Code\n\n\nThe unique identifier for both the member and each Product is required.  You can validate the unique identifier for the member using the Customer Manager, as described in \nCustomer Manager\n.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Product Prices (ERP)"
        }, 
        {
            "location": "/int-product-prices-erp/#product-prices-erp", 
            "text": "If the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed.", 
            "title": "Product Prices (ERP)"
        }, 
        {
            "location": "/int-product-prices-erp/#the-sample-code", 
            "text": "The unique identifier for both the member and each Product is required.  You can validate the unique identifier for the member using the Customer Manager, as described in  Customer Manager .", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-product-stocks-erp/", 
            "text": "Product Stocks (ERP)\n\n\nIf the merchant for whom you are creating the payment acceptance app chooses ERP integration, you can use Product Stocks to retrieve stock information. Stock refers to the quantity, or total amount, of products available. For example, the stock of red roses might be 100.\n\n\n\n\nNote\n\n\nSee the \nInventory Manager Overview\n for more information about storing product data in an ERP versus storing product data locally.\n\n\n\n\nIf the merchant has more than one shop, you can retrieve information for either:\n\n\n\n\nall shops or \n\n\njust one shop \n\n\n\n\n\n\nTip\n\n\nSupport for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product. \n\n\n\n\nThe Sample Code\n\n\nIf you want to retrieve product stock information for a single shop, you also need to know the unique identifier for the shop. The sample code displays only the first product that is returned. \n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Product Stocks (ERP)"
        }, 
        {
            "location": "/int-product-stocks-erp/#product-stocks-erp", 
            "text": "If the merchant for whom you are creating the payment acceptance app chooses ERP integration, you can use Product Stocks to retrieve stock information. Stock refers to the quantity, or total amount, of products available. For example, the stock of red roses might be 100.   Note  See the  Inventory Manager Overview  for more information about storing product data in an ERP versus storing product data locally.   If the merchant has more than one shop, you can retrieve information for either:   all shops or   just one shop     Tip  Support for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product.", 
            "title": "Product Stocks (ERP)"
        }, 
        {
            "location": "/int-product-stocks-erp/#the-sample-code", 
            "text": "If you want to retrieve product stock information for a single shop, you also need to know the unique identifier for the shop. The sample code displays only the first product that is returned.   As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-sale-model/", 
            "text": "Sales Request Object Model", 
            "title": "Sales Request Object Model"
        }, 
        {
            "location": "/int-sale-model/#sales-request-object-model", 
            "text": "", 
            "title": "Sales Request Object Model"
        }, 
        {
            "location": "/int-sale-overview/", 
            "text": "Sales Manager Overview\n\n\nThe objective of every merchant is to complete sales and make a profit so the Sale Managers component is probably the most important API in the Wirecard ePOS SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a \ncash sale request\n. The chapter after that describes how to handle a \ncard sale request\n.\nCombination of payment methods is currently not supported.\n\n\nA Sample User Interface\n\n\nTo help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request.\n\n\n\n\nMinimum Information for a Sales Request\n\n\nMost importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object:\n\n\n\n\ntotal \namount\n of sale\n\n\ncurrency\n\n\ninclusive / exclusive \ntax\n indicator\n\n\npayment method\n (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being:\n\n\nCard (i.e. Visa and Mastercard)\n\n\nCash\n\n\nAlipay\n\n\nWeChat Pay\n\n\n\n\n\n\nsale items\n are conditional. Required if you have enabled cash management, optional otherwise. For each individual item, you need to provide at least:\n\n\nType of item\n\n\nPrice\n\n\nQuantity\n\n\nTax to be charged\n\n\nTotal amount of item (basically price multiplied by quantity with respect to discount and tax)\n\n\n\n\n\n\nid of \ncash register\n is also conditional. Required if you have enabled cash management, optional otherwise.\n\n\nrest of parameters are optional\n\n\n\n\n\n\nNote\n\n\nFor simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.", 
            "title": "Int sale overview"
        }, 
        {
            "location": "/int-sale-overview/#sales-manager-overview", 
            "text": "The objective of every merchant is to complete sales and make a profit so the Sale Managers component is probably the most important API in the Wirecard ePOS SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a  cash sale request . The chapter after that describes how to handle a  card sale request .\nCombination of payment methods is currently not supported.", 
            "title": "Sales Manager Overview"
        }, 
        {
            "location": "/int-sale-overview/#a-sample-user-interface", 
            "text": "To help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request.", 
            "title": "A Sample User Interface"
        }, 
        {
            "location": "/int-sale-overview/#minimum-information-for-a-sales-request", 
            "text": "Most importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object:   total  amount  of sale  currency  inclusive / exclusive  tax  indicator  payment method  (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being:  Card (i.e. Visa and Mastercard)  Cash  Alipay  WeChat Pay    sale items  are conditional. Required if you have enabled cash management, optional otherwise. For each individual item, you need to provide at least:  Type of item  Price  Quantity  Tax to be charged  Total amount of item (basically price multiplied by quantity with respect to discount and tax)    id of  cash register  is also conditional. Required if you have enabled cash management, optional otherwise.  rest of parameters are optional    Note  For simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.", 
            "title": "Minimum Information for a Sales Request"
        }, 
        {
            "location": "/int-salereceipt/", 
            "text": "Sale Receipt\n\n\nIn addition to the receipt generation and printing (see \nPrinter Manager section\n ), Wirecard ePOS SDK offers the option of sending the Sale receipt, filled with your sale data, to the chosen destination (currently, only e-mail method is supported, but we plan on including SMS in the future). This is done based on the ID of already finalized sale, the state of that sale and the method you chose for sending.\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Sale Receipt"
        }, 
        {
            "location": "/int-salereceipt/#sale-receipt", 
            "text": "In addition to the receipt generation and printing (see  Printer Manager section  ), Wirecard ePOS SDK offers the option of sending the Sale receipt, filled with your sale data, to the chosen destination (currently, only e-mail method is supported, but we plan on including SMS in the future). This is done based on the ID of already finalized sale, the state of that sale and the method you chose for sending.", 
            "title": "Sale Receipt"
        }, 
        {
            "location": "/int-salereceipt/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/", 
            "text": "Sale Request - Alternative Payment\n\n\nCurrently we do support two types of Alternative Payments:\n\n\n\n\nAlipay\n\n\nWeChat Quickpay\n\n\n\n\nThe User Interface\n\n\nThe UI presents Alipay and WeChat as an alternative payment methods. At the time of payment it is necessary to select which payment method to use for settling the sale. After tapping on one of the alternative payment method it is necessary to present UI for capturing the QRCode - Alipay or WeChat as preferred by the customer.\n\n\n\n\n\n\nNote\n\n\nIt is your responsibility to capture the QRCode and use the resulting data when adding the Alipay or  WeChat payment into the Sale.\n\n\n\n\nOf course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.\n\n\nThe iOS Object Model\n\n\nThe diagram below shows the key objects involved in the processing of a Alipay/WeChat sale request. \n\n\n\n\n\n\nNote\n\n\nThe object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the \nWDePos\n, which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is \nWDSaleRequest\n but that is tough to read, so we display it as \nSale Request\n instead. We do the same with method names. For example, the method \nadd Alipay payment\n, shown above, is implemented in Objective-C and Swift as \naddAlipayPayment\n. The similar is true for \nadd WeChat payment\n.\n\n\n\n\nThe iOS Process Flow\n\n\nThe process flow in the code is as follows:\n\n\n\n\n Instantiate a \nSale Request\n object.\n\n\n The \ntype\n attribute of \nSale Request\n defines the type of sale request, most commonly a \nPurchase\n.\n\n\n Add details to the Sale Request object with the \nadd sale item\n method. \n\n\n For Alipay transactions, use the \nadd alipay payment\n method. \n\n\n For WeChat transactions, use the \nadd wechat payment\n method. \n\n\n\n\n\n\n Pass the full details of the \nSale Request\n to the \nPayment Config\n object in the \nsale\n property.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Android Object Model\n\n\nThe Sales Manager component in Android is implemented as the \nsales()\n method of the \nEposSDK\n class. The \nSales Builder\n then does most of the work as shown:\n\n\n\n\nThe Android Process Flow\n\n\nThe process flow is:\n\n\n\n\n Create an \nitems\n object with a \nSale Item Type\n of \nPurchase\n. \n\n\n Use \nSale Builder\n to create the sale request.\n\n\n Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with \npay(Sales Builder)\n.\n\n\n The \nadd alipay payment\n method indicates that the full amount of the sale is paid with Alipay (i.e., 10 \u20ac).\n\n\n The \nadd wechat payment\n method indicates that the full amount of the sale is paid with WeChat (i.e., 10 \u20ac).    * \n\n\n\n\n\n\n A \nsaleId\n string is returned which has the complete sale object.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Sample Code\n\n\nBefore jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.\n\n\n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                            \n\n                            \n\n                            \nObjC\n\n                            \n\n                                \n\n                            \n\n\n                            \n\n                            \n\n                            \nSwift\n\n                            \n\n                                \n\n                            \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                                \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        Universal Windows Platform SDK coming soon", 
            "title": "Sale Request - Alternative Payment"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#sale-request-alternative-payment", 
            "text": "Currently we do support two types of Alternative Payments:   Alipay  WeChat Quickpay", 
            "title": "Sale Request - Alternative Payment"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-user-interface", 
            "text": "The UI presents Alipay and WeChat as an alternative payment methods. At the time of payment it is necessary to select which payment method to use for settling the sale. After tapping on one of the alternative payment method it is necessary to present UI for capturing the QRCode - Alipay or WeChat as preferred by the customer.    Note  It is your responsibility to capture the QRCode and use the resulting data when adding the Alipay or  WeChat payment into the Sale.   Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-ios-object-model", 
            "text": "The diagram below shows the key objects involved in the processing of a Alipay/WeChat sale request.     Note  The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the  WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is  WDSaleRequest  but that is tough to read, so we display it as  Sale Request  instead. We do the same with method names. For example, the method  add Alipay payment , shown above, is implemented in Objective-C and Swift as  addAlipayPayment . The similar is true for  add WeChat payment .", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-ios-process-flow", 
            "text": "The process flow in the code is as follows:    Instantiate a  Sale Request  object.   The  type  attribute of  Sale Request  defines the type of sale request, most commonly a  Purchase .   Add details to the Sale Request object with the  add sale item  method.    For Alipay transactions, use the  add alipay payment  method.    For WeChat transactions, use the  add wechat payment  method.      Pass the full details of the  Sale Request  to the  Payment Config  object in the  sale  property.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The iOS Process Flow"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-android-object-model", 
            "text": "The Sales Manager component in Android is implemented as the  sales()  method of the  EposSDK  class. The  Sales Builder  then does most of the work as shown:", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-android-process-flow", 
            "text": "The process flow is:    Create an  items  object with a  Sale Item Type  of  Purchase .    Use  Sale Builder  to create the sale request.   Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with  pay(Sales Builder) .   The  add alipay payment  method indicates that the full amount of the sale is paid with Alipay (i.e., 10 \u20ac).   The  add wechat payment  method indicates that the full amount of the sale is paid with WeChat (i.e., 10 \u20ac).    *      A  saleId  string is returned which has the complete sale object.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The Android Process Flow"
        }, 
        {
            "location": "/int-salerequest-alternativePayment/#the-sample-code", 
            "text": "Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salerequest-card/", 
            "text": "Sale Request - Card\n\n\nYou should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device. \n\n\nThe User Interface\n\n\nLet's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user. \n\n\n\n\nThe same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the \nprevious chapter\n.\n\n\nCode Differences with Credit Sale Request\n\n\nThe key differences between the cash code and the credit code presented in this topic are:\n\n\n\n\nTerminal Manager\n is used to \ndiscover Devices\n and the results are placed into:\n\n\nan array of \nterminals\n in the iOS code\n\n\na \nterminalDevice\n object in the Android code.\n\n\n\n\n\n\nThe \nadd card payment\n method is used instead of the \nadd cash payment\n method. The \nadd card payment\n method uses the discovered terminal.\n\n\n\n\nThat's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models.\n\n\nThe iOS Object Model\n\n\nAn expanded version of the iOS object model is shown below. It now shows the \nadd card payment\n method and the \nTerminal Manager\n component and illustrates how they collaborate together.\n\n\n\n\n\n\nTip\n\n\nIf you are a little overwhelmed at this point, don't worry about it. The \nPayment Flow\n chapter provides a good review which covers card and cash payments on iOS a second time. \n\n\n\n\nThe Android Object Model\n\n\nThe Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the \neventRelay\n takes over and handles various events that can take place on the terminal, such as \nSignature Request\n, \nSignature Confirmation\n and so forth.\n\n\n\n\n\n\nNote\n\n\nSignature Request and Signature Confirmation on iOS are covered in the \nPayment Flow\n chapter. In addition, a sample UI for handling these user actions is presented in that chapter.\n\n\n\n\nThe Sample Code\n\n\n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                            \n\n                            \n\n                            \nObjC\n\n                            \n\n\n                                \n\n                            \n\n\n                            \n\n                            \n\n                            \nSwift\n\n                            \n\n\n                                \n\n                            \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        Universal Windows Platform SDK coming soon", 
            "title": "Sale Request - Card"
        }, 
        {
            "location": "/int-salerequest-card/#sale-request-card", 
            "text": "You should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device.", 
            "title": "Sale Request - Card"
        }, 
        {
            "location": "/int-salerequest-card/#the-user-interface", 
            "text": "Let's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user.    The same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the  previous chapter .", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-salerequest-card/#code-differences-with-credit-sale-request", 
            "text": "The key differences between the cash code and the credit code presented in this topic are:   Terminal Manager  is used to  discover Devices  and the results are placed into:  an array of  terminals  in the iOS code  a  terminalDevice  object in the Android code.    The  add card payment  method is used instead of the  add cash payment  method. The  add card payment  method uses the discovered terminal.   That's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models.", 
            "title": "Code Differences with Credit Sale Request"
        }, 
        {
            "location": "/int-salerequest-card/#the-ios-object-model", 
            "text": "An expanded version of the iOS object model is shown below. It now shows the  add card payment  method and the  Terminal Manager  component and illustrates how they collaborate together.    Tip  If you are a little overwhelmed at this point, don't worry about it. The  Payment Flow  chapter provides a good review which covers card and cash payments on iOS a second time.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-salerequest-card/#the-android-object-model", 
            "text": "The Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the  eventRelay  takes over and handles various events that can take place on the terminal, such as  Signature Request ,  Signature Confirmation  and so forth.    Note  Signature Request and Signature Confirmation on iOS are covered in the  Payment Flow  chapter. In addition, a sample UI for handling these user actions is presented in that chapter.", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-salerequest-card/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salerequest-cash/", 
            "text": "Sale Request - Cash\n\n\nLet's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component.  \n\n\nThe User Interface\n\n\nThe starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single \nItem 1\n is being purchased at a price of \n10.00 \u20ac\n and the tax rate is \n20.00%\n. In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the \nCash\n button. \n\n\n\n\n\n\nTip\n\n\nFor our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as \nEUR\n.\n\n\n\n\nOf course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.\n\n\nThe iOS Design\n\n\nThe Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow.\n\n\nThe iOS Object Model\n\n\nThe diagram below shows the key objects involved in the processing of a cash sale request. \n\n\n\n\n\n\nNote\n\n\nThe object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the \nWDePos\n, which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is \nWDSaleRequest\n but that is tough to read, so we display it as \nSale Request\n instead. We do the same with method names. For example, the method \nadd cash payment\n, shown above, is implemented in Objective-C and Swift as \naddCashPayment\n.\n\n\n\n\nThe iOS Process Flow\n\n\nThe process flow in the code is as follows:\n\n\n\n\n Instantiate a \nSale Request\n object.\n\n\n The \ntype\n attribute of \nSale Request\n defines the type of sale request, most commonly a \nPurchase\n.\n\n\n Add details to the Sale Request object with the \nadd sale item\n method. \n\n\n For cash transactions, use the \nadd cash payment\n method. \n\n\n\n\n\n\n Pass the full details of the \nSale Request\n to the \nPayment Config\n object in the \nsale\n property.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Android Design\n\n\nThe Android design and process flow is described below.\n\n\nThe Android Object Model\n\n\nThe Sales Manager component in Android is implemented as the \nsales()\n method of the \nEposSDK\n class. The \nSales Builder\n then does most of the work as shown:\n\n\n\n\nThe Android Process Flow\n\n\nThe process flow is:\n\n\n\n\n Create an \nitems\n object with a \nSale Item Type\n of \nPurchase\n. \n\n\n Use \nSale Builder\n to create the sale request.\n\n\n Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with \npay(Sales Builder)\n.\n\n\n The \nadd cash payment\n method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac).\n\n\n\n\n\n\n A \nsaleId\n string is returned which has the complete sale object.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Sample Code\n\n\nBefore jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.\n\n\n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                            \n\n                            \n\n                            \nObjC\n\n                            \n\n                                \n\n                                \n\n                            \n\n\n                            \n\n                            \n\n                            \nSwift\n\n                            \n\n                                \n\n                                \n\n                            \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \n\n                    \n\n                \n\n                \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        Universal Windows Platform SDK coming soon", 
            "title": "Sale Request - Cash"
        }, 
        {
            "location": "/int-salerequest-cash/#sale-request-cash", 
            "text": "Let's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component.", 
            "title": "Sale Request - Cash"
        }, 
        {
            "location": "/int-salerequest-cash/#the-user-interface", 
            "text": "The starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single  Item 1  is being purchased at a price of  10.00 \u20ac  and the tax rate is  20.00% . In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the  Cash  button.     Tip  For our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as  EUR .   Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-design", 
            "text": "The Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow.", 
            "title": "The iOS Design"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-object-model", 
            "text": "The diagram below shows the key objects involved in the processing of a cash sale request.     Note  The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the  WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is  WDSaleRequest  but that is tough to read, so we display it as  Sale Request  instead. We do the same with method names. For example, the method  add cash payment , shown above, is implemented in Objective-C and Swift as  addCashPayment .", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-process-flow", 
            "text": "The process flow in the code is as follows:    Instantiate a  Sale Request  object.   The  type  attribute of  Sale Request  defines the type of sale request, most commonly a  Purchase .   Add details to the Sale Request object with the  add sale item  method.    For cash transactions, use the  add cash payment  method.      Pass the full details of the  Sale Request  to the  Payment Config  object in the  sale  property.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The iOS Process Flow"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-design", 
            "text": "The Android design and process flow is described below.", 
            "title": "The Android Design"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-object-model", 
            "text": "The Sales Manager component in Android is implemented as the  sales()  method of the  EposSDK  class. The  Sales Builder  then does most of the work as shown:", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-process-flow", 
            "text": "The process flow is:    Create an  items  object with a  Sale Item Type  of  Purchase .    Use  Sale Builder  to create the sale request.   Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with  pay(Sales Builder) .   The  add cash payment  method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac).     A  saleId  string is returned which has the complete sale object.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The Android Process Flow"
        }, 
        {
            "location": "/int-salerequest-cash/#the-sample-code", 
            "text": "Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salereturns/", 
            "text": "Sale Return\n\n\nSometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a \nfull refund\n is required. If the consumer only wants to return a portion of their purchase, then a \npartial refund\n is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund.  \n\n\n\n\nNote\n\n\nIn the case of a card payment, the return amount is processed directly to the card that was used for payment.\n\n\n\n\n\n\nTip\n\n\nAt the time of a return, you may also want to look up the \nSale History\n so you can see the full details of the sale.\n\n\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Sale Return"
        }, 
        {
            "location": "/int-salereturns/#sale-return", 
            "text": "Sometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a  full refund  is required. If the consumer only wants to return a portion of their purchase, then a  partial refund  is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund.     Note  In the case of a card payment, the return amount is processed directly to the card that was used for payment.    Tip  At the time of a return, you may also want to look up the  Sale History  so you can see the full details of the sale.", 
            "title": "Sale Return"
        }, 
        {
            "location": "/int-salereturns/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salereversals/", 
            "text": "Sale Reversal\n\n\nA sale reversal is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported.\n\n\n\n\nNote\n\n\nIf the merchant is using Cash Management, the Cash Register Id method needs to be called.\n\n\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Sale Reversal"
        }, 
        {
            "location": "/int-salereversals/#sale-reversal", 
            "text": "A sale reversal is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported.   Note  If the merchant is using Cash Management, the Cash Register Id method needs to be called.", 
            "title": "Sale Reversal"
        }, 
        {
            "location": "/int-salereversals/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-saleshistory/", 
            "text": "Sales History\n\n\nThe sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a \nquery\n is constructed that includes attributes such as:\n\n\n\n\npaging information\n\n\nordering information\n\n\nstart date\n\n\nend date\n\n\n\n\n\n\nTip\n\n\nSales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as \nsaleManager\n, whereas in Java it is implemented as \nsales()\n. \n\n\n\n\nThe Sample Code\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \n\n            \nObjC\n\n            \n\n                \n\n            \n\n\n            \n\n            \n\n            \nSwift\n\n            \n\n                \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        Universal Windows Platform SDK coming soon", 
            "title": "Sales History"
        }, 
        {
            "location": "/int-saleshistory/#sales-history", 
            "text": "The sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a  query  is constructed that includes attributes such as:   paging information  ordering information  start date  end date    Tip  Sales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as  saleManager , whereas in Java it is implemented as  sales() .", 
            "title": "Sales History"
        }, 
        {
            "location": "/int-saleshistory/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salesstatistics/", 
            "text": "Sales Statistics\n\n\nYou frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics. \n\n\nTo get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include:\n\n\n\n\nMIN - amount of the smallest sale\n\n\nMAX - amount of the largest sale\n\n\nTurnover\n\n\nTransaction Counts\n\n\n\n\nThe sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the \nsaleStatistics\n object has the results of the query. In the Android code, the \nsalesStatistics\n has the results.\n\n\n\n\nTip\n\n\nThe Java code uses the term \nfilter\n while the Objective-C code uses the term \nquery\n.\n\n\n\n\nThe Sample Code\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \n\n            \nObjC\n\n            \n\n                \n\n            \n\n\n            \n\n            \n\n            \nSwift\n\n            \n\n                \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        Universal Windows Platform SDK coming soon", 
            "title": "Sales Statistics"
        }, 
        {
            "location": "/int-salesstatistics/#sales-statistics", 
            "text": "You frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics.   To get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include:   MIN - amount of the smallest sale  MAX - amount of the largest sale  Turnover  Transaction Counts   The sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the  saleStatistics  object has the results of the query. In the Android code, the  salesStatistics  has the results.   Tip  The Java code uses the term  filter  while the Objective-C code uses the term  query .", 
            "title": "Sales Statistics"
        }, 
        {
            "location": "/int-salesstatistics/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-scanner-discovery/", 
            "text": "Scanner Discovery\n\n\nThe discover devices functionality of Scanner Manager:\n\n\n\n\ndiscovers any connected handheld barcode scanning devices\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nprepares Scanner Manager for the reception of the data after the barcode is scanned\n\n\n\n\nSo, related to the last point above, the main task for you is to implement a method that handles the \ndataReceived\n. \n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.\n\n\n\n\nWarning\n\n\nIn the iOS Code The base class needs to conform to \nWDScanning\n. \n\n\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Int scanner discovery"
        }, 
        {
            "location": "/int-scanner-discovery/#scanner-discovery", 
            "text": "The discover devices functionality of Scanner Manager:   discovers any connected handheld barcode scanning devices  registers to receive device status updates  registers to receive action result updates  prepares Scanner Manager for the reception of the data after the barcode is scanned   So, related to the last point above, the main task for you is to implement a method that handles the  dataReceived .", 
            "title": "Scanner Discovery"
        }, 
        {
            "location": "/int-scanner-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-scanner-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.   Warning  In the iOS Code The base class needs to conform to  WDScanning .", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-scanner-overview/", 
            "text": "Scanner Manager Overview\n\n\nThis section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.", 
            "title": "Int scanner overview"
        }, 
        {
            "location": "/int-scanner-overview/#scanner-manager-overview", 
            "text": "This section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.", 
            "title": "Scanner Manager Overview"
        }, 
        {
            "location": "/int-scannermanager/", 
            "text": "Scanner Manager\n\n\nxxx\n\n\nThe Object Model\n\n\nxxx\n\n\nThe Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//The base class needs to conform to WDAcceptScanning\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nscannerManager\n]\n \ndiscoverDevices\n:\nWDASocketExtensionUUID\n \n//Get the active SocketScanner handheld barcode scanner\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Scanner delegate to receive the data after the barcode was read\n\n                               \n//Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived;\n\n                               \n[[\nsdk\n \nscannerManager\n]\n \naddScannerManagerDelegate\n:\nself\n\n                                                             \nforScanner\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we will use the first active SocketScanner device\n\n                           \n}];", 
            "title": "Scanner Manager"
        }, 
        {
            "location": "/int-scannermanager/#scanner-manager", 
            "text": "xxx", 
            "title": "Scanner Manager"
        }, 
        {
            "location": "/int-scannermanager/#the-object-model", 
            "text": "xxx", 
            "title": "The Object Model"
        }, 
        {
            "location": "/int-scannermanager/#the-code", 
            "text": "Insert GIST here and remove Objective-C below.  //The base class needs to conform to WDAcceptScanning  //Discover active devices  [[ sdk   scannerManager ]   discoverDevices : WDASocketExtensionUUID   //Get the active SocketScanner handheld barcode scanner \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Scanner delegate to receive the data after the barcode was read \n                                //Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived; \n                                [[ sdk   scannerManager ]   addScannerManagerDelegate : self \n                                                              forScanner :[ devices   firstObject ]]; //for simplicity we will use the first active SocketScanner device \n                            }];", 
            "title": "The Code"
        }, 
        {
            "location": "/int-setup-android-gradle/", 
            "text": "Set up with Gradle\n\n\nHassle-free setup on Android is now available with v2.0 of the SDK, using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build. \n\n\n\n\nCaution\n\n\nThe minimum API level supported by this library is API 16 (Jelly Bean). \n\n\n\n\nAdd the following lines to your root \nbuild.gradle\n file to include the SDK in your Android Studio project:\n\n\n\n    \n\n        \n\n            \n\n\n        \n\n    \n\n\n\n\n\n\n\n\n\n\nTip\n\n\nAfter set up of SDK, you can continue with \nSDK Initialization\n section.", 
            "title": "Set up with Gradle"
        }, 
        {
            "location": "/int-setup-android-gradle/#set-up-with-gradle", 
            "text": "Hassle-free setup on Android is now available with v2.0 of the SDK, using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build.    Caution  The minimum API level supported by this library is API 16 (Jelly Bean).    Add the following lines to your root  build.gradle  file to include the SDK in your Android Studio project:  \n     \n         \n             \n\n         \n         Tip  After set up of SDK, you can continue with  SDK Initialization  section.", 
            "title": "Set up with Gradle"
        }, 
        {
            "location": "/int-setup-android-manual/", 
            "text": "Set up Manually\n\n\n\n\nCaution\n\n\nSet up Manually is not recommended way, but it's still available. Definitely see \nSet up with Gradle\n section. \n\n\nThe minimum API level supported by this library is API 16 (Jelly Bean).\n\n\n\n\nFollow the steps listed below to set up the Wirecard ePOS SDK for Android manually:\n\n\n\n\nOpen \nJFrog Bintray\n repository website, where you can find all SDK's modules.\n\n\nFor each library, in \nFiles\n section, and appropriate \nversion\n folder, locate an .aar files.\n\n\nManually download those .aar files to the \nlibs\n folder in your project.\n\n\nMake sure, you have \nflatDir { dirs \nlibs\n }\n in your project build.gradle file.\n\n\nAdd a dependency in the module build.gradle file e.g. \ncompile(name:\u00a0\nnameOfLibrary-version\n,\u00a0ext:\u00a0\naar\n)\n.\n\n\n\n\n\n\nTip\n\n\nAfter set up of SDK, you can continue with \nSDK Initialization\n section.", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-setup-android-manual/#set-up-manually", 
            "text": "Caution  Set up Manually is not recommended way, but it's still available. Definitely see  Set up with Gradle  section.   The minimum API level supported by this library is API 16 (Jelly Bean).   Follow the steps listed below to set up the Wirecard ePOS SDK for Android manually:   Open  JFrog Bintray  repository website, where you can find all SDK's modules.  For each library, in  Files  section, and appropriate  version  folder, locate an .aar files.  Manually download those .aar files to the  libs  folder in your project.  Make sure, you have  flatDir { dirs  libs  }  in your project build.gradle file.  Add a dependency in the module build.gradle file e.g.  compile(name:\u00a0 nameOfLibrary-version ,\u00a0ext:\u00a0 aar ) .    Tip  After set up of SDK, you can continue with  SDK Initialization  section.", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-setup-ios-cocoa/", 
            "text": "Set up with Cocoapods (Recommended)\n\n\nThe setup process for the Wirecard ePOS SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to \nset up the SDK manually\n because all setup files are available on the \nGithub repository for iOS\n. \n\n\nBefore starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the \nCocoaPods site\n. \n\n\nTo add the Wirecard ePOS SDK to your application, create a Podfile and then:\n\n\n\n\nOpen the Podfile in a text editor.\n\n\nAdd the below lines to the Podfile\n\nplatform\n \n:\nios\n,\n \n9.0\n\n\nuse_frameworks\n!\n\n\ntarget\n \nYourTarget\n \ndo\n\n    \npod\n \nWDePOS/All\n\n\nend\n\n\n\nThat's it. Only couple of lines are required to install the SDK into your app. Note: If you want to use more than one target then you must explicitly state this in your Podfile.\n\n\n\n\n\n\nTip\n\nIf you encounter issues with pod install please run 'pod repo update' to upgrade your cocoapods\n\npod repo update\n\n\n\n\n\n\n\n\n\nIn the folder where your podfile is stored, run \npod install\n to install a new pod. Or run \npod update\n to update your current one.\nThis downloads and installs the SDK from Cocoapods and it creates the workspace for your application. \nThe \nExample\n folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The \niOS Integration Tests\n chapter has more information. \n\n\nShould you wish to use BlueTooth devices (Terminals, Printers, Cash Registers) you need to include UISupportedExternalAccessoryProtocols settings in your application plist file:\n\n\n\n\n\n\n\n\n\n\nDevice Vendor\n\n\nAccessory protocol\n\n\n\n\n\n\n\n\n\n\nSpire\n\n\ncom.thyron\n\n\n\n\n\n\nStarMicronics / StarIO\n\n\njp.star-m.starpro\n\n\n\n\n\n\nDatecs\n\n\ncom.datecs.printer.escpos\n\n\n\n\n\n\nSocketMobile\n\n\ncom.socketmobile.chs\n\n\n\n\n\n\nMiura\n\n\ncom.miura.shuttle, com.miura.rpi\n\n\n\n\n\n\nBBPOS\n\n\ncom.bbpos.bt.wisepad\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is WDePOS in the path in the directory one level above the current Example app project.", 
            "title": "Set up with Cocoapods (Recommended)"
        }, 
        {
            "location": "/int-setup-ios-cocoa/#set-up-with-cocoapods-recommended", 
            "text": "The setup process for the Wirecard ePOS SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to  set up the SDK manually  because all setup files are available on the  Github repository for iOS .   Before starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the  CocoaPods site .   To add the Wirecard ePOS SDK to your application, create a Podfile and then:   Open the Podfile in a text editor.  Add the below lines to the Podfile platform   : ios ,   9.0  use_frameworks !  target   YourTarget   do \n     pod   WDePOS/All  end  \nThat's it. Only couple of lines are required to install the SDK into your app. Note: If you want to use more than one target then you must explicitly state this in your Podfile.    Tip \nIf you encounter issues with pod install please run 'pod repo update' to upgrade your cocoapods pod repo update     In the folder where your podfile is stored, run  pod install  to install a new pod. Or run  pod update  to update your current one.\nThis downloads and installs the SDK from Cocoapods and it creates the workspace for your application. \nThe  Example  folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The  iOS Integration Tests  chapter has more information.   Should you wish to use BlueTooth devices (Terminals, Printers, Cash Registers) you need to include UISupportedExternalAccessoryProtocols settings in your application plist file:      Device Vendor  Accessory protocol      Spire  com.thyron    StarMicronics / StarIO  jp.star-m.starpro    Datecs  com.datecs.printer.escpos    SocketMobile  com.socketmobile.chs    Miura  com.miura.shuttle, com.miura.rpi    BBPOS  com.bbpos.bt.wisepad      Note  The workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is WDePOS in the path in the directory one level above the current Example app project.", 
            "title": "Set up with Cocoapods (Recommended)"
        }, 
        {
            "location": "/int-setup-ios-manual/", 
            "text": "Set up using Carthage\n\n\nThe SDK supports installation using the \nCarthage dependency manager\n.\nJust run the carthage update command in the SDK root directory and get the WDePOS and related frameworks from \nCarthage/Build/\nplatform\n directory\n\n\ncarthage update\n\n\n\n\nSet up Manually (Not Recommended)\n\n\nTo manually install the SDK:\n\n\n\n\n\n\nMake sure you have \ncocoapods\n installed. \n\n\n\n\n\n\nDownload the SDK from \nWirecard ePOS SDK for iOS repository on Github\n.\n\n\n\n\nUnzip it and run 'pod install' within \"unzipped_SDK/Example\" folder.\n\n\nAfter the pods are installed, copy the Pods.xcodeproj from \"unzipped_SDK/Example/Pods\" into your own project. Make sure you are copying the xcodeproj and \nnot\n the Pods folder; otherwise you may enter into duplicated definitions problems.\n\n\nAfter the Pods.xcodeproj is added to your project, manually add the following frameworks into your project's General section \"Embedded binaries\":\n\n\nAFNetworking.framework\n\nBerTlv.framework\n\nCocoaLumberjack.framework\n\nINTULocationManager.framework\n\nlibextobjc.framework\n\nLockbox.framework\n\nMantle.framework\n\nOvercoat.framework\n\nZipArchive.framework\n  \n\n\nOther Wirecard ePOS SDK frameworks need to be added manually. Add to your project the WDePos.framework \nand\n the WDePosResources.bundle files, and other hardware frameworks you plan on using, from \"unzipped_SDK/Pod/Classes\". Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners are:  \n\n\n\n\n\n\n\n\nDevice\n\n\nFramework\n\n\nAccessory protocol\n\n\n\n\n\n\n\n\n\n\n[SPm2, SPm20]\n\n\nSpire_SDK.framework\n\n\ncom.thyron\n\n\n\n\n\n\n[StarMicronics , mPOP]\n\n\nStario_SDK.framework\n\n\njp.star-m.starpro\n\n\n\n\n\n\n[uEMVSwiper]\n\n\nBBPOS_SDK.framework\n\n\ncom.bbpos.bt.wisepad\n\n\n\n\n\n\n[DPP-250]\n\n\nDatecs_SDK.framework\n\n\ncom.datecs.printer.escpos\n\n\n\n\n\n\n[M010]\n\n\nMiura_SDK.framework\n\n\ncom.miura.shuttle, com.miura.rpi\n\n\n\n\n\n\n[SocketScanner]\n\n\nSocket_SDK.framework\n\n\ncom.socketmobile.chs\n\n\n\n\n\n\nTogether with the step .5, your \"Embedded binaries\" section will look like:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou also need to add the WDePosResources.bundle file into your project's Build Phases \"Copy Bundle Resources\u201d section:\n  \n  \n\n\nNow add the following Apple frameworks in your project's General \"Linked Frameworks and Libraries\" section:\n\n\nExternalAccessory \n\nCoreFoundation\n\nCoreLocation\n\nCoreBluetooth\n\nUIKit\n\nCoreGraphics\n\nSecurity\n\nSystemConfiguration\n\nFoundation\n\nMobileCoreServices\n\nTogether with the steps above, it will look like:\n\n  \n\n\nMake sure your project Build Settings/Build Options has \u201cAlways Embed Swift Standard Libraries\u201d set to YES:\n\n  \n\n\nAnd the last step: edit your project's info.plist (the faster way is as a text file) and copy paste the lines below. That way your project will include all needed keys/values and protocols for enabling hardware communication, permissions, etc. Make sure you don't have the following keys already defined with different values, and that you are going to use the \nUISupportedExternalAccessoryProtocols\n into your app (do not include the ones for hardware you don't plan on supporting, see point .6).  \n        \nkey\nNSAppTransportSecurity\n/key\n\n         \ndict\n  \n                        \nkey\nNSAllowsArbitraryLoads\n/key\n  \n                        \ntrue/\n  \n        \n/dict\n  \n                        \nkey\nUIBackgroundModes\n/key\n  \n        \narray\n  \n                        \nstring\naudio\n/string\n  \n                        \nstring\nfetch\n/string\n  \n                        \nstring\nexternal-accessory\n/string\n  \n                        \nstring\nbluetooth-peripheral\n/string\n  \n                        \nstring\nbluetooth-central\n/string\n  \n        \n/array\n  \n        \nkey\nNSBluetoothPeripheralUsageDescription\n/key\n  \n        \nstring\nBlueTooth is required for Terminal and Printer communication\n/string\n  \n        \nkey\nNSCameraUsageDescription\n/key\n  \n        \nstring\nCamera will be used for barcode scanning and taking Photos for product catalogue\n/string\n  \n        \nkey\nNSLocationWhenInUseUsageDescription\n/key\n  \n        \nstring\nThe terminal location will be used for all payments\n/string\n  \n        \nkey\nNSMicrophoneUsageDescription\n/key\n\n        \nstring\nAudio jack is used for payment terminals such as BBPOS Chippers/Swippers\n/string\n  \n        \nkey\nNSPhotoLibraryUsageDescription\n/key\n  \n        \nstring\nMedia Library will be used for adding pictures to catalogue products of your own\n/string\n  \n                        \nkey\nUISupportedExternalAccessoryProtocols\n/key\n  \n        \narray\n  \n                        \nstring\ncom.socketmobile.chs\n/string\n  \n                        \nstring\ncom.thyron\n/string\n  \n                        \nstring\ncom.datecs.printer.escpos\n/string\n  \n                        \nstring\njp.star-m.starpro\n/string\n  \n        \n/array", 
            "title": "Set up using Carthage"
        }, 
        {
            "location": "/int-setup-ios-manual/#set-up-using-carthage", 
            "text": "The SDK supports installation using the  Carthage dependency manager .\nJust run the carthage update command in the SDK root directory and get the WDePOS and related frameworks from  Carthage/Build/ platform  directory  carthage update", 
            "title": "Set up using Carthage"
        }, 
        {
            "location": "/int-setup-ios-manual/#set-up-manually-not-recommended", 
            "text": "To manually install the SDK:    Make sure you have  cocoapods  installed.     Download the SDK from  Wirecard ePOS SDK for iOS repository on Github .   Unzip it and run 'pod install' within \"unzipped_SDK/Example\" folder.  After the pods are installed, copy the Pods.xcodeproj from \"unzipped_SDK/Example/Pods\" into your own project. Make sure you are copying the xcodeproj and  not  the Pods folder; otherwise you may enter into duplicated definitions problems.  After the Pods.xcodeproj is added to your project, manually add the following frameworks into your project's General section \"Embedded binaries\":  AFNetworking.framework \nBerTlv.framework \nCocoaLumberjack.framework \nINTULocationManager.framework \nlibextobjc.framework \nLockbox.framework \nMantle.framework \nOvercoat.framework \nZipArchive.framework     Other Wirecard ePOS SDK frameworks need to be added manually. Add to your project the WDePos.framework  and  the WDePosResources.bundle files, and other hardware frameworks you plan on using, from \"unzipped_SDK/Pod/Classes\". Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners are:       Device  Framework  Accessory protocol      [SPm2, SPm20]  Spire_SDK.framework  com.thyron    [StarMicronics , mPOP]  Stario_SDK.framework  jp.star-m.starpro    [uEMVSwiper]  BBPOS_SDK.framework  com.bbpos.bt.wisepad    [DPP-250]  Datecs_SDK.framework  com.datecs.printer.escpos    [M010]  Miura_SDK.framework  com.miura.shuttle, com.miura.rpi    [SocketScanner]  Socket_SDK.framework  com.socketmobile.chs    Together with the step .5, your \"Embedded binaries\" section will look like:              You also need to add the WDePosResources.bundle file into your project's Build Phases \"Copy Bundle Resources\u201d section:\n       Now add the following Apple frameworks in your project's General \"Linked Frameworks and Libraries\" section:  ExternalAccessory  \nCoreFoundation \nCoreLocation \nCoreBluetooth \nUIKit \nCoreGraphics \nSecurity \nSystemConfiguration \nFoundation \nMobileCoreServices \nTogether with the steps above, it will look like:     Make sure your project Build Settings/Build Options has \u201cAlways Embed Swift Standard Libraries\u201d set to YES:     And the last step: edit your project's info.plist (the faster way is as a text file) and copy paste the lines below. That way your project will include all needed keys/values and protocols for enabling hardware communication, permissions, etc. Make sure you don't have the following keys already defined with different values, and that you are going to use the  UISupportedExternalAccessoryProtocols  into your app (do not include the ones for hardware you don't plan on supporting, see point .6).            key NSAppTransportSecurity /key \n          dict   \n                         key NSAllowsArbitraryLoads /key   \n                         true/   \n         /dict   \n                         key UIBackgroundModes /key   \n         array   \n                         string audio /string   \n                         string fetch /string   \n                         string external-accessory /string   \n                         string bluetooth-peripheral /string   \n                         string bluetooth-central /string   \n         /array   \n         key NSBluetoothPeripheralUsageDescription /key   \n         string BlueTooth is required for Terminal and Printer communication /string   \n         key NSCameraUsageDescription /key   \n         string Camera will be used for barcode scanning and taking Photos for product catalogue /string   \n         key NSLocationWhenInUseUsageDescription /key   \n         string The terminal location will be used for all payments /string   \n         key NSMicrophoneUsageDescription /key \n         string Audio jack is used for payment terminals such as BBPOS Chippers/Swippers /string   \n         key NSPhotoLibraryUsageDescription /key   \n         string Media Library will be used for adding pictures to catalogue products of your own /string   \n                         key UISupportedExternalAccessoryProtocols /key   \n         array   \n                         string com.socketmobile.chs /string   \n                         string com.thyron /string   \n                         string com.datecs.printer.escpos /string   \n                         string jp.star-m.starpro /string   \n         /array", 
            "title": "Set up Manually (Not Recommended)"
        }, 
        {
            "location": "/int-terminal-avail/", 
            "text": "Check Available Updates\n\n\nYou can check for available updates before performing an \nUpdate Firmware\n. This sample code discovers connected devices and for the first one found, checks for any available updates.\n\n\nTypically, you should provide the user with an information notice and option to update if there is new firmware available.\n\n\nUpdate types\n\n\nWirecard ePOS SDK provides 3 types of terminal updates.\n\n\n\n\nfirmware\n\n\napplication\n\n\nconfiguration\n\n\n\n\nEvery terminal can handle different types of update. For example, Spire's SPm2 uses application and configuration updates. \n\n\n\n\nNote\n\n\nYou can specify which update type you can check, or you can leave parameter empty, and SDK will check all available update types for the selected terminal.\n\n\n\n\nThe Code\n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n            \n\n            \n\n            \nObjC\n\n            \n\n                \n\n            \n\n\n            \n\n            \n\n            \nSwift\n\n            \n\n                \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        \n\n    \n\n\n\n\n\n\n\n    \n\n        \n\n    \n\n    \n\n        Universal Windows Platform SDK coming soon", 
            "title": "Check Available Updates"
        }, 
        {
            "location": "/int-terminal-avail/#check-available-updates", 
            "text": "You can check for available updates before performing an  Update Firmware . This sample code discovers connected devices and for the first one found, checks for any available updates.  Typically, you should provide the user with an information notice and option to update if there is new firmware available.", 
            "title": "Check Available Updates"
        }, 
        {
            "location": "/int-terminal-avail/#update-types", 
            "text": "Wirecard ePOS SDK provides 3 types of terminal updates.   firmware  application  configuration   Every terminal can handle different types of update. For example, Spire's SPm2 uses application and configuration updates.    Note  You can specify which update type you can check, or you can leave parameter empty, and SDK will check all available update types for the selected terminal.", 
            "title": "Update types"
        }, 
        {
            "location": "/int-terminal-avail/#the-code", 
            "text": "", 
            "title": "The Code"
        }, 
        {
            "location": "/int-terminal-discovery/", 
            "text": "Terminal Discovery\n\n\nThe discoverDevices method of Terminal Manager handles discovery of all paired and connected Posmate terminals. Spire manufactures the following terminals:\n\n\n\n\nPosmate\n\n\nSPm2\n\n\nSpm20\n\n\n\n\nAll three of these terminals are served by the PosMateExtension.\n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \nOnce the terminal is selected from the list of available terminals it can be saved for later use as an instance variable or a user preference\n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Terminal Discovery"
        }, 
        {
            "location": "/int-terminal-discovery/#terminal-discovery", 
            "text": "The discoverDevices method of Terminal Manager handles discovery of all paired and connected Posmate terminals. Spire manufactures the following terminals:   Posmate  SPm2  Spm20   All three of these terminals are served by the PosMateExtension.", 
            "title": "Terminal Discovery"
        }, 
        {
            "location": "/int-terminal-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-terminal-discovery/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-terminal-overview/", 
            "text": "Terminal Manager Overview\n\n\nThis section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to:\n\n\n\n\ndiscover devices\n\n\nupdate firmware\n\n\ncheck for available devices", 
            "title": "Int terminal overview"
        }, 
        {
            "location": "/int-terminal-overview/#terminal-manager-overview", 
            "text": "This section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to:   discover devices  update firmware  check for available devices", 
            "title": "Terminal Manager Overview"
        }, 
        {
            "location": "/int-terminal-update/", 
            "text": "Update Firmware\n\n\nCard acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter.\n\n\n\n\nTip\n\n\nYou can check if any updates are available with the \nCheck Available Updates\n sample code. \n\n\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nIn the sample code, all terminals (Miura terminals are selected) are discovered and then the first one is updated. Both the firmware and payment application are updated. \n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n    \n\n        \n\n        \n\n        \nObjC\n\n        \n\n            \n\n        \n\n\n        \n\n        \n\n        \nSwift\n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n    Universal Windows Platform SDK coming soon", 
            "title": "Update Firmware"
        }, 
        {
            "location": "/int-terminal-update/#update-firmware", 
            "text": "Card acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter.   Tip  You can check if any updates are available with the  Check Available Updates  sample code.", 
            "title": "Update Firmware"
        }, 
        {
            "location": "/int-terminal-update/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-terminal-update/#the-sample-code", 
            "text": "In the sample code, all terminals (Miura terminals are selected) are discovered and then the first one is updated. Both the firmware and payment application are updated.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-tests-a/", 
            "text": "Android Integration Tests\n\n\nA variety of integration tests are provided in the \nexamples\n directory, as shown below:\n\n\n\n\nEach of these is described briefly below.\n\n\nAuthenticationTest.java\n\n\nProvides sample code with a variety of functionality from the User Manager component that you can use for testing, including:\n\n\n\n\nget the current user\n\n\nget active cashiers\n\n\nchange a password\n\n\nobtain the password policy\n\n\nPIN validation\n\n\n\n\nBaseDemoTest.java\n\n\nProvides a basic test of the demo application. \n\n\nCashTests.java\n\n\nProvides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes:\n\n\n\n\nrequest user and cash register information\n\n\nshift management including opening a new shift\n\n\nshift reporting for any closed shifts\n\n\npay in/out reporting for shifts\n\n\nexecution of a cash sale\n\n\n\n\nCatalogueTests.java\n\n\nDemonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including:\n\n\n\n\nobtaining catalogue data\n\n\nidentifying changes in the data\n\n\n\n\nThis includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app.\n\n\nInitializationTest.java\n\n\nDemonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the \nupdateUserCredentials\n method. \n\n\nOtherTests.java\n\n\nMiscellaneous tests including getting the server time and date.\n\n\nPrinterTest.java\n\n\nEnables you to test the Printer Manager component, including:\n\n\n\n\ndetecting available printers\n\n\nprinting a receipt\n\n\n\n\nSalesTest.java\n\n\nIllustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the \ngetSales()\n method. \n\n\nStatsTest.java\n\n\nDemonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including:\n\n\n\n\nmaximum sale\n\n\nminimum sale\n\n\nsales turnover\n\n\n\n\nTerminalTest.java\n\n\nHelps you test features of the Terminal Manager component, including:\n\n\n\n\ndiscovery of terminals\n\n\ncheck for updates for the terminals\n\n\ncarry out a card sale with a Spire terminal\n\n\n\n\nUserTest.java\n\n\nShows how to use the User Manager component to:\n\n\n\n\ntest credentials and get a user\n\n\nremind the user of their password\n\n\nhelp a user reset their password", 
            "title": "Android Integration Tests"
        }, 
        {
            "location": "/int-tests-a/#android-integration-tests", 
            "text": "A variety of integration tests are provided in the  examples  directory, as shown below:   Each of these is described briefly below.", 
            "title": "Android Integration Tests"
        }, 
        {
            "location": "/int-tests-a/#authenticationtestjava", 
            "text": "Provides sample code with a variety of functionality from the User Manager component that you can use for testing, including:   get the current user  get active cashiers  change a password  obtain the password policy  PIN validation", 
            "title": "AuthenticationTest.java"
        }, 
        {
            "location": "/int-tests-a/#basedemotestjava", 
            "text": "Provides a basic test of the demo application.", 
            "title": "BaseDemoTest.java"
        }, 
        {
            "location": "/int-tests-a/#cashtestsjava", 
            "text": "Provides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes:   request user and cash register information  shift management including opening a new shift  shift reporting for any closed shifts  pay in/out reporting for shifts  execution of a cash sale", 
            "title": "CashTests.java"
        }, 
        {
            "location": "/int-tests-a/#cataloguetestsjava", 
            "text": "Demonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including:   obtaining catalogue data  identifying changes in the data   This includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app.", 
            "title": "CatalogueTests.java"
        }, 
        {
            "location": "/int-tests-a/#initializationtestjava", 
            "text": "Demonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the  updateUserCredentials  method.", 
            "title": "InitializationTest.java"
        }, 
        {
            "location": "/int-tests-a/#othertestsjava", 
            "text": "Miscellaneous tests including getting the server time and date.", 
            "title": "OtherTests.java"
        }, 
        {
            "location": "/int-tests-a/#printertestjava", 
            "text": "Enables you to test the Printer Manager component, including:   detecting available printers  printing a receipt", 
            "title": "PrinterTest.java"
        }, 
        {
            "location": "/int-tests-a/#salestestjava", 
            "text": "Illustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the  getSales()  method.", 
            "title": "SalesTest.java"
        }, 
        {
            "location": "/int-tests-a/#statstestjava", 
            "text": "Demonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including:   maximum sale  minimum sale  sales turnover", 
            "title": "StatsTest.java"
        }, 
        {
            "location": "/int-tests-a/#terminaltestjava", 
            "text": "Helps you test features of the Terminal Manager component, including:   discovery of terminals  check for updates for the terminals  carry out a card sale with a Spire terminal", 
            "title": "TerminalTest.java"
        }, 
        {
            "location": "/int-tests-a/#usertestjava", 
            "text": "Shows how to use the User Manager component to:   test credentials and get a user  remind the user of their password  help a user reset their password", 
            "title": "UserTest.java"
        }, 
        {
            "location": "/int-tests-i/", 
            "text": "iOS Integration Tests\n\n\nA variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the \nExample\n folder below your project folder. \n\n\nThese tests are useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK. \n\n\nEach Test file has detailed comments that walk you through the code. Each Test is described briefly below. \n\n\nCashTests\n\n\nDemonstrates a complete usage of the Cash Management feature including how to:\n\n\n\n\nlogin and request user data\n\n\ncheck for available cash registers and get one\n\n\ndeal with various shift-related activities, such as open and close\n\n\npay in and pay out\n\n\n\n\nThe code also demonstrates how to process: \n\n\n\n\na complete cash sale with a basket full of items\n\n\na refund of a sale\n\n\n\n\nCatalogueTests\n\n\nIllustrates how to request:\n\n\n\n\nproduct catalogues\n\n\nproduct categories\n\n\nproducts\n\n\nproduct images\n\n\n\n\nThis data can then be used to display a product catalogue within your payment acceptance app, including images of each product.\n\n\nDatecsPrinterTest\n\n\nEnables you to test a Datecs printer, including:\n\n\n\n\nget a sale\n\n\ndetect a printer\n\n\nprint a receipt\n\n\n\n\nThe Datecs printer only works with the Receipt object. The StarIO printer works with:\n\n\n\n\nPDF\n\n\nUIImage\n\n\n\n\nERP Tests\n\n\nThis test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult \nUsing an ERP\n. \n\n\nBefore using this test, you must:\n\n\n\n\nhave ERP enabled in your back-end\n\n\nensure that you have actual data, such as product catalogue, members, products and so forth in your ERP\n\n\n\n\n\n\nNote\n\n\nMembers is another term for Customers in some ERP systems.\n\n\n\n\nThe code demonstrates how to:\n\n\n\n\nsearch for members\n\n\nrequest discount prices for specific members\n\n\nrequest stock levels for specific products\n\n\n\n\n\n\nNote\n\n\nStock level refers to the quantity of products in inventory. \n\n\n\n\nSee \nProduct Stocks (ERP)\n for more information about retrieving and using product stock levels from your ERP system. \n\n\nSalesTests\n\n\nProvides a basic test of a sale, including:\n\n\n\n\nlogin and request user data\n\n\nrequest a sale from the current user\n\n\nsave the sale response so it can be used by other tests, such as the Printer tests\n\n\nquery the sale\n\n\n\n\n\n\nTip\n\n\nIf you dive in and start reading the code, note that objects are named with a prefix of \nWD\n. \nWD\n is short for Wirecard. So to read the object name, ignore this prefix. For example, \nWDSalesQuery\n is the Sales Query object. \nWDMerchantUser\n is the Merchant User object. \n\n\n\n\nSocketScannerTests\n\n\nThe SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including:\n\n\n\n\ndiscover paired scanners\n\n\nlisten for activity on the paired scanner\n\n\nprocess a scanned barcode\n\n\nhandle battery level changes\n\n\n\n\nTo use this test, a \nbarcode-example.png\n image file is provided in the \nWDePOSDemo\n folder, as shown:\n\n\n\n\nScan this barcode when running this test to validate that your scanner is functioning properly.\n\n\nSpireTests\n\n\nThe SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly with the SDK. To use this test, you must: \n\n\n\n\nhave an actual iOS device because device simulators do not work for this test\n\n\nhave a Spire terminal paired to your iOS device through your iOS device settings\n\n\n\n\nOnce your hardware is ready, you can use the code to:\n\n\n\n\ndiscover paired iOS device\n\n\ncheck for updates for the device\n\n\nhandle firmware updates\n\n\nprocess a card sale\n\n\nrefund a sale\n\n\n\n\n\n\nTip\n\n\nThe refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card. \n\n\n\n\nThe code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end.\n\n\nStarIOTests\n\n\nThe SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code:\n\n\n\n\ndetects paired devices\n\n\nopens the cash drawer\n\n\nprints a receipt\n\n\nscans a barcode\n\n\n\n\n\n\nNote\n\n\nThe StarMicronics device does not have a barcode scanner. \n\n\n\n\nStatsTests\n\n\nA simple implementation lets you test the statistics retrieval features of the SDK, including querying for:\n\n\n\n\nminimum, maximum and average sale amounts\n\n\nturnover\n\n\ntransaction counts\n\n\n\n\nSee the \nSales Statistics\n chapter for complete information. \n\n\nUserTests\n\n\nProvides a variety of tests for user and credential management (i.e., username/password), including:\n\n\n\n\nget credentials for a user\n\n\nremind a user of their username\n\n\nhandle a request by a user to reset their password\n\n\nallow the user to change their password\n\n\n\n\nThis functionality is part of the User Manager component which is described in more detail in the \nUser Manager component chapter\n.", 
            "title": "iOS Integration Tests"
        }, 
        {
            "location": "/int-tests-i/#ios-integration-tests", 
            "text": "A variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the  Example  folder below your project folder.   These tests are useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK.   Each Test file has detailed comments that walk you through the code. Each Test is described briefly below.", 
            "title": "iOS Integration Tests"
        }, 
        {
            "location": "/int-tests-i/#cashtests", 
            "text": "Demonstrates a complete usage of the Cash Management feature including how to:   login and request user data  check for available cash registers and get one  deal with various shift-related activities, such as open and close  pay in and pay out   The code also demonstrates how to process:    a complete cash sale with a basket full of items  a refund of a sale", 
            "title": "CashTests"
        }, 
        {
            "location": "/int-tests-i/#cataloguetests", 
            "text": "Illustrates how to request:   product catalogues  product categories  products  product images   This data can then be used to display a product catalogue within your payment acceptance app, including images of each product.", 
            "title": "CatalogueTests"
        }, 
        {
            "location": "/int-tests-i/#datecsprintertest", 
            "text": "Enables you to test a Datecs printer, including:   get a sale  detect a printer  print a receipt   The Datecs printer only works with the Receipt object. The StarIO printer works with:   PDF  UIImage", 
            "title": "DatecsPrinterTest"
        }, 
        {
            "location": "/int-tests-i/#erp-tests", 
            "text": "This test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult  Using an ERP .   Before using this test, you must:   have ERP enabled in your back-end  ensure that you have actual data, such as product catalogue, members, products and so forth in your ERP    Note  Members is another term for Customers in some ERP systems.   The code demonstrates how to:   search for members  request discount prices for specific members  request stock levels for specific products    Note  Stock level refers to the quantity of products in inventory.    See  Product Stocks (ERP)  for more information about retrieving and using product stock levels from your ERP system.", 
            "title": "ERP Tests"
        }, 
        {
            "location": "/int-tests-i/#salestests", 
            "text": "Provides a basic test of a sale, including:   login and request user data  request a sale from the current user  save the sale response so it can be used by other tests, such as the Printer tests  query the sale    Tip  If you dive in and start reading the code, note that objects are named with a prefix of  WD .  WD  is short for Wirecard. So to read the object name, ignore this prefix. For example,  WDSalesQuery  is the Sales Query object.  WDMerchantUser  is the Merchant User object.", 
            "title": "SalesTests"
        }, 
        {
            "location": "/int-tests-i/#socketscannertests", 
            "text": "The SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including:   discover paired scanners  listen for activity on the paired scanner  process a scanned barcode  handle battery level changes   To use this test, a  barcode-example.png  image file is provided in the  WDePOSDemo  folder, as shown:   Scan this barcode when running this test to validate that your scanner is functioning properly.", 
            "title": "SocketScannerTests"
        }, 
        {
            "location": "/int-tests-i/#spiretests", 
            "text": "The SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly with the SDK. To use this test, you must:    have an actual iOS device because device simulators do not work for this test  have a Spire terminal paired to your iOS device through your iOS device settings   Once your hardware is ready, you can use the code to:   discover paired iOS device  check for updates for the device  handle firmware updates  process a card sale  refund a sale    Tip  The refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card.    The code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end.", 
            "title": "SpireTests"
        }, 
        {
            "location": "/int-tests-i/#stariotests", 
            "text": "The SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code:   detects paired devices  opens the cash drawer  prints a receipt  scans a barcode    Note  The StarMicronics device does not have a barcode scanner.", 
            "title": "StarIOTests"
        }, 
        {
            "location": "/int-tests-i/#statstests", 
            "text": "A simple implementation lets you test the statistics retrieval features of the SDK, including querying for:   minimum, maximum and average sale amounts  turnover  transaction counts   See the  Sales Statistics  chapter for complete information.", 
            "title": "StatsTests"
        }, 
        {
            "location": "/int-tests-i/#usertests", 
            "text": "Provides a variety of tests for user and credential management (i.e., username/password), including:   get credentials for a user  remind a user of their username  handle a request by a user to reset their password  allow the user to change their password   This functionality is part of the User Manager component which is described in more detail in the  User Manager component chapter .", 
            "title": "UserTests"
        }, 
        {
            "location": "/int-ui/", 
            "text": "Sale UI\n\n\nThe SDK comes with the standard UI covering the whole payment flow*:\n\n\n\n\nSale Amount entry\n\n\nCardholder Signature collection\n\n\nQR Payment scanner\n\n\nTerminal selection\n\n\nCash Register selection\n\n\nCash Shift management (Open/Close)\n\n\n\n\n*This feature is available for iOS only at the moment\n\n\nPlease see the example application using the Sale UI. The example application can be found in \nWirecard-ePOS-iOS/eClear\n directory.\n\n\nYou can download the \nWirecard-ePOS-iOS\n if you did not install it already through cocoapods.\n\n\nThe Sample Code\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Coming soon ...\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Sale UI"
        }, 
        {
            "location": "/int-ui/#sale-ui", 
            "text": "The SDK comes with the standard UI covering the whole payment flow*:   Sale Amount entry  Cardholder Signature collection  QR Payment scanner  Terminal selection  Cash Register selection  Cash Shift management (Open/Close)   *This feature is available for iOS only at the moment  Please see the example application using the Sale UI. The example application can be found in  Wirecard-ePOS-iOS/eClear  directory.  You can download the  Wirecard-ePOS-iOS  if you did not install it already through cocoapods.", 
            "title": "Sale UI"
        }, 
        {
            "location": "/int-ui/#the-sample-code", 
            "text": "", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-usb/", 
            "text": "Spire SPm2 terminal via USB\n\n\nTerminal SPm2 by default communicates via Bluetooth. But, it's also able to do it via USB. \n\n\n\n\nCaution\n\n\nBe sure, Android device you're using supports USB OTG. \n\n\n\n\nRequirements\n\n\nTo proper USB communication, several things are required: \n\n\n\n\ncontact Wirecard support team, to assign proper USB configuration to your terminal SN\n\n\nenable USB communication on terminal\n\n\nduring discover devices, choose USB one\n\n\n\n\nProper USB configurations\n\n\nContact Wirecard support team, to assign proper USB configuration to your terminal SN\n\n\nUSB Settings on terminal\n\n\nEnable USB communication directly on terminal:\n\n\n\n\nturn on terminal\n\n\npress yellow arrow\n\n\nselect \"data bearer\"\n\n\nselect \"USB\"\n\n\nconnect terminal via USB cable to your Android device\n\n\ncontinue with terminal discovery\n\n\n\n\nTerminal discovery\n\n\nTerminal discovery for USB terminals is no different from regular \nTerminal Discovery\n. Spire extension tries to find bluetooth and USB devices all together. If you have paired bluetooth terminal and also connected USB device, SDK will return all available terminals.\n\n\nJust select terminal, which has \nCommunicationType\n set to USB. \n\n\n\n\nNote\n\n\nEvery time, you attach terminal to Android device and select it in SDK, user \nhas to confirm\n communication with this specific device by tapping OK to shown dialog.\n\n\n\n\nEverything else should work the same.", 
            "title": "Spire SPm2 terminal via USB"
        }, 
        {
            "location": "/int-usb/#spire-spm2-terminal-via-usb", 
            "text": "Terminal SPm2 by default communicates via Bluetooth. But, it's also able to do it via USB.    Caution  Be sure, Android device you're using supports USB OTG.", 
            "title": "Spire SPm2 terminal via USB"
        }, 
        {
            "location": "/int-usb/#requirements", 
            "text": "To proper USB communication, several things are required:    contact Wirecard support team, to assign proper USB configuration to your terminal SN  enable USB communication on terminal  during discover devices, choose USB one", 
            "title": "Requirements"
        }, 
        {
            "location": "/int-usb/#proper-usb-configurations", 
            "text": "Contact Wirecard support team, to assign proper USB configuration to your terminal SN", 
            "title": "Proper USB configurations"
        }, 
        {
            "location": "/int-usb/#usb-settings-on-terminal", 
            "text": "Enable USB communication directly on terminal:   turn on terminal  press yellow arrow  select \"data bearer\"  select \"USB\"  connect terminal via USB cable to your Android device  continue with terminal discovery", 
            "title": "USB Settings on terminal"
        }, 
        {
            "location": "/int-usb/#terminal-discovery", 
            "text": "Terminal discovery for USB terminals is no different from regular  Terminal Discovery . Spire extension tries to find bluetooth and USB devices all together. If you have paired bluetooth terminal and also connected USB device, SDK will return all available terminals.  Just select terminal, which has  CommunicationType  set to USB.    Note  Every time, you attach terminal to Android device and select it in SDK, user  has to confirm  communication with this specific device by tapping OK to shown dialog.   Everything else should work the same.", 
            "title": "Terminal discovery"
        }, 
        {
            "location": "/int-usermanager/", 
            "text": "User Manager\n\n\nThe merchant's staff who use the payment acceptance app that you create are referred to as the \nusers\n. Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials:\n\n\n\n\npassword policy - lets you access the password rules\n\n\npassword reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available)\n\n\nremind username - sends the user name to a specified email address\n\n\nchange password - enables an authenticated user to change their password\n\n\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nIn the iOS code, there are three key methods that are used: \n\n\n\n\npasswordPolicy\n\n\nmanageCredentials\n\n\nchangePassword\n\n\n\n\nThe \nmanageCredentials\n method used is in three different ways, which correspond to three parameters you can pass it:\n\n\n\n\nremindUserName\n\n\nresetPassword\n\n\nchangePassword\n\n\n\n\n\n\nNote\n\n\n\n\nIn the sample code, the SDK is instantiated with a name of \nsdkNoUser\n, in contrast with the usual object name of \nsdk\n. This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the \nWirecard ePOS\n SDK object when you have an authenticated user.\n\n\n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n                \n\n                \n\n                \nObjC\n\n                \n\n                    \n\n                \n\n\n                \n\n                \n\n                \nSwift\n\n                \n\n                    \n\n                \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            \n\n        \n\n    \n\n    \n\n    \n\n        \n\n            \n\n        \n\n        \n\n            Universal Windows Platform SDK coming soon", 
            "title": "Int usermanager"
        }, 
        {
            "location": "/int-usermanager/#user-manager", 
            "text": "The merchant's staff who use the payment acceptance app that you create are referred to as the  users . Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials:   password policy - lets you access the password rules  password reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available)  remind username - sends the user name to a specified email address  change password - enables an authenticated user to change their password", 
            "title": "User Manager"
        }, 
        {
            "location": "/int-usermanager/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-usermanager/#the-sample-code", 
            "text": "In the iOS code, there are three key methods that are used:    passwordPolicy  manageCredentials  changePassword   The  manageCredentials  method used is in three different ways, which correspond to three parameters you can pass it:   remindUserName  resetPassword  changePassword    Note   In the sample code, the SDK is instantiated with a name of  sdkNoUser , in contrast with the usual object name of  sdk . This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the  Wirecard ePOS  SDK object when you have an authenticated user.", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/integrating/", 
            "text": "Guide to Integrating the SDK\n\n\nHeading Here\n\n\nAnother Heading\n\n\nSubheading\n\n\nSubheading", 
            "title": "Guide to Integrating the SDK"
        }, 
        {
            "location": "/integrating/#guide-to-integrating-the-sdk", 
            "text": "", 
            "title": "Guide to Integrating the SDK"
        }, 
        {
            "location": "/integrating/#heading-here", 
            "text": "", 
            "title": "Heading Here"
        }, 
        {
            "location": "/integrating/#another-heading", 
            "text": "", 
            "title": "Another Heading"
        }, 
        {
            "location": "/integrating/#subheading", 
            "text": "", 
            "title": "Subheading"
        }, 
        {
            "location": "/integrating/#subheading_1", 
            "text": "", 
            "title": "Subheading"
        }, 
        {
            "location": "/ios-reference/", 
            "text": "iOS SDK Reference\n\n\nClass Library", 
            "title": "iOS SDK Reference"
        }, 
        {
            "location": "/ios-reference/#ios-sdk-reference", 
            "text": "Class Library", 
            "title": "iOS SDK Reference"
        }, 
        {
            "location": "/mpos-architecture/", 
            "text": "The mPOS Architecture\n\n\nThis chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard.\n\n\nPartners, Merchants and Consumers\n\n\nAs illustrated below, the \nWirecard ePOS SDK\n enables our \npartners\n to create payment acceptance app functionality for \nmerchants\n.\n\n\n\n\nThe resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit.\n\n\nThe cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see \nSDK Architecture\n for overview information and \nCash Manager Overview\n for detailed information.\n\n\nExtensive Hardware Support\n\n\nIn addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running:\n\n\n\n\na printer for printing receipts\n\n\na pistol scanner for scanning QR codes and barcodes\n\n\na cash register or cash drawer to enable the handling of cash payments\n\n\n\n\nThe SDK has extensive support for all of these devices. See the \nGetting Started\n chapter for a list of currently supported hardware devices. The \nIntegrating the SDK\n section of this website has complete information.\n\n\n\n\nTip\n\n\nFour components of the SDK architecture handle the four different types of hardware, as described in the \nnext chapter\n.\n\n\n\n\n\n\nNote\n\n\nTo enable Cash Management, you require cash drawer hardware. See the \nCash Manager Overview\n chapter for more information about Cash Management.\n\n\n\n\nSwitch, Gateway and the Acquiring Platform\n\n\nThe payment acceptance app is a front-end application. The corresponding back-end is \nSwitch\n. Each merchant must first be set up on Switch before they can use Wirecard ePOS SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch.\n\n\nSwitch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the \nWirecard Gateway\n. The Gateway, in turn, does the initial processing and then routes transactions to the \nAcquiring Platform\n, as illustrated below:\n\n\n\n\n\n\nNote\n\n\nThe mPOS division at Wirecard is responsible for the Wirecard ePOS SDK and the Switch back-end. The Payment \n Risk division oversees the Wirecard Gateway and the Acquiring Platform.\n\n\n\n\nUsing an ERP\n\n\nA key implementation decision that each merchant must make before implementing mPOS is whether or not to use an \nERP\n tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system than to replace it with a new one.\n\n\nFor example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores.\n\n\n\n\nTip\n\n\nGetting \nProduct Stocks (ERP)\n information is covered later in this documentation, along with getting \nProduct Prices (ERP)\n. Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in \nCustomer Manager (ERP)\n.\n\n\n\n\nIf a merchant chooses to augment their back-end with an ERP, the architecture looks like this:\n\n\n\n\nCard Schemes and the Issuer\n\n\nThe \nAcquiring Platform\n handles the communication with the various \nCard Schemes\n. The Card Schemes process transactions through the Issuing Bank of the \nIssuer\n. Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer.\n\n\n\n\nMoreover, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.", 
            "title": "The mPOS Architecture"
        }, 
        {
            "location": "/mpos-architecture/#the-mpos-architecture", 
            "text": "This chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard.", 
            "title": "The mPOS Architecture"
        }, 
        {
            "location": "/mpos-architecture/#partners-merchants-and-consumers", 
            "text": "As illustrated below, the  Wirecard ePOS SDK  enables our  partners  to create payment acceptance app functionality for  merchants .   The resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit.  The cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see  SDK Architecture  for overview information and  Cash Manager Overview  for detailed information.", 
            "title": "Partners, Merchants and Consumers"
        }, 
        {
            "location": "/mpos-architecture/#extensive-hardware-support", 
            "text": "In addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running:   a printer for printing receipts  a pistol scanner for scanning QR codes and barcodes  a cash register or cash drawer to enable the handling of cash payments   The SDK has extensive support for all of these devices. See the  Getting Started  chapter for a list of currently supported hardware devices. The  Integrating the SDK  section of this website has complete information.   Tip  Four components of the SDK architecture handle the four different types of hardware, as described in the  next chapter .    Note  To enable Cash Management, you require cash drawer hardware. See the  Cash Manager Overview  chapter for more information about Cash Management.", 
            "title": "Extensive Hardware Support"
        }, 
        {
            "location": "/mpos-architecture/#switch-gateway-and-the-acquiring-platform", 
            "text": "The payment acceptance app is a front-end application. The corresponding back-end is  Switch . Each merchant must first be set up on Switch before they can use Wirecard ePOS SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch.  Switch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the  Wirecard Gateway . The Gateway, in turn, does the initial processing and then routes transactions to the  Acquiring Platform , as illustrated below:    Note  The mPOS division at Wirecard is responsible for the Wirecard ePOS SDK and the Switch back-end. The Payment   Risk division oversees the Wirecard Gateway and the Acquiring Platform.", 
            "title": "Switch, Gateway and the Acquiring Platform"
        }, 
        {
            "location": "/mpos-architecture/#using-an-erp", 
            "text": "A key implementation decision that each merchant must make before implementing mPOS is whether or not to use an  ERP  tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system than to replace it with a new one.  For example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores.   Tip  Getting  Product Stocks (ERP)  information is covered later in this documentation, along with getting  Product Prices (ERP) . Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in  Customer Manager (ERP) .   If a merchant chooses to augment their back-end with an ERP, the architecture looks like this:", 
            "title": "Using an ERP"
        }, 
        {
            "location": "/mpos-architecture/#card-schemes-and-the-issuer", 
            "text": "The  Acquiring Platform  handles the communication with the various  Card Schemes . The Card Schemes process transactions through the Issuing Bank of the  Issuer . Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer.   Moreover, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.", 
            "title": "Card Schemes and the Issuer"
        }, 
        {
            "location": "/sdk-architecture/", 
            "text": "The SDK Architecture\n\n\nThe Wirecard ePOS SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below:\n\n\n\n\n\n\nNote\n\n\nWhile the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as \nsalesManager\n in the Objective-C code and \nsales()\n in the Java code.\n\n\n\n\nEach component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail.\n\n\n\n\nNote\n\n\nAll nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information.\n\n\n\n\nSales Manager\n\n\nSales are the lifeblood of any merchant so the \nSales Manager\n component is the centerpiece of the SDK.\n\n\n\n\nA sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not.\n\n\n\n\nCaution\n\n\nA sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash.\n\n\n\n\nInventory Manager\n\n\nInventory Manager\n enables you to:\n\n\n\n\nmaintain product catalogues\n\n\nmaintain product categories\n\n\nmaintain products\n\n\nmaintain product images\n\n\n\n\nIn addition, if the merchant uses an ERP system, it also enables:\n\n\n\n\nuse of product stock information stored in the ERP\n\n\nuse of product price information stored in the ERP\n\n\n\n\nThe Inventory Manager component is highlighted below:\n\n\n\n\nCash Management Components\n\n\nThe Wirecard ePOS SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components:\n\n\n\n\nThe \nCash Manager\n component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth.\n\n\nThe \nCash Drawer Manager\n component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired.\n\n\n\n\nThese two components are highlighted below:\n\n\n\n\nHardware Components\n\n\nFour of the nine components in the SDK architecture enable the management of hardware. They are highlighted below:\n\n\n\n\nTerminal Manager\n\n\nThe \nTerminal Manager\n component enables the discovery and usage of paired terminal devices, as well as the updating of firmware.\n\n\nCash Drawer Manager\n\n\nAs described earlier, the \nCash Drawer Manager\n component enables the discovery and usage of paired cash drawers and cash registers.\n\n\nPrinter Manager\n\n\nThe \nPrinter Manager\n component enables the discovery and usage of paired printer devices, primarily for the printing of receipts.\n\n\nScanner Manager\n\n\nThis \nScanner Manager\n component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes.\n\n\nCustomer and User Management\n\n\nTwo supplementary components assist with handling customers and users.\n\n\n\n\nCustomer Manager (ERP)\n\n\nERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The \nCustomer Manager\n component enables the use of this information.\n\n\nUser Manager\n\n\nApps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the \nUser Manager\n component has a variety of useful functionality, including:\n\n\n\n\nPassword Policy checks\n\n\nPassword Resets\n\n\nReminder User of Password\n\n\nChange Password\n\n\n\n\nError management\n\n\nAlmost all Wirecard ePOS SDK calls can have two results. First is positive, when everything is happy and second, something less-happy is the error result. See in categories below, which errors could appear.\n\n\niOS Errors\n\n\nWDErrorBackendReturnedJSONDoesNotMatchMappedClass\nWDErrorUnauthorizedUser\nWDErrorUserPasswordExpired\nWDErrorUserPasswordChangeRequired\nWDErrorUserAccessForbidden\nWDErrorResourceNotFound\nWDErrorSessionExpired\nWDErrorRequestTimeOut\nWDErrorRequestNoProperResponse\nWDErrorRequestParameterRequired\nWDErrorRequestedResourceNotFound\nWDErrorRequestFailedValidation\nWDErrorPlugInTimeout\nWDErrorSignatureTimeout\nWDErrorInitialization\nWDErrorLowBatteryLevel\nWDErrorSwipeTimeout\nWDErrorBadSwipe\nWDErrorNotSupportedCardType\nWDErrorDataProcessing\nWDErrorOnlineProcessing\nWDErrorTransactionNotApproved\nWDErrorHardwareAccessPermission\nWDErrorTokenExpired\nWDErrorConnection\nWDErrorSignatureRequired\nWDErrorCantLoadTerminalConfiguration\nWDErrorTerminalDamaged\nWDErrorNoDUKPT\nWDErrorFailedToStartEMV\nWDErrorFailedToSendOfflineEMV\nWDErrorFailedToSendOnlineEMV\nWDErrorTerminalNotSetInMerchant\nWDErrorResponseLost\nWDErrorTransactionTerminated\nWDErrorTransactionDeclined\nWDErrorTransactionFailure\nWDErrorBlockedCardType\nWDErrorFailedBluetoothConnection\nWDErrorFailedPrinterBluetoothConnection\nWDErrorFailedTerminalBluetoothConnection\nWDErrorFailedDrawerBluetoothConnection\nWDErrorFailedPistolBluetoothConnection\n\nWDErrorTerminalNotReady\nWDErrorTerminalCommunication\nWDErrorTerminalTimeoutApplicationSelection\nWDErrorTerminalFailedToGetICCApplicationsList\nWDErrorTerminalFailedToTerminateCurrentTerminalPaymentFlow\nWDErrorLowPowerInAudioJack\nWDErrorMonoAudioEnabled\nWDErrorTerminalCommandTimeOut\nWDErrorTerminalTimeOut\nWDErrorTerminalWaitingUserTimeOut\nWDErrorTerminalCancelledFileUpload\n\nWDErrorWrongUserNameOrPassword\nWDErrorVendorNotFound\nWDErrorExternalAccessoriesProtocolInvalid application .plist file.\nWDErrorExternalIdNotFound\nWDErrorChangePasswordCriteriaNotMet\nWDErrorQueryStatsTokenExpired\nWDErrorForgotExternalIdNotFound\n\nWDErrorConfigFilesInfoTimeout\nWDErrorConfigFilesZipDownload\nWDErrorTerminalDisconnected\nWDErrorConfigFilesTerminalMayNotBeSet\nWDErrorConfigFilesTerminalCancelledFileDownload\nWDErrorConfigFilesProductionFirmwareOnDevelopmentTerminal\nWDErrorConfigFilesDevelopmentFirmwareOnProductionTerminal\nWDErrorConfigFilesTerminalUnsupported\nWDErrorConfigFilesTokenExpired\nWDErrorInventoryNoData\nWDErrorTerminalFirmwareDoesNotExist\nWDErrorTerminalConfigDoesNotExist\n\nWDErrorConfigFilesReading\n\nWDErrorPrinterTimeout\nWDErrorPrinterInitialization\nWDErrorPrinterLowBatteryLevel\nWDErrorPrinterNotConnected\nWDErrorPrinterOperation\nWDErrorPrinterUnsupportedDevice\nWDErrorDeviceDoesNotSupportPrinting\nWDErrorPrinterPaperLow\n\nWDErrorSignatureRejectedFromTerminal\nWDErrorInvalidPaymentConfiguration\nWDErrorInvalidAIDConfiguration\n\nWDErrorTransactionReversalRequired\nWDErrorTransactionReversedByTerminal\nWDErrorTransactionReversalFailed\nWDErrorTransactionUpdateFailed\n\nWDErrorExtensionClassDoesNotExist\nWDErrorExtensionDoesNotSupportMethod\nWDErrorInvalidParameter\nWDErrorDeviceRooted\n\nWDErrorActiveTerminalNotSet\nWDErrorActiveScanPistolNotSet\nWDErrorActivePrinterNotSet\nWDErrorPinLocked\nWDErrorPinInvalid\nWDErrorGeneral\nWDErrorServerSSLCertificateExpired\nWDErrorFailedTerminalBluetoothConnectionNotInPayment\n\nWDErrorMissingMerchant\nWDErrorAnotherTransactionIsInProgress\n\n\n\n\nAndroid Exceptions\n\n\nSDK will usually returns exception, which extends from \nEposException\n and can also contain another exception in cause.\n\n\nHierarchy of exceptions: \n\n\nEposException (de.wirecard.epos.exceptions)\n    NoInternetException (de.wirecard.epos.exceptions)\n    DeviceSelectingCanceled (de.wirecard.epos.exceptions.initialization)\n    EposBackendException (de.wirecard.epos.exceptions)\n    UnknownException (de.wirecard.epos.exceptions)\n    ValidationException (de.wirecard.epos.exceptions)\n        AmountTooLowException (de.wirecard.epos.exceptions.validation)\n        MissingParamException (de.wirecard.epos.exceptions.validation)\n        NoDeviceTypeException (de.wirecard.epos.exceptions.validation)\n        TerminalAidConfigurationException (de.wirecard.epos.exceptions.validation)\n        TipQuantityException (de.wirecard.epos.exceptions.validation)\n        TerminalProfileException (de.wirecard.epos.exceptions.validation)\n        MandatoryParametersException (de.wirecard.epos.exceptions.validation)\n        TerminalProfileForNetworkException (de.wirecard.epos.exceptions.validation)\n        ServiceChargeQuantityException (de.wirecard.epos.exceptions.validation)\n        SaleValidationException (de.wirecard.epos.exceptions.validation)\n        TerminalApplicationFileException (de.wirecard.epos.exceptions.validation)\n        InvalidTerminalUpdateException (de.wirecard.epos.exceptions.validation)\n        ThereIsNoAvailableDevice (de.wirecard.epos.exceptions.initialization)\n        NoNewTerminalUpdateException (de.wirecard.epos.exceptions.validation)\n        MissingCurrencyException (de.wirecard.epos.exceptions.validation)\n        ParallelSalesException (de.wirecard.epos.exceptions.validation)\n        MissingConfigurationException (de.wirecard.epos.exceptions.validation)\n        MissingCallbackException (de.wirecard.epos.exceptions.validation)\n        MissingDeviceIdException (de.wirecard.epos.exceptions.validation)\n        AmountTooHighException (de.wirecard.epos.exceptions.validation)\n        MissingTerminalConfigurationException (de.wirecard.epos.exceptions.validation)\n        NoPaymentMethodException (de.wirecard.epos.exceptions.validation)\n        TerminalCapabilityException (de.wirecard.epos.exceptions.validation)\n        NoSelectedDeviceException (de.wirecard.epos.exceptions.validation)\n        MissingSaleException (de.wirecard.epos.exceptions.validation)\n        NoPaymentConfigurationException (de.wirecard.epos.exceptions.validation)\n        DeviceTypeMismatchException (de.wirecard.epos.exceptions.validation)\n        MissingBackendException (de.wirecard.epos.exceptions.validation)\n        ThereIsNoAvailableDeviceType (de.wirecard.epos.exceptions.initialization)\n        TerminalConfigurationException (de.wirecard.epos.exceptions.validation)\n        MissingContextException (de.wirecard.epos.exceptions.validation)\n        TerminalConfigUpdateException (de.wirecard.epos.exceptions.validation)\n            IncorrectUpdateFilesException (de.wirecard.epos.exceptions.extension.general)\n    SaleFailedException (de.wirecard.epos.exceptions)\n        UnknownSaleFailException (de.wirecard.epos.exceptions.sale)\n        SignatureRequestCanceledException (de.wirecard.epos.exceptions.sale)\n        SaleNotApprovedException (de.wirecard.epos.exceptions.sale)\n        SignatureConfirmationCanceledException (de.wirecard.epos.exceptions.sale)\n        PasswordConfirmationRequestCanceledException (de.wirecard.epos.exceptions.sale)\n    DeviceTypesSelectingCanceled (de.wirecard.epos.exceptions.initialization)\n    ExtensionException (de.wirecard.epos.exceptions.extension)\n        TerminalApplicationMismatchException (de.wirecard.epos.exceptions.validation)\n        InvalidFirmwareVersionException (de.wirecard.epos.exceptions.extension.general)\n        UnknownExtensionException (de.wirecard.epos.exceptions.extension.general)\n        TerminatePaymentException (de.wirecard.epos.extension.terminal.exception)\n        CardEntryAbortException (de.wirecard.epos.exceptions.extension.general)\n        InvalidTerminalAppVersionException (de.wirecard.epos.exceptions.extension.general)\n        LoadTerminalUpdateException (de.wirecard.epos.exceptions.extension.general)\n        PinEntryAbortedByUserException (de.wirecard.epos.extension.bbpos.exceptions)\n        CommunicationException (de.wirecard.epos.exceptions.extension)\n            NoBluetoothPermissionException (de.wirecard.epos.exceptions.extension.communication)\n            ConnectionAfterRestartDeviceException (de.wirecard.epos.exceptions.extension.communication)\n            NoBluetoothException (de.wirecard.epos.exceptions.extension.communication)\n            BluetoothConnectionException (de.wirecard.epos.exceptions.extension.communication)\n            UsbConnectionException (de.wirecard.epos.exceptions.extension.communication)\n            CommunicationTimeoutException (de.wirecard.epos.exceptions.extension.communication)\n                AmountConfirmationTimedOutException (de.wirecard.epos.exceptions.extension.communication)\n            NoUsbException (de.wirecard.epos.exceptions.extension.communication)\n            TerminateAfterConfirmException (de.wirecard.epos.exceptions.extension.communication)\n            NoBluetoothAdminPermissionException (de.wirecard.epos.exceptions.extension.communication)\n            UnknownCommunicationException (de.wirecard.epos.exceptions.extension.communication)\n            WrongBluetoothDeviceAddressException (de.wirecard.epos.exceptions.extension.communication)\n            ConnectionFailedException (de.wirecard.epos.exceptions.extension.communication)\n            DeviceDisconnectedException (de.wirecard.epos.exceptions.extension.communication)\n            PairingToTerminalException (de.wirecard.epos.exceptions.extension.communication)\n            UsbPermissionDeniedException (de.wirecard.epos.exceptions.extension.communication)\n        TerminalUpdateFileException (de.wirecard.epos.exceptions.extension.general)\n        CardEntryAbortedByUserException (de.wirecard.epos.extension.bbpos.exceptions)\n    UnauthorizedException (de.wirecard.epos.exceptions)", 
            "title": "The SDK Architecture"
        }, 
        {
            "location": "/sdk-architecture/#the-sdk-architecture", 
            "text": "The Wirecard ePOS SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below:    Note  While the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as  salesManager  in the Objective-C code and  sales()  in the Java code.   Each component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail.   Note  All nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information.", 
            "title": "The SDK Architecture"
        }, 
        {
            "location": "/sdk-architecture/#sales-manager", 
            "text": "Sales are the lifeblood of any merchant so the  Sales Manager  component is the centerpiece of the SDK.   A sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not.   Caution  A sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash.", 
            "title": "Sales Manager"
        }, 
        {
            "location": "/sdk-architecture/#inventory-manager", 
            "text": "Inventory Manager  enables you to:   maintain product catalogues  maintain product categories  maintain products  maintain product images   In addition, if the merchant uses an ERP system, it also enables:   use of product stock information stored in the ERP  use of product price information stored in the ERP   The Inventory Manager component is highlighted below:", 
            "title": "Inventory Manager"
        }, 
        {
            "location": "/sdk-architecture/#cash-management-components", 
            "text": "The Wirecard ePOS SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components:   The  Cash Manager  component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth.  The  Cash Drawer Manager  component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired.   These two components are highlighted below:", 
            "title": "Cash Management Components"
        }, 
        {
            "location": "/sdk-architecture/#hardware-components", 
            "text": "Four of the nine components in the SDK architecture enable the management of hardware. They are highlighted below:", 
            "title": "Hardware Components"
        }, 
        {
            "location": "/sdk-architecture/#terminal-manager", 
            "text": "The  Terminal Manager  component enables the discovery and usage of paired terminal devices, as well as the updating of firmware.", 
            "title": "Terminal Manager"
        }, 
        {
            "location": "/sdk-architecture/#cash-drawer-manager", 
            "text": "As described earlier, the  Cash Drawer Manager  component enables the discovery and usage of paired cash drawers and cash registers.", 
            "title": "Cash Drawer Manager"
        }, 
        {
            "location": "/sdk-architecture/#printer-manager", 
            "text": "The  Printer Manager  component enables the discovery and usage of paired printer devices, primarily for the printing of receipts.", 
            "title": "Printer Manager"
        }, 
        {
            "location": "/sdk-architecture/#scanner-manager", 
            "text": "This  Scanner Manager  component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes.", 
            "title": "Scanner Manager"
        }, 
        {
            "location": "/sdk-architecture/#customer-and-user-management", 
            "text": "Two supplementary components assist with handling customers and users.", 
            "title": "Customer and User Management"
        }, 
        {
            "location": "/sdk-architecture/#customer-manager-erp", 
            "text": "ERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The  Customer Manager  component enables the use of this information.", 
            "title": "Customer Manager (ERP)"
        }, 
        {
            "location": "/sdk-architecture/#user-manager", 
            "text": "Apps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the  User Manager  component has a variety of useful functionality, including:   Password Policy checks  Password Resets  Reminder User of Password  Change Password", 
            "title": "User Manager"
        }, 
        {
            "location": "/sdk-architecture/#error-management", 
            "text": "Almost all Wirecard ePOS SDK calls can have two results. First is positive, when everything is happy and second, something less-happy is the error result. See in categories below, which errors could appear.", 
            "title": "Error management"
        }, 
        {
            "location": "/sdk-architecture/#ios-errors", 
            "text": "WDErrorBackendReturnedJSONDoesNotMatchMappedClass\nWDErrorUnauthorizedUser\nWDErrorUserPasswordExpired\nWDErrorUserPasswordChangeRequired\nWDErrorUserAccessForbidden\nWDErrorResourceNotFound\nWDErrorSessionExpired\nWDErrorRequestTimeOut\nWDErrorRequestNoProperResponse\nWDErrorRequestParameterRequired\nWDErrorRequestedResourceNotFound\nWDErrorRequestFailedValidation\nWDErrorPlugInTimeout\nWDErrorSignatureTimeout\nWDErrorInitialization\nWDErrorLowBatteryLevel\nWDErrorSwipeTimeout\nWDErrorBadSwipe\nWDErrorNotSupportedCardType\nWDErrorDataProcessing\nWDErrorOnlineProcessing\nWDErrorTransactionNotApproved\nWDErrorHardwareAccessPermission\nWDErrorTokenExpired\nWDErrorConnection\nWDErrorSignatureRequired\nWDErrorCantLoadTerminalConfiguration\nWDErrorTerminalDamaged\nWDErrorNoDUKPT\nWDErrorFailedToStartEMV\nWDErrorFailedToSendOfflineEMV\nWDErrorFailedToSendOnlineEMV\nWDErrorTerminalNotSetInMerchant\nWDErrorResponseLost\nWDErrorTransactionTerminated\nWDErrorTransactionDeclined\nWDErrorTransactionFailure\nWDErrorBlockedCardType\nWDErrorFailedBluetoothConnection\nWDErrorFailedPrinterBluetoothConnection\nWDErrorFailedTerminalBluetoothConnection\nWDErrorFailedDrawerBluetoothConnection\nWDErrorFailedPistolBluetoothConnection\n\nWDErrorTerminalNotReady\nWDErrorTerminalCommunication\nWDErrorTerminalTimeoutApplicationSelection\nWDErrorTerminalFailedToGetICCApplicationsList\nWDErrorTerminalFailedToTerminateCurrentTerminalPaymentFlow\nWDErrorLowPowerInAudioJack\nWDErrorMonoAudioEnabled\nWDErrorTerminalCommandTimeOut\nWDErrorTerminalTimeOut\nWDErrorTerminalWaitingUserTimeOut\nWDErrorTerminalCancelledFileUpload\n\nWDErrorWrongUserNameOrPassword\nWDErrorVendorNotFound\nWDErrorExternalAccessoriesProtocolInvalid application .plist file.\nWDErrorExternalIdNotFound\nWDErrorChangePasswordCriteriaNotMet\nWDErrorQueryStatsTokenExpired\nWDErrorForgotExternalIdNotFound\n\nWDErrorConfigFilesInfoTimeout\nWDErrorConfigFilesZipDownload\nWDErrorTerminalDisconnected\nWDErrorConfigFilesTerminalMayNotBeSet\nWDErrorConfigFilesTerminalCancelledFileDownload\nWDErrorConfigFilesProductionFirmwareOnDevelopmentTerminal\nWDErrorConfigFilesDevelopmentFirmwareOnProductionTerminal\nWDErrorConfigFilesTerminalUnsupported\nWDErrorConfigFilesTokenExpired\nWDErrorInventoryNoData\nWDErrorTerminalFirmwareDoesNotExist\nWDErrorTerminalConfigDoesNotExist\n\nWDErrorConfigFilesReading\n\nWDErrorPrinterTimeout\nWDErrorPrinterInitialization\nWDErrorPrinterLowBatteryLevel\nWDErrorPrinterNotConnected\nWDErrorPrinterOperation\nWDErrorPrinterUnsupportedDevice\nWDErrorDeviceDoesNotSupportPrinting\nWDErrorPrinterPaperLow\n\nWDErrorSignatureRejectedFromTerminal\nWDErrorInvalidPaymentConfiguration\nWDErrorInvalidAIDConfiguration\n\nWDErrorTransactionReversalRequired\nWDErrorTransactionReversedByTerminal\nWDErrorTransactionReversalFailed\nWDErrorTransactionUpdateFailed\n\nWDErrorExtensionClassDoesNotExist\nWDErrorExtensionDoesNotSupportMethod\nWDErrorInvalidParameter\nWDErrorDeviceRooted\n\nWDErrorActiveTerminalNotSet\nWDErrorActiveScanPistolNotSet\nWDErrorActivePrinterNotSet\nWDErrorPinLocked\nWDErrorPinInvalid\nWDErrorGeneral\nWDErrorServerSSLCertificateExpired\nWDErrorFailedTerminalBluetoothConnectionNotInPayment\n\nWDErrorMissingMerchant\nWDErrorAnotherTransactionIsInProgress", 
            "title": "iOS Errors"
        }, 
        {
            "location": "/sdk-architecture/#android-exceptions", 
            "text": "SDK will usually returns exception, which extends from  EposException  and can also contain another exception in cause.  Hierarchy of exceptions:   EposException (de.wirecard.epos.exceptions)\n    NoInternetException (de.wirecard.epos.exceptions)\n    DeviceSelectingCanceled (de.wirecard.epos.exceptions.initialization)\n    EposBackendException (de.wirecard.epos.exceptions)\n    UnknownException (de.wirecard.epos.exceptions)\n    ValidationException (de.wirecard.epos.exceptions)\n        AmountTooLowException (de.wirecard.epos.exceptions.validation)\n        MissingParamException (de.wirecard.epos.exceptions.validation)\n        NoDeviceTypeException (de.wirecard.epos.exceptions.validation)\n        TerminalAidConfigurationException (de.wirecard.epos.exceptions.validation)\n        TipQuantityException (de.wirecard.epos.exceptions.validation)\n        TerminalProfileException (de.wirecard.epos.exceptions.validation)\n        MandatoryParametersException (de.wirecard.epos.exceptions.validation)\n        TerminalProfileForNetworkException (de.wirecard.epos.exceptions.validation)\n        ServiceChargeQuantityException (de.wirecard.epos.exceptions.validation)\n        SaleValidationException (de.wirecard.epos.exceptions.validation)\n        TerminalApplicationFileException (de.wirecard.epos.exceptions.validation)\n        InvalidTerminalUpdateException (de.wirecard.epos.exceptions.validation)\n        ThereIsNoAvailableDevice (de.wirecard.epos.exceptions.initialization)\n        NoNewTerminalUpdateException (de.wirecard.epos.exceptions.validation)\n        MissingCurrencyException (de.wirecard.epos.exceptions.validation)\n        ParallelSalesException (de.wirecard.epos.exceptions.validation)\n        MissingConfigurationException (de.wirecard.epos.exceptions.validation)\n        MissingCallbackException (de.wirecard.epos.exceptions.validation)\n        MissingDeviceIdException (de.wirecard.epos.exceptions.validation)\n        AmountTooHighException (de.wirecard.epos.exceptions.validation)\n        MissingTerminalConfigurationException (de.wirecard.epos.exceptions.validation)\n        NoPaymentMethodException (de.wirecard.epos.exceptions.validation)\n        TerminalCapabilityException (de.wirecard.epos.exceptions.validation)\n        NoSelectedDeviceException (de.wirecard.epos.exceptions.validation)\n        MissingSaleException (de.wirecard.epos.exceptions.validation)\n        NoPaymentConfigurationException (de.wirecard.epos.exceptions.validation)\n        DeviceTypeMismatchException (de.wirecard.epos.exceptions.validation)\n        MissingBackendException (de.wirecard.epos.exceptions.validation)\n        ThereIsNoAvailableDeviceType (de.wirecard.epos.exceptions.initialization)\n        TerminalConfigurationException (de.wirecard.epos.exceptions.validation)\n        MissingContextException (de.wirecard.epos.exceptions.validation)\n        TerminalConfigUpdateException (de.wirecard.epos.exceptions.validation)\n            IncorrectUpdateFilesException (de.wirecard.epos.exceptions.extension.general)\n    SaleFailedException (de.wirecard.epos.exceptions)\n        UnknownSaleFailException (de.wirecard.epos.exceptions.sale)\n        SignatureRequestCanceledException (de.wirecard.epos.exceptions.sale)\n        SaleNotApprovedException (de.wirecard.epos.exceptions.sale)\n        SignatureConfirmationCanceledException (de.wirecard.epos.exceptions.sale)\n        PasswordConfirmationRequestCanceledException (de.wirecard.epos.exceptions.sale)\n    DeviceTypesSelectingCanceled (de.wirecard.epos.exceptions.initialization)\n    ExtensionException (de.wirecard.epos.exceptions.extension)\n        TerminalApplicationMismatchException (de.wirecard.epos.exceptions.validation)\n        InvalidFirmwareVersionException (de.wirecard.epos.exceptions.extension.general)\n        UnknownExtensionException (de.wirecard.epos.exceptions.extension.general)\n        TerminatePaymentException (de.wirecard.epos.extension.terminal.exception)\n        CardEntryAbortException (de.wirecard.epos.exceptions.extension.general)\n        InvalidTerminalAppVersionException (de.wirecard.epos.exceptions.extension.general)\n        LoadTerminalUpdateException (de.wirecard.epos.exceptions.extension.general)\n        PinEntryAbortedByUserException (de.wirecard.epos.extension.bbpos.exceptions)\n        CommunicationException (de.wirecard.epos.exceptions.extension)\n            NoBluetoothPermissionException (de.wirecard.epos.exceptions.extension.communication)\n            ConnectionAfterRestartDeviceException (de.wirecard.epos.exceptions.extension.communication)\n            NoBluetoothException (de.wirecard.epos.exceptions.extension.communication)\n            BluetoothConnectionException (de.wirecard.epos.exceptions.extension.communication)\n            UsbConnectionException (de.wirecard.epos.exceptions.extension.communication)\n            CommunicationTimeoutException (de.wirecard.epos.exceptions.extension.communication)\n                AmountConfirmationTimedOutException (de.wirecard.epos.exceptions.extension.communication)\n            NoUsbException (de.wirecard.epos.exceptions.extension.communication)\n            TerminateAfterConfirmException (de.wirecard.epos.exceptions.extension.communication)\n            NoBluetoothAdminPermissionException (de.wirecard.epos.exceptions.extension.communication)\n            UnknownCommunicationException (de.wirecard.epos.exceptions.extension.communication)\n            WrongBluetoothDeviceAddressException (de.wirecard.epos.exceptions.extension.communication)\n            ConnectionFailedException (de.wirecard.epos.exceptions.extension.communication)\n            DeviceDisconnectedException (de.wirecard.epos.exceptions.extension.communication)\n            PairingToTerminalException (de.wirecard.epos.exceptions.extension.communication)\n            UsbPermissionDeniedException (de.wirecard.epos.exceptions.extension.communication)\n        TerminalUpdateFileException (de.wirecard.epos.exceptions.extension.general)\n        CardEntryAbortedByUserException (de.wirecard.epos.extension.bbpos.exceptions)\n    UnauthorizedException (de.wirecard.epos.exceptions)", 
            "title": "Android Exceptions"
        }, 
        {
            "location": "/setup-publictest/", 
            "text": "Set up Public Test", 
            "title": "Set up Public Test"
        }, 
        {
            "location": "/setup-publictest/#set-up-public-test", 
            "text": "", 
            "title": "Set up Public Test"
        }, 
        {
            "location": "/setup-terminals/", 
            "text": "Guide to Setting up Terminals", 
            "title": "Guide to Setting up Terminals"
        }, 
        {
            "location": "/setup-terminals/#guide-to-setting-up-terminals", 
            "text": "", 
            "title": "Guide to Setting up Terminals"
        }, 
        {
            "location": "/start/", 
            "text": "Welcome to the Wirecard ePOS SDK Partner Documentation\n\n\nThe \nWirecard ePOS SDK\n is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see \nWirecard mPOS SDK Integration\n.\n\n\nThe Wirecard ePOS SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay and WeChatPay. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the Wirecard ePOS SDK.\n\n\n\n\nNote\n\n\nA Windows Mobile version of the Wirecard ePOS SDK will be available shortly. Talk to your Wirecard representative for more information.\n\n\n\n\nWho is this for?\n\n\nWirecard works with partners who use the Wirecard ePOS SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the \nfunctionality\n that you create with the SDK as the \npayment acceptance app\n, even though it may not be a standalone app.\n\n\n\n\nTip\n\n\nIf you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the \nGlossary\n to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others.\n\n\n\n\nHow much is covered?\n\n\nEverything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The \nUsing This Documentation\n chapter shows you how to use each section of this documentation site.\n\n\nHow technical is it?\n\n\nA partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical.\n\n\nWhat do I need to know?\n\n\nProject managers on the technical team do not require any specific skills. Developers should have these skills:\n\n\n\n\niOS developers\n - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift)\n\n\nAndroid developers\n - basic understanding of your Android development environment and the Java programming language\n\n\n\n\nFor both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended.\n\n\nWhere should I start?\n\n\nWe recommend you take a few minutes to read \nThe Basics\n chapter and then the \nUsing this Documentation\n chapter. Or, if you just want to jump in to the more technical information, you can read the \nThe mPOS Architecture\n first.\n\n\n\n\nTip\n\n\nFor \ndevelopers\n who want to dive directly into the code, see the \nSet up on iOS\n or the \nSet up on Android\n.", 
            "title": "Start"
        }, 
        {
            "location": "/start/#welcome-to-the-wirecard-epos-sdk-partner-documentation", 
            "text": "The  Wirecard ePOS SDK  is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see  Wirecard mPOS SDK Integration .  The Wirecard ePOS SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay and WeChatPay. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the Wirecard ePOS SDK.   Note  A Windows Mobile version of the Wirecard ePOS SDK will be available shortly. Talk to your Wirecard representative for more information.", 
            "title": "Welcome to the Wirecard ePOS SDK Partner Documentation"
        }, 
        {
            "location": "/start/#who-is-this-for", 
            "text": "Wirecard works with partners who use the Wirecard ePOS SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the  functionality  that you create with the SDK as the  payment acceptance app , even though it may not be a standalone app.   Tip  If you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the  Glossary  to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others.", 
            "title": "Who is this for?"
        }, 
        {
            "location": "/start/#how-much-is-covered", 
            "text": "Everything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The  Using This Documentation  chapter shows you how to use each section of this documentation site.", 
            "title": "How much is covered?"
        }, 
        {
            "location": "/start/#how-technical-is-it", 
            "text": "A partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical.", 
            "title": "How technical is it?"
        }, 
        {
            "location": "/start/#what-do-i-need-to-know", 
            "text": "Project managers on the technical team do not require any specific skills. Developers should have these skills:   iOS developers  - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift)  Android developers  - basic understanding of your Android development environment and the Java programming language   For both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended.", 
            "title": "What do I need to know?"
        }, 
        {
            "location": "/start/#where-should-i-start", 
            "text": "We recommend you take a few minutes to read  The Basics  chapter and then the  Using this Documentation  chapter. Or, if you just want to jump in to the more technical information, you can read the  The mPOS Architecture  first.   Tip  For  developers  who want to dive directly into the code, see the  Set up on iOS  or the  Set up on Android .", 
            "title": "Where should I start?"
        }, 
        {
            "location": "/switch-reference/", 
            "text": "Switch Back-end Reference", 
            "title": "Switch Back-end Reference"
        }, 
        {
            "location": "/switch-reference/#switch-back-end-reference", 
            "text": "", 
            "title": "Switch Back-end Reference"
        }, 
        {
            "location": "/using/", 
            "text": "Using This Documentation\n\n\nThis topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the \nOverall Table of Contents\n because there is also a table of contents on the right side of the window and this is referred to as the \nChapter Table of Contents\n. The Chapter Table of Contents lists the headings that make up each individual chapter.\n\n\n\n\nNote\n\n\nOn smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this: \n\n\n\n\nStart\n\n\nThe \nStart\n section helps you get oriented. After this topic, there are two more really important ones you should read:\n\n\n\n\n\n\nThe \nmPOS Architecture\n topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the Wirecard ePOS SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment.\n\n\n\n\n\n\nThe \nSDK Architecture\n topic introduces the nine components that comprise the Wirecard ePOS SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code.\n\n\n\n\n\n\nSetup\n\n\nThe \nSetup\n section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs.\n\n\nIntegrate\n\n\nThe \nIntegrate\n section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the Wirecard ePOS SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed.\n\n\nIt also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in \nGIST\n.  Code is available in the following languages:\n\n\n\n\nSwift for iOS\n\n\nObjective-C for iOS\n\n\nJava for Android\n\n\n\n\nReferences\n\n\nThe \nReferences\n section actually has hundreds of pages of useful information, particularly for developers.\n\n\n\n\n\n\nThe \nReference - Android SDK\n topic, which is below the \nReferences\n section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a \nsub-site\n that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java.\n\n\n\n\n\n\nThe \nReference - iOS SDK\n topic, which is below the \nReferences\n section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a \nsub-site\n that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift.\n\n\n\n\n\n\nGlossary\n\n\nIf you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The \nGlossary\n addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.", 
            "title": "Using This Documentation"
        }, 
        {
            "location": "/using/#using-this-documentation", 
            "text": "This topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the  Overall Table of Contents  because there is also a table of contents on the right side of the window and this is referred to as the  Chapter Table of Contents . The Chapter Table of Contents lists the headings that make up each individual chapter.   Note  On smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this:", 
            "title": "Using This Documentation"
        }, 
        {
            "location": "/using/#start", 
            "text": "The  Start  section helps you get oriented. After this topic, there are two more really important ones you should read:    The  mPOS Architecture  topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the Wirecard ePOS SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment.    The  SDK Architecture  topic introduces the nine components that comprise the Wirecard ePOS SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code.", 
            "title": "Start"
        }, 
        {
            "location": "/using/#setup", 
            "text": "The  Setup  section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs.", 
            "title": "Setup"
        }, 
        {
            "location": "/using/#integrate", 
            "text": "The  Integrate  section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the Wirecard ePOS SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed.  It also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in  GIST .  Code is available in the following languages:   Swift for iOS  Objective-C for iOS  Java for Android", 
            "title": "Integrate"
        }, 
        {
            "location": "/using/#references", 
            "text": "The  References  section actually has hundreds of pages of useful information, particularly for developers.    The  Reference - Android SDK  topic, which is below the  References  section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a  sub-site  that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java.    The  Reference - iOS SDK  topic, which is below the  References  section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a  sub-site  that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift.", 
            "title": "References"
        }, 
        {
            "location": "/using/#glossary", 
            "text": "If you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The  Glossary  addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.", 
            "title": "Glossary"
        }, 
        {
            "location": "/old/Developer Reference (Android)/", 
            "text": "Developer Reference (Android)\n\n\nAlphabetical object/method reference.\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\netc", 
            "title": "Developer Reference (Android)"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#developer-reference-android", 
            "text": "Alphabetical object/method reference.", 
            "title": "Developer Reference (Android)"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#a", 
            "text": "", 
            "title": "A"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#b", 
            "text": "", 
            "title": "B"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#c", 
            "text": "", 
            "title": "C"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#d", 
            "text": "", 
            "title": "D"
        }, 
        {
            "location": "/old/Developer Reference (Android)/#etc", 
            "text": "", 
            "title": "etc"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/", 
            "text": "Developer Reference (iOS)\n\n\nAlphabetical object/method reference.\n\n\nA\n\n\nB\n\n\nC\n\n\nD\n\n\netc", 
            "title": "Developer Reference (iOS)"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#developer-reference-ios", 
            "text": "Alphabetical object/method reference.", 
            "title": "Developer Reference (iOS)"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#a", 
            "text": "", 
            "title": "A"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#b", 
            "text": "", 
            "title": "B"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#c", 
            "text": "", 
            "title": "C"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#d", 
            "text": "", 
            "title": "D"
        }, 
        {
            "location": "/old/Developer Reference (iOS)/#etc", 
            "text": "", 
            "title": "etc"
        }, 
        {
            "location": "/old/allclasses-frame/", 
            "text": "Android Classes\n\n\nAuto-generated via Javadoc.\n\n\nAbsUpdateEvent\n\n\nAcceptBackendException\n\n\nAcceptCashDrawerExtension\n\n\nAcceptDevice\n\n\nAcceptException\n\n\nAcceptExtension\n\n\nAcceptPrinterExtension\n\n\nAcceptPublicExtension\n\n\nAcceptRetrofitListener\n\n\nAcceptScannerExtension\n\n\nAcceptSDK\n\n\nAcceptSdkBuilder\n\n\nAcceptSdkFactory\n\n\nAcceptTerminalExtension", 
            "title": "Allclasses frame"
        }, 
        {
            "location": "/old/allclasses-frame/#android-classes", 
            "text": "Auto-generated via Javadoc.", 
            "title": "Android Classes"
        }, 
        {
            "location": "/old/allclasses-frame/#absupdateevent", 
            "text": "", 
            "title": "AbsUpdateEvent"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptbackendexception", 
            "text": "", 
            "title": "AcceptBackendException"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptcashdrawerextension", 
            "text": "", 
            "title": "AcceptCashDrawerExtension"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptdevice", 
            "text": "", 
            "title": "AcceptDevice"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptexception", 
            "text": "", 
            "title": "AcceptException"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptextension", 
            "text": "", 
            "title": "AcceptExtension"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptprinterextension", 
            "text": "", 
            "title": "AcceptPrinterExtension"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptpublicextension", 
            "text": "", 
            "title": "AcceptPublicExtension"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptretrofitlistener", 
            "text": "", 
            "title": "AcceptRetrofitListener"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptscannerextension", 
            "text": "", 
            "title": "AcceptScannerExtension"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptsdk", 
            "text": "", 
            "title": "AcceptSDK"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptsdkbuilder", 
            "text": "", 
            "title": "AcceptSdkBuilder"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptsdkfactory", 
            "text": "", 
            "title": "AcceptSdkFactory"
        }, 
        {
            "location": "/old/allclasses-frame/#acceptterminalextension", 
            "text": "", 
            "title": "AcceptTerminalExtension"
        }, 
        {
            "location": "/old/glossary-acronyms/", 
            "text": "", 
            "title": "Glossary acronyms"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/", 
            "text": "Overview of the Project\n\n\nObjectives\n\n\nPayment app on iOS and Android mobile devices for partners supplying apps to merchants.\n\n\nStandard vs. Non-standards Integrations\n\n\nClarify with Geza. How many approaches? Two. Vanilla and fancy? \n\n\nClosely related to the next architecture chapter: will they go with all Wirecard components or other vendors? \n\n\nIs white label terminology still valid?\n\n\nKey Terminology\n\n\nPartner\n\n\nAccept Payment App\n\n\nshould we add accept to the title to relate it more directly to AcceptSDK\n\n\nMerchant\n\n\nuser of the payment app\n\n\nCustomer\n\n\nSame as merchant?\n\n\nEnd-customer the app is created for.\n\n\nTerminal\n\n\nOthers\n\n\nKey Concepts\n\n\nAbout Wirecard\n\n\nmarketing\n\n\nAbout mPOS\n\n\nbasics", 
            "title": "Overview of the Project"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#overview-of-the-project", 
            "text": "", 
            "title": "Overview of the Project"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#objectives", 
            "text": "Payment app on iOS and Android mobile devices for partners supplying apps to merchants.", 
            "title": "Objectives"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#standard-vs-non-standards-integrations", 
            "text": "Clarify with Geza. How many approaches? Two. Vanilla and fancy?   Closely related to the next architecture chapter: will they go with all Wirecard components or other vendors?   Is white label terminology still valid?", 
            "title": "Standard vs. Non-standards Integrations"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#key-terminology", 
            "text": "", 
            "title": "Key Terminology"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#partner", 
            "text": "", 
            "title": "Partner"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#accept-payment-app", 
            "text": "should we add accept to the title to relate it more directly to AcceptSDK", 
            "title": "Accept Payment App"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#merchant", 
            "text": "user of the payment app", 
            "title": "Merchant"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#customer", 
            "text": "Same as merchant?  End-customer the app is created for.", 
            "title": "Customer"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#terminal", 
            "text": "", 
            "title": "Terminal"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#others", 
            "text": "", 
            "title": "Others"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#key-concepts", 
            "text": "", 
            "title": "Key Concepts"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#about-wirecard", 
            "text": "marketing", 
            "title": "About Wirecard"
        }, 
        {
            "location": "/old/xxx 001 Overview of the Project/#about-mpos", 
            "text": "basics", 
            "title": "About mPOS"
        }
    ]
}