{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Welcome"},{"location":"android-reference/","text":"Android SDK Reference","title":"Android SDK Reference"},{"location":"android-reference/#android-sdk-reference","text":"","title":"Android SDK Reference"},{"location":"appa-other/","text":"Appendix A - Other","title":"Appendix A - Other"},{"location":"appa-other/#appendix-a-other","text":"","title":"Appendix A - Other"},{"location":"appb-emv/","text":"Appendix B - EMV Reference","title":"Appendix B - EMV Reference"},{"location":"appb-emv/#appendix-b-emv-reference","text":"","title":"Appendix B - EMV Reference"},{"location":"appc-payment/","text":"Guide to Basic Payment Processing","title":"Guide to Basic Payment Processing"},{"location":"appc-payment/#guide-to-basic-payment-processing","text":"","title":"Guide to Basic Payment Processing"},{"location":"basics/","text":"The Basics This chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support. What does it do? The Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods. Which payments methods are supported? Cash If you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality. Card You can also use the SDK to create functionality to accept payments from: Visa Mastercard Alternative Payment Methods The following alternative payment methods can also be accepted: Alipay WeChat Pay Which transaction types are supported? The following payment operations are supported: Purchase Reversal Refund (both partial and full) What are the prerequisites for using the SDK? These are the prerequisites for both iOS and Android: iOS - v9.0 or higher Android - v4.0 or higher Android Studio How do I find and install the SDK? The two SDKs are available here: JFrog Bintray for Android . Github repository for iOS Setup instructions are provided on this site: for Android, see the Set up on Android section of this website, starting with the Automated Setup with JitPack chapter for iOS, see the Set up on iOS section of this website, starting with the Automated Setup with Cocoapods chapter Is there sample code? Yes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using Gists , a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The Integrating the SDK section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages: iOS: Objective-C iOS: Swift Android: Java Is there demo application? Yes. You can check standalone demo application for both platforms. iOS Wirecard ePOS Demo Android Wirecard ePOS Demo Is there integration testing code? Yes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See Android Integration Tests and iOS Integration Tests . How do I get technical support? Please email: pos-solutions@wirecard.com Which hardware is supported? Printers Datecs printer DPP-250 StarMicronics TSP650 , SM-L200 Cash Drawer or Multi-function Devices StarMicronics mPOP StarMicronics SMD2 Handheld Scanners SocketMobile Series 7 Registration on Apple's MFI program If you plan on releasing your iOS app with the above hardware enabled, please follow the steps in MFI registration section before submitting the app to the Apple Review Warning MFI Approval process takes approximately two weeks License Wirecard ePOS SDK is available under the MIT license. See the LICENSE file for more info.","title":"The Basics"},{"location":"basics/#the-basics","text":"This chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support.","title":"The Basics"},{"location":"basics/#what-does-it-do","text":"The Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods.","title":"What does it do?"},{"location":"basics/#which-payments-methods-are-supported","text":"","title":"Which payments methods are supported?"},{"location":"basics/#cash","text":"If you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality.","title":"Cash"},{"location":"basics/#card","text":"You can also use the SDK to create functionality to accept payments from: Visa Mastercard","title":"Card"},{"location":"basics/#alternative-payment-methods","text":"The following alternative payment methods can also be accepted: Alipay WeChat Pay","title":"Alternative Payment Methods"},{"location":"basics/#which-transaction-types-are-supported","text":"The following payment operations are supported: Purchase Reversal Refund (both partial and full)","title":"Which transaction types are supported?"},{"location":"basics/#what-are-the-prerequisites-for-using-the-sdk","text":"These are the prerequisites for both iOS and Android: iOS - v9.0 or higher Android - v4.0 or higher Android Studio","title":"What are the prerequisites for using the SDK?"},{"location":"basics/#how-do-i-find-and-install-the-sdk","text":"The two SDKs are available here: JFrog Bintray for Android . Github repository for iOS Setup instructions are provided on this site: for Android, see the Set up on Android section of this website, starting with the Automated Setup with JitPack chapter for iOS, see the Set up on iOS section of this website, starting with the Automated Setup with Cocoapods chapter","title":"How do I find and install the SDK?"},{"location":"basics/#is-there-sample-code","text":"Yes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using Gists , a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The Integrating the SDK section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages: iOS: Objective-C iOS: Swift Android: Java","title":"Is there sample code?"},{"location":"basics/#is-there-demo-application","text":"Yes. You can check standalone demo application for both platforms. iOS Wirecard ePOS Demo Android Wirecard ePOS Demo","title":"Is there demo application?"},{"location":"basics/#is-there-integration-testing-code","text":"Yes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See Android Integration Tests and iOS Integration Tests .","title":"Is there integration testing code?"},{"location":"basics/#how-do-i-get-technical-support","text":"Please email: pos-solutions@wirecard.com","title":"How do I get technical support?"},{"location":"basics/#which-hardware-is-supported","text":"","title":"Which hardware is supported?"},{"location":"basics/#printers","text":"Datecs printer DPP-250 StarMicronics TSP650 , SM-L200","title":"Printers"},{"location":"basics/#cash-drawer-or-multi-function-devices","text":"StarMicronics mPOP StarMicronics SMD2","title":"Cash Drawer or Multi-function Devices"},{"location":"basics/#handheld-scanners","text":"SocketMobile Series 7","title":"Handheld Scanners"},{"location":"basics/#registration-on-apples-mfi-program","text":"If you plan on releasing your iOS app with the above hardware enabled, please follow the steps in MFI registration section before submitting the app to the Apple Review Warning MFI Approval process takes approximately two weeks","title":"Registration on Apple's MFI program"},{"location":"basics/#license","text":"Wirecard ePOS SDK is available under the MIT license. See the LICENSE file for more info.","title":"License"},{"location":"fake-external-link/","text":"","title":"Reference - iOS SDK &#x1F5D7|iosref/"},{"location":"glossary/","text":"Glossary Glossary of Acronyms CNP \u2013 Chip and PIN CVM - Card Verification Method DUKPT \u2013 Derived Unique Key Per Transaction EFT - Electronic Funds Transfer EMV - Europay, Mastercard, Visa. See EMV below. ERP \u2013 Enterprise Resource Planning FW - Firmware HSM - Hardware Security Module. See HSM below. mPOS - mobile Point of Sale MFI \u2013 Made for iPhone. PCI DSS \u2013 Payment Card Industry Data Security Standard REST \u2013 Representational State Transfer SEPA - Single Euro Payments Area UUID \u2013 Unique User Identifier Glossary of Terminology A Acquiring Platform \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the Acquirer and handles the interchange with the card schemes so that, ultimately, the transaction is debited from the account of the Cardholder. For Wirecard ePOS SDK, a merchant requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's Payment & Risk division provides its own Acquiring Platform with the Wirecard Acquiring and Processing unit. Acquirer - Entities that collect card payments that have been accepted by merchants, and then aggregate and separate those payments and forward them on to Issuers for processing. Also known as Merchant Acquirers . Acquiring and Processing - Unit of Wirecard that provides an Acquiring Platform . Alipay \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The Wirecard ePOS SDK supports payments made through Alipay. authorize - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale. B back-end - Refers to the new Switch back-end. With Wirecard ePOS SDK, you create a front-end payment acceptance app and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the Gateway , which in turn, forwards the transaction on to the Acquirer and, ultimately, to the Issuer so that the consumer can pay the Issuer. In addition, many merchants also have an ERP system connected which augments the back-end functionality provided by Switch. barcode - One of two possible types of codes that can be scanned with a pistol scanner . The other type is a QR code . basket - A user-defined collection of items for purchase, also referred to as a cart or shopping cart . Business ByDesign - See SAP Business ByDesign . C cardholder - Consumer who uses a debit or credit card as their method of payment. Card Issuer - See Issuer . card reader - See terminal . cart - See basket . cash - Physical money in the form of bank notes or coins. cash in/out - See pay in/out . cash payments - Payment with bank notes or coins. The opposite of cashless payments . cash register - Refers to an actual piece of hardware that provides cash register functionality. Cash Register (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code. Cash Register - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component. Cashier - User of a cash register. Each Cashier must be associated with a Cash Register. cashless payment - Payment that involves a card, and does not involve bank notes or coins. The opposite of cash payments . Chip and PIN cards - See EMV cards . Chip and Signature cards - See EMV cards . consumer - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a cardholder . customer - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including SAP Business By Design . See member . D device - The physical hardware used by the merchant who has the payment acceptance app installed. E electronic payments - Same as cashless payments . Contrast with cash payments . EMV - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others. EMV Cards \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called Chip and PIN or Chip and Signature cards. F Firmware \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the payment acceptance app that you create. front-end - The payment acceptance app that is created by partners using the Wirecard ePOS SDK is typically referred to as the front-end to distinguish it from the Switch back-end , which handles the processing and routing of transactions. full refund - A return to the consumer of the full amount that they paid in the original sale. G Gateway - Wirecard component that is responsible for the initial processing of the transaction and then routing to the Acquirer . Initial processing includes handling the secure decryption of MagStripe , EMV and both offline and online PIN transactions. An HSM is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the Wirecard ePOS SDK, there is a Test Gateway to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development. gift card \u2013 Physical or online card that provides the consumer with a discount on a purchase. H HSM - A physical device that helps with the decryption of PIN and other card holder data. I Inventory Manager - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images). Issuing Bank - See Card Issuer . Issuer - See Card Issuer . M merchant - A seller of products, typically with a physical location, which is known as a store or shop . The Wirecard ePOS SDK is used by our partners to create payment acceptance apps for merchants. Merchant Acquirer - See Acquirer . member - A term that is sometimes used by ERP back-end systems to refer to customers. See customer . mobile device \u2013 Hardware on which apps created with the Wirecard ePOS SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon. Switch Portal - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end. O Objective-C - One of the programming languages that is available on the iOS platform. It is also available in the Swift language. P partial refund - A return to the consumer of a portion of the amount they paid in the original sale. partner - Refers to companies that collaborate with Wirecard to create payment acceptance apps for merchants using the Wirecard ePOS SDK. partner team - One or more persons at a partner company responsible for creating a payment acceptance app using the Wirecard ePOS SDK. Typically, a partner team consists of a project manager and one or more developers. This Wirecard ePOS SDK documentation was created for our partner teams. pay in/out \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out. payment gateway - See Gateway . payment method - Form of payment used in a sale. With the Wirecard ePOS SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay. Payment & Risk - Division of Wirecard that handles Acquiring and Processing services. payment acceptance app - App that Wirecard partners create with the Wirecard ePOS SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the Wirecard ePOS SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the Wirecard ePOS SDK is always referred to as the payment acceptance app . payment gateway \u2013 Transaction processing and routing. See Gateway . pistol scanner - Handheld scanner used to scan barcodes and QR codes . platform - Refers to the operating system on which the Wirecard ePOS SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK. product catalogue - A set of products. Also commonly referred to as inventory. See Inventory Manager . Public Test \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK. purchase - The most common transaction type . A purchase involves the consumer buying something from a merchant . Other types of transactions include return , authorize , pre-authorize . Q QR code - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a pistol scanner . See also barcode . R return - Can be a reverse or a refund . reverse - A cancellation of a sale, which can be performed if the sale has not yet been processed by the Acquiring Platform . refund - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds. S sale - The initial interaction between the merchant user and a consumer . In terms of the SDK code, sales begin with a Sale Request and completes with a Sale Response . Sale Response - SDK object that has the results of the sale after processing by the back-end. Sale Request - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a purchase , but it can also be a return , an authorize , or a pre-authorize . SAP Business ByDesign - A cloud-based ERP solution for small to medium-sized businesses. This software can be used to augment the Switch back-end which is provided as part of the SDK. scanner - See pistol scanner . SEPA \u2013 The Single Euro Payments Area (SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros. shift \u2013 Working time of a merchant user. Starts with the open and ends with the close. shop - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location. shopping cart - See basket . Shift Report - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report. Shift Activity \u2013 Pay in/out activity between the open and close of a shift. Star Micronics - Vendor of payment acceptance hardware. StarIO - See Star Micronics . store - See shop . Swift - One of the programming languages that is available on the iOS platform. See also Objective-C . Switch - The back-end of the Wirecard ePOS SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information. T terminal \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader. transaction - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit. transaction type - Indicates the nature of a transaction, such as a purchase or an authorize . U user - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as Cashiers . V vendor \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Spire, PAX, Star, Socket and Datecs. W WeChat Pay - One of the most popular alternative payment methods available in China, this is a digital wallet service. Z Z-Report \u2013 See Shift Report .","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#glossary-of-acronyms","text":"CNP \u2013 Chip and PIN CVM - Card Verification Method DUKPT \u2013 Derived Unique Key Per Transaction EFT - Electronic Funds Transfer EMV - Europay, Mastercard, Visa. See EMV below. ERP \u2013 Enterprise Resource Planning FW - Firmware HSM - Hardware Security Module. See HSM below. mPOS - mobile Point of Sale MFI \u2013 Made for iPhone. PCI DSS \u2013 Payment Card Industry Data Security Standard REST \u2013 Representational State Transfer SEPA - Single Euro Payments Area UUID \u2013 Unique User Identifier","title":"Glossary of Acronyms"},{"location":"glossary/#glossary-of-terminology","text":"","title":"Glossary of Terminology"},{"location":"glossary/#a","text":"Acquiring Platform \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the Acquirer and handles the interchange with the card schemes so that, ultimately, the transaction is debited from the account of the Cardholder. For Wirecard ePOS SDK, a merchant requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's Payment & Risk division provides its own Acquiring Platform with the Wirecard Acquiring and Processing unit. Acquirer - Entities that collect card payments that have been accepted by merchants, and then aggregate and separate those payments and forward them on to Issuers for processing. Also known as Merchant Acquirers . Acquiring and Processing - Unit of Wirecard that provides an Acquiring Platform . Alipay \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The Wirecard ePOS SDK supports payments made through Alipay. authorize - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale.","title":"A"},{"location":"glossary/#b","text":"back-end - Refers to the new Switch back-end. With Wirecard ePOS SDK, you create a front-end payment acceptance app and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the Gateway , which in turn, forwards the transaction on to the Acquirer and, ultimately, to the Issuer so that the consumer can pay the Issuer. In addition, many merchants also have an ERP system connected which augments the back-end functionality provided by Switch. barcode - One of two possible types of codes that can be scanned with a pistol scanner . The other type is a QR code . basket - A user-defined collection of items for purchase, also referred to as a cart or shopping cart . Business ByDesign - See SAP Business ByDesign .","title":"B"},{"location":"glossary/#c","text":"cardholder - Consumer who uses a debit or credit card as their method of payment. Card Issuer - See Issuer . card reader - See terminal . cart - See basket . cash - Physical money in the form of bank notes or coins. cash in/out - See pay in/out . cash payments - Payment with bank notes or coins. The opposite of cashless payments . cash register - Refers to an actual piece of hardware that provides cash register functionality. Cash Register (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code. Cash Register - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component. Cashier - User of a cash register. Each Cashier must be associated with a Cash Register. cashless payment - Payment that involves a card, and does not involve bank notes or coins. The opposite of cash payments . Chip and PIN cards - See EMV cards . Chip and Signature cards - See EMV cards . consumer - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a cardholder . customer - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including SAP Business By Design . See member .","title":"C"},{"location":"glossary/#d","text":"device - The physical hardware used by the merchant who has the payment acceptance app installed.","title":"D"},{"location":"glossary/#e","text":"electronic payments - Same as cashless payments . Contrast with cash payments . EMV - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others. EMV Cards \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called Chip and PIN or Chip and Signature cards.","title":"E"},{"location":"glossary/#f","text":"Firmware \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the payment acceptance app that you create. front-end - The payment acceptance app that is created by partners using the Wirecard ePOS SDK is typically referred to as the front-end to distinguish it from the Switch back-end , which handles the processing and routing of transactions. full refund - A return to the consumer of the full amount that they paid in the original sale.","title":"F"},{"location":"glossary/#g","text":"Gateway - Wirecard component that is responsible for the initial processing of the transaction and then routing to the Acquirer . Initial processing includes handling the secure decryption of MagStripe , EMV and both offline and online PIN transactions. An HSM is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the Wirecard ePOS SDK, there is a Test Gateway to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development. gift card \u2013 Physical or online card that provides the consumer with a discount on a purchase.","title":"G"},{"location":"glossary/#h","text":"HSM - A physical device that helps with the decryption of PIN and other card holder data.","title":"H"},{"location":"glossary/#i","text":"Inventory Manager - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images). Issuing Bank - See Card Issuer . Issuer - See Card Issuer .","title":"I"},{"location":"glossary/#m","text":"merchant - A seller of products, typically with a physical location, which is known as a store or shop . The Wirecard ePOS SDK is used by our partners to create payment acceptance apps for merchants. Merchant Acquirer - See Acquirer . member - A term that is sometimes used by ERP back-end systems to refer to customers. See customer . mobile device \u2013 Hardware on which apps created with the Wirecard ePOS SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon. Switch Portal - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end.","title":"M"},{"location":"glossary/#o","text":"Objective-C - One of the programming languages that is available on the iOS platform. It is also available in the Swift language.","title":"O"},{"location":"glossary/#p","text":"partial refund - A return to the consumer of a portion of the amount they paid in the original sale. partner - Refers to companies that collaborate with Wirecard to create payment acceptance apps for merchants using the Wirecard ePOS SDK. partner team - One or more persons at a partner company responsible for creating a payment acceptance app using the Wirecard ePOS SDK. Typically, a partner team consists of a project manager and one or more developers. This Wirecard ePOS SDK documentation was created for our partner teams. pay in/out \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out. payment gateway - See Gateway . payment method - Form of payment used in a sale. With the Wirecard ePOS SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay. Payment & Risk - Division of Wirecard that handles Acquiring and Processing services. payment acceptance app - App that Wirecard partners create with the Wirecard ePOS SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the Wirecard ePOS SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the Wirecard ePOS SDK is always referred to as the payment acceptance app . payment gateway \u2013 Transaction processing and routing. See Gateway . pistol scanner - Handheld scanner used to scan barcodes and QR codes . platform - Refers to the operating system on which the Wirecard ePOS SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK. product catalogue - A set of products. Also commonly referred to as inventory. See Inventory Manager . Public Test \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK. purchase - The most common transaction type . A purchase involves the consumer buying something from a merchant . Other types of transactions include return , authorize , pre-authorize .","title":"P"},{"location":"glossary/#q","text":"QR code - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a pistol scanner . See also barcode .","title":"Q"},{"location":"glossary/#r","text":"return - Can be a reverse or a refund . reverse - A cancellation of a sale, which can be performed if the sale has not yet been processed by the Acquiring Platform . refund - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds.","title":"R"},{"location":"glossary/#s","text":"sale - The initial interaction between the merchant user and a consumer . In terms of the SDK code, sales begin with a Sale Request and completes with a Sale Response . Sale Response - SDK object that has the results of the sale after processing by the back-end. Sale Request - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a purchase , but it can also be a return , an authorize , or a pre-authorize . SAP Business ByDesign - A cloud-based ERP solution for small to medium-sized businesses. This software can be used to augment the Switch back-end which is provided as part of the SDK. scanner - See pistol scanner . SEPA \u2013 The Single Euro Payments Area (SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros. shift \u2013 Working time of a merchant user. Starts with the open and ends with the close. shop - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location. shopping cart - See basket . Shift Report - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report. Shift Activity \u2013 Pay in/out activity between the open and close of a shift. Star Micronics - Vendor of payment acceptance hardware. StarIO - See Star Micronics . store - See shop . Swift - One of the programming languages that is available on the iOS platform. See also Objective-C . Switch - The back-end of the Wirecard ePOS SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information.","title":"S"},{"location":"glossary/#t","text":"terminal \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader. transaction - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit. transaction type - Indicates the nature of a transaction, such as a purchase or an authorize .","title":"T"},{"location":"glossary/#u","text":"user - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as Cashiers .","title":"U"},{"location":"glossary/#v","text":"vendor \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Spire, PAX, Star, Socket and Datecs.","title":"V"},{"location":"glossary/#w","text":"WeChat Pay - One of the most popular alternative payment methods available in China, this is a digital wallet service.","title":"W"},{"location":"glossary/#z","text":"Z-Report \u2013 See Shift Report .","title":"Z"},{"location":"int-cash-cashiers-pin/","text":"Cashiers with PIN The second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the Cashiers chapter. The User Interface A typical interface might look like this: The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Cashiers With PIN"},{"location":"int-cash-cashiers-pin/#cashiers-with-pin","text":"The second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the Cashiers chapter.","title":"Cashiers with PIN"},{"location":"int-cash-cashiers-pin/#the-user-interface","text":"A typical interface might look like this:","title":"The User Interface"},{"location":"int-cash-cashiers-pin/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-cash-cashiers/","text":"Cashiers Cashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales. There are two methods to obtain the identifier for a Cashier: Obtain the cashier linked to the merchant user who is already logged in. Present a PIN entry user interface to the merchant user and have them log in. This chapter covers the first use case, while the next chapter covers the PIN entry validation use case. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Cashiers"},{"location":"int-cash-cashiers/#cashiers","text":"Cashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales. There are two methods to obtain the identifier for a Cashier: Obtain the cashier linked to the merchant user who is already logged in. Present a PIN entry user interface to the merchant user and have them log in. This chapter covers the first use case, while the next chapter covers the PIN entry validation use case.","title":"Cashiers"},{"location":"int-cash-cashiers/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-cash-overview/","text":"Cash Manager Overview Cash Management is an optional feature of the Wirecard ePOS SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature. Most of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the Cash Drawer Manager , which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user. Features of Cash Manager More specifically, the Cash Manager component supports: cash register management opening and closing of shifts (a shift being a period of time worked by merchant staff) putting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out) reporting on shift activity for each cash register reporting on cash activity (also known as Z-Reports) for each cash register For complete information about the hardware required to use Cash Management, see the Cash Drawer Manager chapter. Cashier Base You also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for: support of PIN-authorized users support for ERP Integration (such as SAP By Design)","title":"Cash Manager Overview"},{"location":"int-cash-overview/#cash-manager-overview","text":"Cash Management is an optional feature of the Wirecard ePOS SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature. Most of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the Cash Drawer Manager , which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user.","title":"Cash Manager Overview"},{"location":"int-cash-overview/#features-of-cash-manager","text":"More specifically, the Cash Manager component supports: cash register management opening and closing of shifts (a shift being a period of time worked by merchant staff) putting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out) reporting on shift activity for each cash register reporting on cash activity (also known as Z-Reports) for each cash register For complete information about the hardware required to use Cash Management, see the Cash Drawer Manager chapter.","title":"Features of Cash Manager"},{"location":"int-cash-overview/#cashier-base","text":"You also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for: support of PIN-authorized users support for ERP Integration (such as SAP By Design)","title":"Cashier Base"},{"location":"int-cash-payinout/","text":"Pay In/Out We have seen how to open and close a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the pay in and the pay out , or sometimes it is referred to as the cash in and cash out . You can report on all cash activity during a shift using Shift Activity , or after the shift is closed you can report on all activity using Shift Report . As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the Cash Registers . The User Interface A typical interface might look like this: Note The Android sample code uses an amount of 200 \u20ac. The Sample Code Pay ins and pay outs are both recorded in an amount field so it is crucial to note that pay ins are entered using a positive number while pay outs are entered using a negative number . BigDecimal is used in the Java code with a sample value of 200 \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac amount is used in the iOS code with a sample value of 100 \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac Caution As the code comments make clear, the cash currency must match the currency of the selected cash register. ObjC Swift Universal Windows Platform SDK coming soon","title":"Pay In/Out"},{"location":"int-cash-payinout/#pay-inout","text":"We have seen how to open and close a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the pay in and the pay out , or sometimes it is referred to as the cash in and cash out . You can report on all cash activity during a shift using Shift Activity , or after the shift is closed you can report on all activity using Shift Report . As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the Cash Registers .","title":"Pay In/Out"},{"location":"int-cash-payinout/#the-user-interface","text":"A typical interface might look like this: Note The Android sample code uses an amount of 200 \u20ac.","title":"The User Interface"},{"location":"int-cash-payinout/#the-sample-code","text":"Pay ins and pay outs are both recorded in an amount field so it is crucial to note that pay ins are entered using a positive number while pay outs are entered using a negative number . BigDecimal is used in the Java code with a sample value of 200 \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac amount is used in the iOS code with a sample value of 100 \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac Caution As the code comments make clear, the cash currency must match the currency of the selected cash register.","title":"The Sample Code"},{"location":"int-cash-register/","text":"Cash Registers The first step in dealing with cash is to select a cash register that will be used by the cash sale request . More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a cashRegisters object stores the valid cash register identifiers. Tip For complete information about setting up cash register and cash drawer hardware, see Cash Drawer Manager . The User Interface As illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it: Note Even though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device. The Sample Code The sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of cashRegisters , you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe. ObjC Swift Universal Windows Platform SDK coming soon","title":"Cash Registers"},{"location":"int-cash-register/#cash-registers","text":"The first step in dealing with cash is to select a cash register that will be used by the cash sale request . More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a cashRegisters object stores the valid cash register identifiers. Tip For complete information about setting up cash register and cash drawer hardware, see Cash Drawer Manager .","title":"Cash Registers"},{"location":"int-cash-register/#the-user-interface","text":"As illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it: Note Even though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device.","title":"The User Interface"},{"location":"int-cash-register/#the-sample-code","text":"The sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of cashRegisters , you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe.","title":"The Sample Code"},{"location":"int-cash-shift-activity/","text":"Shift Activity You can query all pay in/out activity for: a specific shift and a specific cash register And then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using Cash Registers . The Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Shift Activity"},{"location":"int-cash-shift-activity/#shift-activity","text":"You can query all pay in/out activity for: a specific shift and a specific cash register And then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using Cash Registers .","title":"Shift Activity"},{"location":"int-cash-shift-activity/#the-code","text":"","title":"The Code"},{"location":"int-cash-shift-close/","text":"Close Shift At the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the opening of their shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by Cash Registers . During the shift, cash that goes in and out of the cash register is recorded by Pay In/Out . Caution A Shift Report for a shift can only be generated after a shift is closed. The User Interface The user interface is almost the same as the Open Shift one, but with a couple of key changes: The Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Close Shift"},{"location":"int-cash-shift-close/#close-shift","text":"At the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the opening of their shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by Cash Registers . During the shift, cash that goes in and out of the cash register is recorded by Pay In/Out . Caution A Shift Report for a shift can only be generated after a shift is closed.","title":"Close Shift"},{"location":"int-cash-shift-close/#the-user-interface","text":"The user interface is almost the same as the Open Shift one, but with a couple of key changes:","title":"The User Interface"},{"location":"int-cash-shift-close/#the-code","text":"","title":"The Code"},{"location":"int-cash-shift-open/","text":"Open Shift Just like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in Pay In/Out . You must also record the amount of cash in the register when the shift is over. This is referred to as closing the shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by Cash Registers . Caution Sales can only be performed after a shift is opened. The User Interface Once again, to visualize what a user interface might look like we created a mockup: The Sample Code The sample code demonstrates how to open the shift for a specific cash register, which includes recording: the amount of cash in the drawer which is very important for reconciliation purposes ( amount in the iOS code and openingAmount in the Android code) and optionally, recording a note related to the opening of the drawer ( note in the iOS code and openingNote in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing\"). ObjC Swift Universal Windows Platform SDK coming soon","title":"Open Shift"},{"location":"int-cash-shift-open/#open-shift","text":"Just like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in Pay In/Out . You must also record the amount of cash in the register when the shift is over. This is referred to as closing the shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by Cash Registers . Caution Sales can only be performed after a shift is opened.","title":"Open Shift"},{"location":"int-cash-shift-open/#the-user-interface","text":"Once again, to visualize what a user interface might look like we created a mockup:","title":"The User Interface"},{"location":"int-cash-shift-open/#the-sample-code","text":"The sample code demonstrates how to open the shift for a specific cash register, which includes recording: the amount of cash in the drawer which is very important for reconciliation purposes ( amount in the iOS code and openingAmount in the Android code) and optionally, recording a note related to the opening of the drawer ( note in the iOS code and openingNote in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing\").","title":"The Sample Code"},{"location":"int-cash-shift-report/","text":"Shift Report After a shift is closed , cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes: opening and closing times opening and closing amounts cashier names sale categories (cash, card or coupon) net amount gross amount per sale (for purchases and returns) tax charged The Shift identifier and Cash Register identifier are both required. Note A Shift Report is also known as a Z-Report. The Sample Code On both platforms, the cashShift has all of the information needed to create the Shift Report. Caution On both platforms, a shift must first be closed before you can generate a shift report. ObjC Swift Universal Windows Platform SDK coming soon","title":"Shift Report"},{"location":"int-cash-shift-report/#shift-report","text":"After a shift is closed , cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes: opening and closing times opening and closing amounts cashier names sale categories (cash, card or coupon) net amount gross amount per sale (for purchases and returns) tax charged The Shift identifier and Cash Register identifier are both required. Note A Shift Report is also known as a Z-Report.","title":"Shift Report"},{"location":"int-cash-shift-report/#the-sample-code","text":"On both platforms, the cashShift has all of the information needed to create the Shift Report. Caution On both platforms, a shift must first be closed before you can generate a shift report.","title":"The Sample Code"},{"location":"int-cashdrawer-connect/","text":"Check Connection Status The connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Check Connection Status"},{"location":"int-cashdrawer-connect/#check-connection-status","text":"The connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code.","title":"Check Connection Status"},{"location":"int-cashdrawer-connect/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-cashdrawer-discovery/","text":"Cash Drawer Discovery The device discovery functionality of Cash Drawer Manager: discovers any connected Star Micronics or other cash drawer devices registers to receive device status updates registers to receive action result updates handles the reception of notifications related to: connection status battery levels So, related to the last point above, there are two main tasks for you: implement the connectionStatusDidChange implement the batteryLevelDidChange The User Interface A typical user interface might look like this: The Sample Code For simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner. ObjC Swift Universal Windows Platform SDK coming soon","title":"Cash Drawer Discovery"},{"location":"int-cashdrawer-discovery/#cash-drawer-discovery","text":"The device discovery functionality of Cash Drawer Manager: discovers any connected Star Micronics or other cash drawer devices registers to receive device status updates registers to receive action result updates handles the reception of notifications related to: connection status battery levels So, related to the last point above, there are two main tasks for you: implement the connectionStatusDidChange implement the batteryLevelDidChange","title":"Cash Drawer Discovery"},{"location":"int-cashdrawer-discovery/#the-user-interface","text":"A typical user interface might look like this:","title":"The User Interface"},{"location":"int-cashdrawer-discovery/#the-sample-code","text":"For simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.","title":"The Sample Code"},{"location":"int-cashdrawer-open/","text":"Open Cash Drawer The sample code in this chapter builds on the code in the previous chapter by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Open Cash Drawer"},{"location":"int-cashdrawer-open/#open-cash-drawer","text":"The sample code in this chapter builds on the code in the previous chapter by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins.","title":"Open Cash Drawer"},{"location":"int-cashdrawer-open/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-cashdrawer-overview/","text":"Cash Drawer Manager Overview This section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to: discover paired cash drawers open cash drawers connect to Bluetooth cash drawers and check their status","title":"Cash Drawer Overview"},{"location":"int-cashdrawer-overview/#cash-drawer-manager-overview","text":"This section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to: discover paired cash drawers open cash drawers connect to Bluetooth cash drawers and check their status","title":"Cash Drawer Manager Overview"},{"location":"int-complete/","text":"A Complete Sale This chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the EposSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far. The User Interface Here's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card: The iOS Object Model Since this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the add cash transaction and the add card transaction methods are used to process the split-method payment from the consumer: Tip Just like in the previous chapter , it is recommended you read the bottom lines of code first to see the overall payment flow. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"A Complete Sale"},{"location":"int-complete/#a-complete-sale","text":"This chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the EposSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far.","title":"A Complete Sale"},{"location":"int-complete/#the-user-interface","text":"Here's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card:","title":"The User Interface"},{"location":"int-complete/#the-ios-object-model","text":"Since this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the add cash transaction and the add card transaction methods are used to process the split-method payment from the consumer: Tip Just like in the previous chapter , it is recommended you read the bottom lines of code first to see the overall payment flow.","title":"The iOS Object Model"},{"location":"int-complete/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-customermanager/","text":"Customer Manager (ERP) If the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on: the unique identifier for the member the first name the surname The unique identifier for a member can typically be collected by: scanning a membership card belonging to the consumer scanning a barcode belonging to the consumer You can also specify whether you want only exact matches are not, as shown in the sample code. The User Interface A typical interface might look like this: Note In this example, a consumer's membership card is shown, but a card with a barcode is also usable. The Sample Code In the sample code, a unique identifier for the member is used to obtain information for that member. ObjC Swift Universal Windows Platform SDK coming soon","title":"Customer Manager (ERP)"},{"location":"int-customermanager/#customer-manager-erp","text":"If the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on: the unique identifier for the member the first name the surname The unique identifier for a member can typically be collected by: scanning a membership card belonging to the consumer scanning a barcode belonging to the consumer You can also specify whether you want only exact matches are not, as shown in the sample code.","title":"Customer Manager (ERP)"},{"location":"int-customermanager/#the-user-interface","text":"A typical interface might look like this: Note In this example, a consumer's membership card is shown, but a card with a barcode is also usable.","title":"The User Interface"},{"location":"int-customermanager/#the-sample-code","text":"In the sample code, a unique identifier for the member is used to obtain information for that member.","title":"The Sample Code"},{"location":"int-device-overview/","text":"Device Manger Overview xxx xx","title":"Device Manger Overview"},{"location":"int-device-overview/#device-manger-overview","text":"xxx xx","title":"Device Manger Overview"},{"location":"int-file-manager/","text":"File Manager This manager is responsible for retrieving files from server side, using a FileRecord description model with attributes such as: File unique identifier Merchant reference identifier Category reference identifier Original file name URL Optionally, you can filter the objects by specifying a exact match search, or filters by merchant or categories. Also its possible to get listed all files from a category. When downloading a file, you can either use the id request and download the file directly, or use the URL from the FileRecord. Sample Code In the following code, a unique identifier for the FileRecord is used to obtain information on that member. Universal Windows Platform SDK coming soon","title":"File Manager"},{"location":"int-file-manager/#file-manager","text":"This manager is responsible for retrieving files from server side, using a FileRecord description model with attributes such as: File unique identifier Merchant reference identifier Category reference identifier Original file name URL Optionally, you can filter the objects by specifying a exact match search, or filters by merchant or categories. Also its possible to get listed all files from a category. When downloading a file, you can either use the id request and download the file directly, or use the URL from the FileRecord.","title":"File Manager"},{"location":"int-file-manager/#sample-code","text":"In the following code, a unique identifier for the FileRecord is used to obtain information on that member.","title":"Sample Code"},{"location":"int-initialization/","text":"The SDK Initialization After you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works. Using the Public Test Environment All Wirecard partners who develop with the SDK are provided with: a Wirecard card reader hardware device that can be used for testing purposes a user name and password that can be used to access the Public Test back-end testing environment Note Your user's credentials are usually shipped with expired password so you have to change password after first login. As part of your initialization code (a sample of which is shown below), you must point the SDK to a back-end environment . An environment essentially means a Switch back-end, as described in the mPOS Architecture . Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing. All endpoints are accessible also in Swagger . Note Talk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email pos-solutions@wirecard.com with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you. Tip We often use the term credentials to refer to both the user name and the password. The Wirecard ePOS class The highest-level class in the object hierarchy is: WDePOS class for iOS platform EposSdk class for Android platform The first step in using Wirecard ePOS SDK is to instantiate this object as shown in the sample code below. The Sample Code The sample code demonstrates how to initialize the SDK. Note that the WDEnvironmentPublicTest is passed to setupWithEnvironment method. This points your payment app to the Public Test environment. Substitute your actual user name and password where instead of yourUsername and yourPassword . Also note that if there is a current user and a current cashier, both are returned. The cashier is important if you are using the Cash Management functionality of the SDK because every cash operation requires an associated cashier. ObjC Swift As part of the instantiation, notice in the code below that the Env is set to SWITCH_TEST . This points your payment app to the Public Test Switch back-end. To work properly, valid credentials must be passed so substitute in your actual user name instead of username and use your actual password instead of password in the setCredentials method. Also note that the extensions that you should include will depend on the hardware that you will use with the payment app. The Spire Spm2 terminal is Wirecard's standard card reader device. Datecs is a commonly used printer. Universal Windows Platform SDK coming soon Tip After initialization of SDK, you can continue with User Manager section or go straight to payments in the Sales Manager Overview section.","title":"SDK Initialization"},{"location":"int-initialization/#the-sdk-initialization","text":"After you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.","title":"The SDK Initialization"},{"location":"int-initialization/#using-the-public-test-environment","text":"All Wirecard partners who develop with the SDK are provided with: a Wirecard card reader hardware device that can be used for testing purposes a user name and password that can be used to access the Public Test back-end testing environment Note Your user's credentials are usually shipped with expired password so you have to change password after first login. As part of your initialization code (a sample of which is shown below), you must point the SDK to a back-end environment . An environment essentially means a Switch back-end, as described in the mPOS Architecture . Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing. All endpoints are accessible also in Swagger . Note Talk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email pos-solutions@wirecard.com with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you. Tip We often use the term credentials to refer to both the user name and the password.","title":"Using the Public Test Environment"},{"location":"int-initialization/#the-wirecard-epos-class","text":"The highest-level class in the object hierarchy is: WDePOS class for iOS platform EposSdk class for Android platform The first step in using Wirecard ePOS SDK is to instantiate this object as shown in the sample code below.","title":"The Wirecard ePOS class"},{"location":"int-initialization/#the-sample-code","text":"The sample code demonstrates how to initialize the SDK.","title":"The Sample Code"},{"location":"int-inventory-overview/","text":"Inventory Manager Overview The collection of items that a merchant sells is known as their inventory . An inventory is typically made up of what are referred to as products . Local or ERP Storage of Product Data It is important to understand that inventory data can be stored either: locally on the merchant's device or centrally in the merchant's back-end ERP system This makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage. Local Storage Methods The following chapters describe how to handle locally stored product-related data: Maintain Product Catalogues Maintain Product Categories Maintain Products Product Changes Product Images Changes ERP Storage Methods The following chapters describe how to handle product-related data that is stored in an ERP system: Product Stocks Product Prices (ERP) Note Stock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available. Products, Categories and Catalogues The first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop: In this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right): Tulips Orchids Roses Within the roses category, there are six products available: Mix (colors) Orange Pink Pink/Purple Red Yellow The Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for: product catalogues product categories products","title":"Inventory Manager Overview"},{"location":"int-inventory-overview/#inventory-manager-overview","text":"The collection of items that a merchant sells is known as their inventory . An inventory is typically made up of what are referred to as products .","title":"Inventory Manager Overview"},{"location":"int-inventory-overview/#local-or-erp-storage-of-product-data","text":"It is important to understand that inventory data can be stored either: locally on the merchant's device or centrally in the merchant's back-end ERP system This makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage.","title":"Local or ERP Storage of Product Data"},{"location":"int-inventory-overview/#local-storage-methods","text":"The following chapters describe how to handle locally stored product-related data: Maintain Product Catalogues Maintain Product Categories Maintain Products Product Changes Product Images Changes","title":"Local Storage Methods"},{"location":"int-inventory-overview/#erp-storage-methods","text":"The following chapters describe how to handle product-related data that is stored in an ERP system: Product Stocks Product Prices (ERP) Note Stock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available.","title":"ERP Storage Methods"},{"location":"int-inventory-overview/#products-categories-and-catalogues","text":"The first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop: In this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right): Tulips Orchids Roses Within the roses category, there are six products available: Mix (colors) Orange Pink Pink/Purple Red Yellow The Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for: product catalogues product categories products","title":"Products, Categories and Catalogues"},{"location":"int-maint-prod-catalogues/","text":"Maintain Product Catalogues A product catalogue represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your product categories and, in turn, your products . The User Interface For example, if a store merchant sells flowers, the first page of their catalogue might look like this: The Sample Code Insert GIST here and remove Objective-C below. Note On iOS, the Inventory Manager is implement by inventoryManagers , while on Android it is implemented by inventory () . Tip As mentioned previously, to understand the overall flow of the iOS code look first at the calls to sdk . inventoryManager , at the bottom of each segment of code, because this section of code defines the overall process flow. Caution If you are integrating with SAP Business ByDesign, only query actions are allowed. ObjC Swift Universal Windows Platform SDK coming soon","title":"Maintain Product Catalogues"},{"location":"int-maint-prod-catalogues/#maintain-product-catalogues","text":"A product catalogue represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your product categories and, in turn, your products .","title":"Maintain Product Catalogues"},{"location":"int-maint-prod-catalogues/#the-user-interface","text":"For example, if a store merchant sells flowers, the first page of their catalogue might look like this:","title":"The User Interface"},{"location":"int-maint-prod-catalogues/#the-sample-code","text":"Insert GIST here and remove Objective-C below. Note On iOS, the Inventory Manager is implement by inventoryManagers , while on Android it is implemented by inventory () . Tip As mentioned previously, to understand the overall flow of the iOS code look first at the calls to sdk . inventoryManager , at the bottom of each segment of code, because this section of code defines the overall process flow. Caution If you are integrating with SAP Business ByDesign, only query actions are allowed.","title":"The Sample Code"},{"location":"int-maint-prod-categories/","text":"Maintain Product Categories Groups of related products are known as product categories . Typically, a merchant's product catalogue is divided up into product categories. The User Interface For example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips: The Sample Code Of course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. ObjC Swift Universal Windows Platform SDK coming soon","title":"Maintain Product Categories"},{"location":"int-maint-prod-categories/#maintain-product-categories","text":"Groups of related products are known as product categories . Typically, a merchant's product catalogue is divided up into product categories.","title":"Maintain Product Categories"},{"location":"int-maint-prod-categories/#the-user-interface","text":"For example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips:","title":"The User Interface"},{"location":"int-maint-prod-categories/#the-sample-code","text":"Of course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information.","title":"The Sample Code"},{"location":"int-maint-product/","text":"Maintain Products We have seen that the full collection of items for sale is known as the product catalogue , and then sub-divisions of items within a catalogue are referred to as categories . At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system). The User Interface Using the flower catalogue example, within the rose category a merchant might sell six different types of roses: The Code As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. ObjC Swift Universal Windows Platform SDK coming soon","title":"Maintain Products"},{"location":"int-maint-product/#maintain-products","text":"We have seen that the full collection of items for sale is known as the product catalogue , and then sub-divisions of items within a catalogue are referred to as categories . At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system).","title":"Maintain Products"},{"location":"int-maint-product/#the-user-interface","text":"Using the flower catalogue example, within the rose category a merchant might sell six different types of roses:","title":"The User Interface"},{"location":"int-maint-product/#the-code","text":"As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information.","title":"The Code"},{"location":"int-mfi/","text":"iOS MFI Registration In order to use our supported Bluetooth devices with your app through Wirecard ePOS SDK you need to register in Apple's MFI program. This is done by contacting the hardware vendor you are supporting, providing them with the information about your app. This is done prior to requesting a review on the App Store, as not having the correct PPID codes in the \"App comments\" sections can cause an app rejection from Apple. Warning Each vendor handles the MFI registration on their own, in a proccess which is out of Wirecard's or your control. It is suggested to submit the MFI registration request at least two weeks before submitting your app for the Apple review, as this may affect your release plan. Card Terminals Spire Spm2 For registering into the Spire program, please fill the following form with the information, exactly as they will appear in the App Store: Name of the app App version Bundle Identifier Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . thyron Printers and Cash Drawers Datecs printer DPP-250 For registering into the Datecs program, please send an email or contact their support with the following information, exactly as they will appear in the App Store: Name of the app App version Bundle Identifier Yes/No if this is a totally new app in the Store Yes/No if the app will be used independently from the hardware Describe your application and its key features (You can copy your description from the Ap Store) Informing that your hardware is the printer DPP-250 (protocol com.datecs.printer.escpos) Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . datecs . printer . escpos StarMicronics mPOP, TSP650, SMD2 For registering into the StarMicronics program, please fill the inquiry in its webpage . Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: jp . star - m . starpro Handheld Scanners SocketMobile Series 7 (CHS 7Xi) For registering into the SocketMobile program, please fill the inquiry in the developer section of its webpage . Please note that SocketMobile request a paid registration to gain access to its developer section. Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . socketmobile . chs Warning Once the registration is successful, each vendor must retreive you the PPID number of your app. You must copy the PPID number(s) in your app's comments section, for the Apple reviewer to read. Background Modes It is suggested you include several background modes in your app's plist \"Required background modes\" section. The reason for this is that you don't want a firmware update or a printing getting interrupted if you receive a phone call or the app is dismissed by tapping an external notification. For an optimal behavior, the following background modes are recommended: App downloads content from the network App communicates with an accessory App shares data using CoreBluetooth App communicates using CoreBluetooth","title":"MFI Registration"},{"location":"int-mfi/#ios-mfi-registration","text":"In order to use our supported Bluetooth devices with your app through Wirecard ePOS SDK you need to register in Apple's MFI program. This is done by contacting the hardware vendor you are supporting, providing them with the information about your app. This is done prior to requesting a review on the App Store, as not having the correct PPID codes in the \"App comments\" sections can cause an app rejection from Apple. Warning Each vendor handles the MFI registration on their own, in a proccess which is out of Wirecard's or your control. It is suggested to submit the MFI registration request at least two weeks before submitting your app for the Apple review, as this may affect your release plan.","title":"iOS MFI Registration"},{"location":"int-mfi/#card-terminals","text":"","title":"Card Terminals"},{"location":"int-mfi/#spire-spm2","text":"For registering into the Spire program, please fill the following form with the information, exactly as they will appear in the App Store: Name of the app App version Bundle Identifier Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . thyron","title":"Spire Spm2"},{"location":"int-mfi/#printers-and-cash-drawers","text":"","title":"Printers and Cash Drawers"},{"location":"int-mfi/#datecs-printer-dpp-250","text":"For registering into the Datecs program, please send an email or contact their support with the following information, exactly as they will appear in the App Store: Name of the app App version Bundle Identifier Yes/No if this is a totally new app in the Store Yes/No if the app will be used independently from the hardware Describe your application and its key features (You can copy your description from the Ap Store) Informing that your hardware is the printer DPP-250 (protocol com.datecs.printer.escpos) Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . datecs . printer . escpos","title":"Datecs printer DPP-250"},{"location":"int-mfi/#starmicronics-mpop-tsp650-smd2","text":"For registering into the StarMicronics program, please fill the inquiry in its webpage . Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: jp . star - m . starpro","title":"StarMicronics mPOP, TSP650, SMD2"},{"location":"int-mfi/#handheld-scanners","text":"","title":"Handheld Scanners"},{"location":"int-mfi/#socketmobile-series-7-chs-7xi","text":"For registering into the SocketMobile program, please fill the inquiry in the developer section of its webpage . Please note that SocketMobile request a paid registration to gain access to its developer section. Also, the following protocol must be included in your \"Supported external accessory protocol\" field of your app's info.plist: com . socketmobile . chs Warning Once the registration is successful, each vendor must retreive you the PPID number of your app. You must copy the PPID number(s) in your app's comments section, for the Apple reviewer to read.","title":"SocketMobile Series 7 (CHS 7Xi)"},{"location":"int-mfi/#background-modes","text":"It is suggested you include several background modes in your app's plist \"Required background modes\" section. The reason for this is that you don't want a firmware update or a printing getting interrupted if you receive a phone call or the app is dismissed by tapping an external notification. For an optimal behavior, the following background modes are recommended: App downloads content from the network App communicates with an accessory App shares data using CoreBluetooth App communicates using CoreBluetooth","title":"Background Modes"},{"location":"int-multitender-sale/","text":"Multitender Sales It is possible to settle the Sale by multiple payments. Such Sale is referred to as Multitender Sale. The Multitender Sale is created when the total sale amount is greater than the amount in the payment. Such Sale would then be in the Unconfirmed state - this would indicate that the Sale will be settled by additional payments at the later stage. The Sale can be settled by further payments (i.e. Cash, Card, Alipay, Wechat, etc.). The subsequent payments refer to such Sale as the Original Sale. There is no limit on combination or quantity of payments as long as the Original Sale is still in unconfirmed state, meaning that the sale total amount was not settled yet by the summary of amounts of subsequent payments. Multitender Sale rules: The Sale is Multitender if Sale total amount is greater than the summary of payments amount in the initial Sale Request The Multitender Sale can have one or many payments processed by Reference Sale Request The Sale is Completed if Sale total amount equals the summary of completed payments amount Sale Return : The Sale can be Returned only if it's status is Completed or Partially Returned (to be used in situation where customer Returns goods after some time) Sale Cancel : The Sale can be Cancelled after all of the payments were Reversed . The Sale Reversal is used to reverse each payment on the Original Sale. (to be used in situation when customer wishes to Cancel the Sale or Payment immediately following it's completion) Payment Refund : The Sale in Failed Intervene or Unconfirmed status can have it's payments Refunded in order to deal with uncommon payment issues (to be used when customer wishes to end the Sale in progress, replace completed payment with alternative or resolve Failed payment) Sale Fail : The Unconfirmed Sale can be flagged as Failed if none of it's payment is Completed and merchant wishes to end the Sale (to be used at the time when the Merchant wishes to Close the Sale which cannot be completed in a normal way)","title":"Overview"},{"location":"int-multitender-sale/#multitender-sales","text":"It is possible to settle the Sale by multiple payments. Such Sale is referred to as Multitender Sale. The Multitender Sale is created when the total sale amount is greater than the amount in the payment. Such Sale would then be in the Unconfirmed state - this would indicate that the Sale will be settled by additional payments at the later stage. The Sale can be settled by further payments (i.e. Cash, Card, Alipay, Wechat, etc.). The subsequent payments refer to such Sale as the Original Sale. There is no limit on combination or quantity of payments as long as the Original Sale is still in unconfirmed state, meaning that the sale total amount was not settled yet by the summary of amounts of subsequent payments.","title":"Multitender Sales"},{"location":"int-multitender-sale/#multitender-sale-rules","text":"The Sale is Multitender if Sale total amount is greater than the summary of payments amount in the initial Sale Request The Multitender Sale can have one or many payments processed by Reference Sale Request The Sale is Completed if Sale total amount equals the summary of completed payments amount Sale Return : The Sale can be Returned only if it's status is Completed or Partially Returned (to be used in situation where customer Returns goods after some time) Sale Cancel : The Sale can be Cancelled after all of the payments were Reversed . The Sale Reversal is used to reverse each payment on the Original Sale. (to be used in situation when customer wishes to Cancel the Sale or Payment immediately following it's completion) Payment Refund : The Sale in Failed Intervene or Unconfirmed status can have it's payments Refunded in order to deal with uncommon payment issues (to be used when customer wishes to end the Sale in progress, replace completed payment with alternative or resolve Failed payment) Sale Fail : The Unconfirmed Sale can be flagged as Failed if none of it's payment is Completed and merchant wishes to end the Sale (to be used at the time when the Merchant wishes to Close the Sale which cannot be completed in a normal way)","title":"Multitender Sale rules:"},{"location":"int-ov-a/","text":"Epos SDK Design Principles Wirecard ePOS SDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on RxJava's github or the official ReactiveX webpage . Every call to Wirecard ePOS SDK returns an object which extends the observer pattern. It allows you to: choose between synchronous or asynchronous results manage execution and result threads manage a chain of methods by operators and much more Note Every example in this documentation is using asynchronous approach with lambda expressions. Completable, Single, Observable Most methods return Completable or Single object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK. Observable objects can return object defined by generics multiple times. CompletableParallel and SingleParallel These two objects are special because they contain two separate rx streams: Main stream contains final result of request and Second stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method. Here is a recommended usage: import com.jakewharton.rxrelay2.BehaviorRelay ; import com.jakewharton.rxrelay2.Relay ; import io.reactivex.android.schedulers.AndroidSchedulers ; Relay < Event > eventObservable = BehaviorRelay . create (); epos . methodReturnsSingleParallel () . subscribeParallel ( eventObservable ) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( onSuccess -> { //do something on success }, onError -> { //show error } ); eventObservable . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( event -> { //do something on event }); Synchronous vs Asynchronous You can choose which principle suits your algorithms best for every method call. Synchronous Methods A synchronous response can be achieved by calling one of these methods: //completable epos . methodReturnsCompletable (). blockingAwait () //returns void or rethrows any exception emitted epos . methodReturnsCompletable (). blockingGet () //returns null or the emitted exception if any //single epos . methodReturnsSingle (). blockingGet () //returns success object or rethrows any exception emitted Asynchronous Methods An asynchronous response can be achieved by calling the subscribe method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came. //completable epos . methodReturnsCompletable (). subscribe () //returns disposable, ignores all responses epos . methodReturnsCompletable (). subscribe ( CompletableObserver s ) //returns disposable, all responses came in given CompletableObserver epos . methodReturnsCompletable (). subscribe ( Action onComplete , Consumer <? super Throwable > onError ) //returns disposable, successful responses came in onComplete Action and error in onError epos . methodReturnsCompletable (). subscribe ( Action onComplete ) //returns disposable, successful response came in given Action, error is ignored //single epos . methodReturnsSingle (). subscribe () //returns disposable, ignores all responses epos . methodReturnsSingle (). subscribe ( BiConsumer <? super T , ? super Throwable > onCallback ) //returns disposable, all responses came in given composite BiConsumer callback epos . methodReturnsSingle (). subscribe ( Consumer <? super T > onSuccess ) //returns disposable, successful response came in given Consumer callback, error is ignored epos . methodReturnsSingle (). subscribe ( Consumer <? super T > onSuccess , Consumer <? super Throwable > onError ) //returns disposable, successful or error response came in given onSuccess or onError Consumer epos . methodReturnsSingle (). subscribe ( SingleObserver <? super T > subscriber ) //returns disposable, all responses came in given SingleObserver Threads There is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to schedulers and RxAndroid . You can change the result thread by calling observeOn method, as shown: epos . anyObservableMethod () . observeOn ( AndroidSchedulers . mainThread ()) . subscribe (...); Operators Operators are a very powerful RxJava mechanism. See this page for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the andThen and flatMap operators. epos . methodReturnsCompletable () . andThen ( epos . methodReturnsAnotherCompletable ()) . andThen ( epos . methodReturnsSingle ()) . flatMap ( previousResult -> epos . methodReturnsAnotherSingle ()) . subscribe (...); Is there a non Rx way? If you're not familiar with RxJava and Rx principles, you can use SDK with \"listeners\" as you're used to. Just call subscribe method to every SDK method and put listeners as parameters. //completable eposSDK . methodReturnsCompletable (). subscribe ( new Action () { @Override public void run () throws Exception { ... } }, new Consumer < Throwable >() { @Override public void accept ( Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsCompletable (). subscribe ( new CompletableObserver () { @Override public void onSubscribe ( Disposable d ) { ... } @Override public void onComplete () { ... } @Override public void onError ( Throwable e ) { ... } }); //single eposSDK . methodReturnsSingle (). subscribe ( new BiConsumer < Response , Throwable >() { @Override public void accept ( Response response , Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsSingle (). subscribe ( new Consumer < Response >() { @Override public void accept ( Response response ) throws Exception { ... } }, new Consumer < Throwable >() { @Override public void accept ( Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsSingle (). subscribe ( new SingleObserver < Response >() { @Override public void onSubscribe ( Disposable disposable ) { ... } @Override public void onSuccess ( Response response ) { ... } ... @Override public void onError ( Throwable e ) { } }); Parameter \"With\" \"With\" method parameter gives you advanced control over processes started by SDK methods. You can run backend calls on desired thread/scheduler. Requests, by default, are running on thread that is related to specific manager (e.g SaleManager methods runs on \"SalesThread\" by default). This can be changed by using \"scheduler()\" method of an \"With\" interface. When you start backend request the response object can contain huge amount of information stored in the response object fields and some of them may not be useful for your application. To avoid receiving all response object fields the \"includeResponseFields()\" and the \"excludeResponseFields()\" methods can help you to reduce the amount of response object fields. If you use \"includeResponseFields()\" method the response object will contain only those fields which you have added to this method as parameters (e.g. you will receive only: \"transaction\", \"id\", \"type\", \"state\" response object fields instead of receiving others that you don't even need for your application). Similar usage is for \"excludeResponseFields()\" method where you will receive the response object that will not contain those response object fields which you have included in this method. There is possibility to add optional parameters to backend request. For example, if you are using backend with multiple users but you want to build request, where you will receive only one specific user with name \"user26\" you can use \"param()\", \"params()\" methods. Backend request for users has optional parameter \"username\". Using couple param(\"username\", \"user26\")in request for users you will receive desired user object from backend. Pagination of request object can be achieved by using \"page()\" and \"size()\" methods. Imagine you have backend with 1000 users. You want to get only first 20 users. You need to use \"page(1)\" and \"size(20)\" and you will receive first 20 users. If you want to get 20 more users you will use \"page(2)\" and \"size(20)\". Response results can be sorted also. There are \"ASC\" and \"DESC\" enumerators. \"ASC\" means ascending and \"DESC\" means descending order. There is possibility to combine multiple order params. To sort your backend response object users by response object field \"name\" from A to Z you will need to use \"sort(\"username\", WithPagination.Order.ASC)\". Imagine, at the same time you want to sort the same backend response object users by response object field \"age\" but from highest to lowest. You will use \"sort(\"age\", WithPagination.Order.DESC)\". You have already applied two sorts in one backend request. The result object will contain users sorted by \"name\" alphabetically by fist and by \"age\" from highest to lowest as a second. There are three types of \"With\" parameters where you can use apply above mentioned params: WithBase WithFields WithPagination epos . anyObservableMethod ( With with ) . observeOn (...) . subscribe (...); WithBase Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. WithBase withBase = With . base (). scheduler ( Schedulers . io ()); WithFields Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. includeResponseFields(String[] includeResponseFields) Fields that will be retrieved from original response object so the response object will contain only \"includeResponseFields\". excludeResponseFields(String[] excludeResponseFields) Fields that will be omitted from original response object (original response object minus excludeResponseFields). param(String name, String value) Optional request parameter that will be included in backend request. params(Pair values) Optional request parameters that will be included in backend request. WithFields withFields = With . fields () . scheduler ( Schedulers . newThread ()) . includeResponseFields ( new String []{ \"id\" , \"type\" , \"status\" , \"currency\" }) . param ( \"groupBy\" , \"STATUS\" ) . param ( \"countryCode\" , \"BTN\" ) . params ( new Pair < String , String >( \"statuses\" , \"COMPLETED\" ), new Pair < String , String >( \"statuses\" , \"CANCELED\" )); WithPagination Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. includeResponseFields(String[] includeResponseFields) Fields that will be retrieved from original response object so the response object will contain only \"includeResponseFields\". excludeResponseFields(String[] excludeResponseFields) Fields that will be omitted from original response object (original response object minus excludeResponseFields). param(String name, String value) Optional request parameter that will be included in backend request. params(Pair values) Optional request parameters that will be included in backend request. page(Int page) Pagination of results can be achieved by adding \"page\" and \"size\" into backend request parameters. size(Int size) maximum 1000 Number of response results. sort(String property, WithPagination.Order order) Response objects will be sorted according to \"property\" that will be added into backend request (there are two options: ASC, DESC). WithPagination withPagination = With . pagination () . scheduler ( Schedulers . newThread ()) . includeResponseFields ( new String []{ \"id\" , \"name\" , \"openTime\" }) . param ( \"groupBy\" , \"STATUS\" ) // optional request parameter . page ( 0 ) . size ( 20 ) . sort ( \"openTime\" , WithPagination . Order . ASC )","title":"Design Principles"},{"location":"int-ov-a/#epos-sdk-design-principles","text":"Wirecard ePOS SDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on RxJava's github or the official ReactiveX webpage . Every call to Wirecard ePOS SDK returns an object which extends the observer pattern. It allows you to: choose between synchronous or asynchronous results manage execution and result threads manage a chain of methods by operators and much more Note Every example in this documentation is using asynchronous approach with lambda expressions.","title":"Epos SDK Design Principles"},{"location":"int-ov-a/#completable-single-observable","text":"Most methods return Completable or Single object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK. Observable objects can return object defined by generics multiple times.","title":"Completable, Single, Observable"},{"location":"int-ov-a/#completableparallel-and-singleparallel","text":"These two objects are special because they contain two separate rx streams: Main stream contains final result of request and Second stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method. Here is a recommended usage: import com.jakewharton.rxrelay2.BehaviorRelay ; import com.jakewharton.rxrelay2.Relay ; import io.reactivex.android.schedulers.AndroidSchedulers ; Relay < Event > eventObservable = BehaviorRelay . create (); epos . methodReturnsSingleParallel () . subscribeParallel ( eventObservable ) . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( onSuccess -> { //do something on success }, onError -> { //show error } ); eventObservable . observeOn ( AndroidSchedulers . mainThread ()) . subscribe ( event -> { //do something on event });","title":"CompletableParallel and SingleParallel"},{"location":"int-ov-a/#synchronous-vs-asynchronous","text":"You can choose which principle suits your algorithms best for every method call.","title":"Synchronous vs Asynchronous"},{"location":"int-ov-a/#synchronous-methods","text":"A synchronous response can be achieved by calling one of these methods: //completable epos . methodReturnsCompletable (). blockingAwait () //returns void or rethrows any exception emitted epos . methodReturnsCompletable (). blockingGet () //returns null or the emitted exception if any //single epos . methodReturnsSingle (). blockingGet () //returns success object or rethrows any exception emitted","title":"Synchronous Methods"},{"location":"int-ov-a/#asynchronous-methods","text":"An asynchronous response can be achieved by calling the subscribe method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came. //completable epos . methodReturnsCompletable (). subscribe () //returns disposable, ignores all responses epos . methodReturnsCompletable (). subscribe ( CompletableObserver s ) //returns disposable, all responses came in given CompletableObserver epos . methodReturnsCompletable (). subscribe ( Action onComplete , Consumer <? super Throwable > onError ) //returns disposable, successful responses came in onComplete Action and error in onError epos . methodReturnsCompletable (). subscribe ( Action onComplete ) //returns disposable, successful response came in given Action, error is ignored //single epos . methodReturnsSingle (). subscribe () //returns disposable, ignores all responses epos . methodReturnsSingle (). subscribe ( BiConsumer <? super T , ? super Throwable > onCallback ) //returns disposable, all responses came in given composite BiConsumer callback epos . methodReturnsSingle (). subscribe ( Consumer <? super T > onSuccess ) //returns disposable, successful response came in given Consumer callback, error is ignored epos . methodReturnsSingle (). subscribe ( Consumer <? super T > onSuccess , Consumer <? super Throwable > onError ) //returns disposable, successful or error response came in given onSuccess or onError Consumer epos . methodReturnsSingle (). subscribe ( SingleObserver <? super T > subscriber ) //returns disposable, all responses came in given SingleObserver","title":"Asynchronous Methods"},{"location":"int-ov-a/#threads","text":"There is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to schedulers and RxAndroid . You can change the result thread by calling observeOn method, as shown: epos . anyObservableMethod () . observeOn ( AndroidSchedulers . mainThread ()) . subscribe (...);","title":"Threads"},{"location":"int-ov-a/#operators","text":"Operators are a very powerful RxJava mechanism. See this page for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the andThen and flatMap operators. epos . methodReturnsCompletable () . andThen ( epos . methodReturnsAnotherCompletable ()) . andThen ( epos . methodReturnsSingle ()) . flatMap ( previousResult -> epos . methodReturnsAnotherSingle ()) . subscribe (...);","title":"Operators"},{"location":"int-ov-a/#is-there-a-non-rx-way","text":"If you're not familiar with RxJava and Rx principles, you can use SDK with \"listeners\" as you're used to. Just call subscribe method to every SDK method and put listeners as parameters. //completable eposSDK . methodReturnsCompletable (). subscribe ( new Action () { @Override public void run () throws Exception { ... } }, new Consumer < Throwable >() { @Override public void accept ( Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsCompletable (). subscribe ( new CompletableObserver () { @Override public void onSubscribe ( Disposable d ) { ... } @Override public void onComplete () { ... } @Override public void onError ( Throwable e ) { ... } }); //single eposSDK . methodReturnsSingle (). subscribe ( new BiConsumer < Response , Throwable >() { @Override public void accept ( Response response , Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsSingle (). subscribe ( new Consumer < Response >() { @Override public void accept ( Response response ) throws Exception { ... } }, new Consumer < Throwable >() { @Override public void accept ( Throwable throwable ) throws Exception { ... } }); eposSDK . methodReturnsSingle (). subscribe ( new SingleObserver < Response >() { @Override public void onSubscribe ( Disposable disposable ) { ... } @Override public void onSuccess ( Response response ) { ... } ... @Override public void onError ( Throwable e ) { } });","title":"Is there a non Rx way?"},{"location":"int-ov-a/#parameter-with","text":"\"With\" method parameter gives you advanced control over processes started by SDK methods. You can run backend calls on desired thread/scheduler. Requests, by default, are running on thread that is related to specific manager (e.g SaleManager methods runs on \"SalesThread\" by default). This can be changed by using \"scheduler()\" method of an \"With\" interface. When you start backend request the response object can contain huge amount of information stored in the response object fields and some of them may not be useful for your application. To avoid receiving all response object fields the \"includeResponseFields()\" and the \"excludeResponseFields()\" methods can help you to reduce the amount of response object fields. If you use \"includeResponseFields()\" method the response object will contain only those fields which you have added to this method as parameters (e.g. you will receive only: \"transaction\", \"id\", \"type\", \"state\" response object fields instead of receiving others that you don't even need for your application). Similar usage is for \"excludeResponseFields()\" method where you will receive the response object that will not contain those response object fields which you have included in this method. There is possibility to add optional parameters to backend request. For example, if you are using backend with multiple users but you want to build request, where you will receive only one specific user with name \"user26\" you can use \"param()\", \"params()\" methods. Backend request for users has optional parameter \"username\". Using couple param(\"username\", \"user26\")in request for users you will receive desired user object from backend. Pagination of request object can be achieved by using \"page()\" and \"size()\" methods. Imagine you have backend with 1000 users. You want to get only first 20 users. You need to use \"page(1)\" and \"size(20)\" and you will receive first 20 users. If you want to get 20 more users you will use \"page(2)\" and \"size(20)\". Response results can be sorted also. There are \"ASC\" and \"DESC\" enumerators. \"ASC\" means ascending and \"DESC\" means descending order. There is possibility to combine multiple order params. To sort your backend response object users by response object field \"name\" from A to Z you will need to use \"sort(\"username\", WithPagination.Order.ASC)\". Imagine, at the same time you want to sort the same backend response object users by response object field \"age\" but from highest to lowest. You will use \"sort(\"age\", WithPagination.Order.DESC)\". You have already applied two sorts in one backend request. The result object will contain users sorted by \"name\" alphabetically by fist and by \"age\" from highest to lowest as a second. There are three types of \"With\" parameters where you can use apply above mentioned params: WithBase WithFields WithPagination epos . anyObservableMethod ( With with ) . observeOn (...) . subscribe (...);","title":"Parameter \"With\""},{"location":"int-ov-a/#withbase","text":"Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. WithBase withBase = With . base (). scheduler ( Schedulers . io ());","title":"WithBase"},{"location":"int-ov-a/#withfields","text":"Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. includeResponseFields(String[] includeResponseFields) Fields that will be retrieved from original response object so the response object will contain only \"includeResponseFields\". excludeResponseFields(String[] excludeResponseFields) Fields that will be omitted from original response object (original response object minus excludeResponseFields). param(String name, String value) Optional request parameter that will be included in backend request. params(Pair values) Optional request parameters that will be included in backend request. WithFields withFields = With . fields () . scheduler ( Schedulers . newThread ()) . includeResponseFields ( new String []{ \"id\" , \"type\" , \"status\" , \"currency\" }) . param ( \"groupBy\" , \"STATUS\" ) . param ( \"countryCode\" , \"BTN\" ) . params ( new Pair < String , String >( \"statuses\" , \"COMPLETED\" ), new Pair < String , String >( \"statuses\" , \"CANCELED\" ));","title":"WithFields"},{"location":"int-ov-a/#withpagination","text":"Methods: scheduler(Scheduler scheduler) You can set desired Scheduler upon which the request will run. includeResponseFields(String[] includeResponseFields) Fields that will be retrieved from original response object so the response object will contain only \"includeResponseFields\". excludeResponseFields(String[] excludeResponseFields) Fields that will be omitted from original response object (original response object minus excludeResponseFields). param(String name, String value) Optional request parameter that will be included in backend request. params(Pair values) Optional request parameters that will be included in backend request. page(Int page) Pagination of results can be achieved by adding \"page\" and \"size\" into backend request parameters. size(Int size) maximum 1000 Number of response results. sort(String property, WithPagination.Order order) Response objects will be sorted according to \"property\" that will be added into backend request (there are two options: ASC, DESC). WithPagination withPagination = With . pagination () . scheduler ( Schedulers . newThread ()) . includeResponseFields ( new String []{ \"id\" , \"name\" , \"openTime\" }) . param ( \"groupBy\" , \"STATUS\" ) // optional request parameter . page ( 0 ) . size ( 20 ) . sort ( \"openTime\" , WithPagination . Order . ASC )","title":"WithPagination"},{"location":"int-payment-refund/","text":"Sale Refund It is possible to refund particular payment within the Multitender Sale. Info E.g. It can be used for cases where the customer changes their mind immediatelly after the payment and Sale Reversal is no longer possible (Payment already sent for settlement to respective network) or if the customer wishes to replace completed payment method with alternative one. The execution of payment refund is bound to Sale being in the Unconfirmed or Failed Intervene states. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Refund Sale"},{"location":"int-payment-refund/#sale-refund","text":"It is possible to refund particular payment within the Multitender Sale. Info E.g. It can be used for cases where the customer changes their mind immediatelly after the payment and Sale Reversal is no longer possible (Payment already sent for settlement to respective network) or if the customer wishes to replace completed payment method with alternative one. The execution of payment refund is bound to Sale being in the Unconfirmed or Failed Intervene states.","title":"Sale Refund"},{"location":"int-payment-refund/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-payment-reverse/","text":"Sale Reverse It is possible to reverse particular payment within the Multitender Sale. E.g. It can be used for cases where the customer changes their mind immediatelly after the payment. The execution of sale reversal is usually time limited - available only in the short time span after the payment processing till the time it was sent to settlement by the respective network. For Merchants with the Cash register functionality enabled the sale reversal is bound to the Open Cash Register Shift in which the Original Sale was initiated. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Reverse Sale"},{"location":"int-payment-reverse/#sale-reverse","text":"It is possible to reverse particular payment within the Multitender Sale. E.g. It can be used for cases where the customer changes their mind immediatelly after the payment. The execution of sale reversal is usually time limited - available only in the short time span after the payment processing till the time it was sent to settlement by the respective network. For Merchants with the Cash register functionality enabled the sale reversal is bound to the Open Cash Register Shift in which the Original Sale was initiated.","title":"Sale Reverse"},{"location":"int-payment-reverse/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-payment/","text":"Sale Processing Alright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Sale request configuration object's sale attribute. So now we can get down to the heavy duty work of processing the payment. The User Interface From the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI. If the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this: The iOS Object Model The payment flow for purchase sales requests is largely handled by the six methods of the Sales Manager component shown below on the right side of the diagram. The completed sale is delivered in the Sale Response object: as a sale object if the processing was successful as an error object if the processing was not successful Tip In the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six Sales Manager methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow. The Android Object Model The previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this: The Sample Code ObjC Swift The code demonstrates very simplistic usage of each unit of behaviour Universal Windows Platform SDK coming soon","title":"Sale Processing"},{"location":"int-payment/#sale-processing","text":"Alright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Sale request configuration object's sale attribute. So now we can get down to the heavy duty work of processing the payment.","title":"Sale Processing"},{"location":"int-payment/#the-user-interface","text":"From the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI. If the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this:","title":"The User Interface"},{"location":"int-payment/#the-ios-object-model","text":"The payment flow for purchase sales requests is largely handled by the six methods of the Sales Manager component shown below on the right side of the diagram. The completed sale is delivered in the Sale Response object: as a sale object if the processing was successful as an error object if the processing was not successful Tip In the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six Sales Manager methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow.","title":"The iOS Object Model"},{"location":"int-payment/#the-android-object-model","text":"The previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this:","title":"The Android Object Model"},{"location":"int-payment/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-print-paperstatus/","text":"Check Paper Status This sample code illustrates how to report on the paper status of an active mPOP printer. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Check Paper Status"},{"location":"int-print-paperstatus/#check-paper-status","text":"This sample code illustrates how to report on the paper status of an active mPOP printer.","title":"Check Paper Status"},{"location":"int-print-paperstatus/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-print-receipt/","text":"Print Receipt The previous chapter examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including: reporting on the status of a print job reporting on the final status of a print job Wirecard ePOS Receipt and Image As the code comments indicate, the Wirecard ePOS Receipt object tends to print quicker than the Image (which is a bitmap) so the sample code shown here prints an WDePosReceipt object. The next chapter demonstrates how to handle printing of a Image. The input for a receipt can either be: a Sale Response object from the payment method of Sales Manager a Query object from the Sales Manager The sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt. A single receipt, or a collection of receipts, can be printed. The Sample Code As is the case with much of the sample code in GIST, we start with the first printer object that is found. ObjC Swift Universal Windows Platform SDK coming soon","title":"Print Receipt"},{"location":"int-print-receipt/#print-receipt","text":"The previous chapter examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including: reporting on the status of a print job reporting on the final status of a print job","title":"Print Receipt"},{"location":"int-print-receipt/#wirecard-epos-receipt-and-image","text":"As the code comments indicate, the Wirecard ePOS Receipt object tends to print quicker than the Image (which is a bitmap) so the sample code shown here prints an WDePosReceipt object. The next chapter demonstrates how to handle printing of a Image. The input for a receipt can either be: a Sale Response object from the payment method of Sales Manager a Query object from the Sales Manager The sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt. A single receipt, or a collection of receipts, can be printed.","title":"Wirecard ePOS Receipt and Image"},{"location":"int-print-receipt/#the-sample-code","text":"As is the case with much of the sample code in GIST, we start with the first printer object that is found.","title":"The Sample Code"},{"location":"int-print/","text":"Print Image This chapter, like the previous one , describes how to print a receipt, but here we use the Image object. A single receipt, collection of receipts or any other image, can be printed. The Sample Code The sample code demonstrates how to print an image. The code is largely the same as the print of receipt, except that the format in the showReturns object of Sale Response now uses: AcceptReceiptFormatUIImage . ObjC Swift Universal Windows Platform SDK coming soon","title":"Print Image"},{"location":"int-print/#print-image","text":"This chapter, like the previous one , describes how to print a receipt, but here we use the Image object. A single receipt, collection of receipts or any other image, can be printed.","title":"Print Image"},{"location":"int-print/#the-sample-code","text":"The sample code demonstrates how to print an image.","title":"The Sample Code"},{"location":"int-printer-discovery/","text":"Printer Discovery The discover devices functionality of Printer Manager: discovers any connected Datecs DPP-250 handheld printers registers to receive device status updates registers to receive action result updates prepares Printer Manager for the reception of the data after a barcode is scanned So, related to the last point above, the main task for you is to implement a method that handles the dataReceived . The User Interface A typical user interface might look like this: The Sample Code For simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer. Warning In the iOS code, the base class needs to conform to WDPrinting . ObjC Swift Universal Windows Platform SDK coming soon","title":"Printer Discovery"},{"location":"int-printer-discovery/#printer-discovery","text":"The discover devices functionality of Printer Manager: discovers any connected Datecs DPP-250 handheld printers registers to receive device status updates registers to receive action result updates prepares Printer Manager for the reception of the data after a barcode is scanned So, related to the last point above, the main task for you is to implement a method that handles the dataReceived .","title":"Printer Discovery"},{"location":"int-printer-discovery/#the-user-interface","text":"A typical user interface might look like this:","title":"The User Interface"},{"location":"int-printer-discovery/#the-sample-code","text":"For simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer. Warning In the iOS code, the base class needs to conform to WDPrinting .","title":"The Sample Code"},{"location":"int-printer-overview/","text":"Printer Manager Overview This section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to: discover printers print a single receipt or a collection of receipts check the paper status of a printer","title":"Printer Manager Overview"},{"location":"int-printer-overview/#printer-manager-overview","text":"This section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to: discover printers print a single receipt or a collection of receipts check the paper status of a printer","title":"Printer Manager Overview"},{"location":"int-prod-changes-images/","text":"Product Image Changes Each product has an associated image. In this chapter, the sample code illustrates how to retrieve either: all changed product images or an individual product image that has been changed To retrieve individual product images, you need to know the unique product identifier. The Code If you want to select a single product image change, then you require the unique identifier for that image and you pass it in the productId on iOS, or the productExternalId on Android. As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. Note On iOS, the catalogue is identified by productCatalogueId , whereas on Android, it is identified by catalogueId . ObjC Swift Universal Windows Platform SDK coming soon","title":"Product Images Changes"},{"location":"int-prod-changes-images/#product-image-changes","text":"Each product has an associated image. In this chapter, the sample code illustrates how to retrieve either: all changed product images or an individual product image that has been changed To retrieve individual product images, you need to know the unique product identifier.","title":"Product Image Changes"},{"location":"int-prod-changes-images/#the-code","text":"If you want to select a single product image change, then you require the unique identifier for that image and you pass it in the productId on iOS, or the productExternalId on Android. As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. Note On iOS, the catalogue is identified by productCatalogueId , whereas on Android, it is identified by catalogueId .","title":"The Code"},{"location":"int-prod-changes/","text":"Product Changes If the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes: a list of products that have changed since the last synchronization date a list of deleted products (according to their identifier) The Code As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. Note On iOS, the catalogue is identified by productCatalogueId , whereas on Android, it is identified by catalogueId . ObjC Swift Universal Windows Platform SDK coming soon","title":"Product Changes"},{"location":"int-prod-changes/#product-changes","text":"If the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes: a list of products that have changed since the last synchronization date a list of deleted products (according to their identifier)","title":"Product Changes"},{"location":"int-prod-changes/#the-code","text":"As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See Maintain Product Catalogues for complete information. Note On iOS, the catalogue is identified by productCatalogueId , whereas on Android, it is identified by catalogueId .","title":"The Code"},{"location":"int-product-prices-erp/","text":"Product Prices (ERP) If the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed. The Sample Code The unique identifier for both the member and each Product is required. You can validate the unique identifier for the member using the Customer Manager, as described in Customer Manager . ObjC Swift Universal Windows Platform SDK coming soon","title":"Product Prices (ERP)"},{"location":"int-product-prices-erp/#product-prices-erp","text":"If the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed.","title":"Product Prices (ERP)"},{"location":"int-product-prices-erp/#the-sample-code","text":"The unique identifier for both the member and each Product is required. You can validate the unique identifier for the member using the Customer Manager, as described in Customer Manager .","title":"The Sample Code"},{"location":"int-product-stocks/","text":"Product Stocks The Inventory Manager also offers the ability to keep track of product stocks in each and every shop of a merchant. This is done through a maintenance function that updates the total amount of products in a specific location, and also allows the creation of notification thresholds, in case you want to receive an email warning you when a product stock is running lower. The requirements for modifying/maintaining the stocks of one or several products are: The id of the shop the product is located. You need to create and retrieve the shop data in advance through the User Manager . The stock amount you want to update the product with. This amount is the new current total. Optionally, you can set both a threshold limit to receive notifications (ie: setting 5 will send you a notification when the product stock is equal or lower than 5), and a note to keep track on the update reason (ie \"New shipment received\"). The product id to be updated and the catalogue id it belongs to. See Maintain Product Catalogues for complete information. Note that you can maintain the stock for several shops with a single call. Tip Support for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product. You can retrieve as well the stock of a single product by using the product stock function. Note that this will respond with the stock of a single product in all the shops, and for having stock of more than one product you are required to do separate queries. Note If the merchant chooses to have ERP integration, the product stock feature becomes read only, and no maintenance/update is possible through the ePOS SDK. See the Inventory Manager Overview for more information about storing product data in an ERP versus storing product data locally. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Product Stocks"},{"location":"int-product-stocks/#product-stocks","text":"The Inventory Manager also offers the ability to keep track of product stocks in each and every shop of a merchant. This is done through a maintenance function that updates the total amount of products in a specific location, and also allows the creation of notification thresholds, in case you want to receive an email warning you when a product stock is running lower. The requirements for modifying/maintaining the stocks of one or several products are: The id of the shop the product is located. You need to create and retrieve the shop data in advance through the User Manager . The stock amount you want to update the product with. This amount is the new current total. Optionally, you can set both a threshold limit to receive notifications (ie: setting 5 will send you a notification when the product stock is equal or lower than 5), and a note to keep track on the update reason (ie \"New shipment received\"). The product id to be updated and the catalogue id it belongs to. See Maintain Product Catalogues for complete information. Note that you can maintain the stock for several shops with a single call. Tip Support for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product. You can retrieve as well the stock of a single product by using the product stock function. Note that this will respond with the stock of a single product in all the shops, and for having stock of more than one product you are required to do separate queries. Note If the merchant chooses to have ERP integration, the product stock feature becomes read only, and no maintenance/update is possible through the ePOS SDK. See the Inventory Manager Overview for more information about storing product data in an ERP versus storing product data locally.","title":"Product Stocks"},{"location":"int-product-stocks/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-sale-fail/","text":"Sale Fail A Sale can be flagged by Merchant as Failed for the sole purpose of closing it and perhaps producing the receipt that shows the failures of all underlying payments. This can be used for the cases where all attempts to successfuly process payments fails and merchant reversed, refunded or rejected all payments conforming this Sale. This operation is available only for the Sale in the Unconfirmed status. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Fail Sale"},{"location":"int-sale-fail/#sale-fail","text":"A Sale can be flagged by Merchant as Failed for the sole purpose of closing it and perhaps producing the receipt that shows the failures of all underlying payments. This can be used for the cases where all attempts to successfuly process payments fails and merchant reversed, refunded or rejected all payments conforming this Sale. This operation is available only for the Sale in the Unconfirmed status.","title":"Sale Fail"},{"location":"int-sale-fail/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-sale-model/","text":"Sales Request Object Model","title":"Sales Request Object Model"},{"location":"int-sale-model/#sales-request-object-model","text":"","title":"Sales Request Object Model"},{"location":"int-sale-overview/","text":"Sales Manager Overview The objective of every merchant is to complete sales and make a profit, so the Sale Managers component is probably the most important API in the Wirecard ePOS SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a cash sale request . The chapter after that describes how to handle a card sale request . The Sale can be settled by using multiple payments as discussed in Multitender Sale . A Sample User Interface To help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request. Minimum Information for a Sales Request Most importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object: total amount of sale currency inclusive / exclusive tax indicator payment method (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being: Card (i.e. Visa and Mastercard) Cash Alipay WeChat Pay sale items are conditional. Required if you have enabled cash management, optional otherwise. For each individual item, you need to provide at least: Type of item Price Quantity Tax to be charged Total amount of item (basically price multiplied by quantity with respect to discount and tax) id of cash register is also conditional. Required if you have enabled cash management, optional otherwise. rest of parameters are optional Note For simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.","title":"Overview"},{"location":"int-sale-overview/#sales-manager-overview","text":"The objective of every merchant is to complete sales and make a profit, so the Sale Managers component is probably the most important API in the Wirecard ePOS SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a cash sale request . The chapter after that describes how to handle a card sale request . The Sale can be settled by using multiple payments as discussed in Multitender Sale .","title":"Sales Manager Overview"},{"location":"int-sale-overview/#a-sample-user-interface","text":"To help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request.","title":"A Sample User Interface"},{"location":"int-sale-overview/#minimum-information-for-a-sales-request","text":"Most importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object: total amount of sale currency inclusive / exclusive tax indicator payment method (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being: Card (i.e. Visa and Mastercard) Cash Alipay WeChat Pay sale items are conditional. Required if you have enabled cash management, optional otherwise. For each individual item, you need to provide at least: Type of item Price Quantity Tax to be charged Total amount of item (basically price multiplied by quantity with respect to discount and tax) id of cash register is also conditional. Required if you have enabled cash management, optional otherwise. rest of parameters are optional Note For simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.","title":"Minimum Information for a Sales Request"},{"location":"int-salereceipt/","text":"Sale Receipt In addition to the receipt generation and printing (see Printer Manager section ), Wirecard ePOS SDK offers the option of sending the Sale receipt, filled with your sale data, to the chosen destination (currently, only e-mail method is supported, but we plan on including SMS in the future). This is done based on the ID of already finalized sale, the state of that sale and the method you chose for sending. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Sale Receipt"},{"location":"int-salereceipt/#sale-receipt","text":"In addition to the receipt generation and printing (see Printer Manager section ), Wirecard ePOS SDK offers the option of sending the Sale receipt, filled with your sale data, to the chosen destination (currently, only e-mail method is supported, but we plan on including SMS in the future). This is done based on the ID of already finalized sale, the state of that sale and the method you chose for sending.","title":"Sale Receipt"},{"location":"int-salereceipt/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salerequest-alternativePayment/","text":"Sale Request - Alternative Payment Currently we do support two types of Alternative Payments: Alipay WeChat Quickpay The User Interface The UI presents Alipay and WeChat as an alternative payment methods. At the time of payment it is necessary to select which payment method to use for settling the sale. After tapping on one of the alternative payment method it is necessary to present UI for capturing the QRCode - Alipay or WeChat as preferred by the customer. Note It is your responsibility to capture the QRCode and use the resulting data when adding the Alipay or WeChat payment into the Sale. Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale. The iOS Object Model The diagram below shows the key objects involved in the processing of a Alipay/WeChat sale request. Note The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is WDSaleRequest but that is tough to read, so we display it as Sale Request instead. We do the same with method names. For example, the method add Alipay payment , shown above, is implemented in Objective-C and Swift as addAlipayPayment . The similar is true for add WeChat payment . Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it. The iOS Process Flow The process flow in the code is as follows: Instantiate a Sale Request object. The type attribute of Sale Request defines the type of sale request, most commonly a Purchase . Add details to the Sale Request object with the add sale item method. For Alipay transactions, use the add alipay payment method. For WeChat transactions, use the add wechat payment method. Pass the full details of the Sale Request to the Payment Config object in the sale property. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter. The Android Object Model The Sales Manager component in Android is implemented as the sales () method of the EposSDK class. The Sales Builder then does most of the work as shown: The Android Process Flow The process flow is: Create an items object with a Sale Item Type of Purchase . Use Sale Builder to create the sale request. Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with pay(Sales Builder) . The add alipay payment method indicates that the full amount of the sale is paid with Alipay (i.e., 10 \u20ac). The add wechat payment method indicates that the full amount of the sale is paid with WeChat (i.e., 10 \u20ac). * A saleId string is returned which has the complete sale object. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter. The Sample Code Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI. Warning Wechat and Alipay payments must include a sale note (only mandatory for these alternative payment methods) that can be used for storing details about the sale. While the content of this note is not validated by Wirecard (as soon as it is not empty), both Wechat and Alipay demands a brief description of the sale (ie. nature of it, or products sold) for regulatory reasons. ObjC Swift Universal Windows Platform SDK coming soon","title":"Alternative Methods"},{"location":"int-salerequest-alternativePayment/#sale-request-alternative-payment","text":"Currently we do support two types of Alternative Payments: Alipay WeChat Quickpay","title":"Sale Request - Alternative Payment"},{"location":"int-salerequest-alternativePayment/#the-user-interface","text":"The UI presents Alipay and WeChat as an alternative payment methods. At the time of payment it is necessary to select which payment method to use for settling the sale. After tapping on one of the alternative payment method it is necessary to present UI for capturing the QRCode - Alipay or WeChat as preferred by the customer. Note It is your responsibility to capture the QRCode and use the resulting data when adding the Alipay or WeChat payment into the Sale. Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.","title":"The User Interface"},{"location":"int-salerequest-alternativePayment/#the-ios-object-model","text":"The diagram below shows the key objects involved in the processing of a Alipay/WeChat sale request. Note The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is WDSaleRequest but that is tough to read, so we display it as Sale Request instead. We do the same with method names. For example, the method add Alipay payment , shown above, is implemented in Objective-C and Swift as addAlipayPayment . The similar is true for add WeChat payment . Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it.","title":"The iOS Object Model"},{"location":"int-salerequest-alternativePayment/#the-ios-process-flow","text":"The process flow in the code is as follows: Instantiate a Sale Request object. The type attribute of Sale Request defines the type of sale request, most commonly a Purchase . Add details to the Sale Request object with the add sale item method. For Alipay transactions, use the add alipay payment method. For WeChat transactions, use the add wechat payment method. Pass the full details of the Sale Request to the Payment Config object in the sale property. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter.","title":"The iOS Process Flow"},{"location":"int-salerequest-alternativePayment/#the-android-object-model","text":"The Sales Manager component in Android is implemented as the sales () method of the EposSDK class. The Sales Builder then does most of the work as shown:","title":"The Android Object Model"},{"location":"int-salerequest-alternativePayment/#the-android-process-flow","text":"The process flow is: Create an items object with a Sale Item Type of Purchase . Use Sale Builder to create the sale request. Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with pay(Sales Builder) . The add alipay payment method indicates that the full amount of the sale is paid with Alipay (i.e., 10 \u20ac). The add wechat payment method indicates that the full amount of the sale is paid with WeChat (i.e., 10 \u20ac). * A saleId string is returned which has the complete sale object. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter.","title":"The Android Process Flow"},{"location":"int-salerequest-alternativePayment/#the-sample-code","text":"Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI. Warning Wechat and Alipay payments must include a sale note (only mandatory for these alternative payment methods) that can be used for storing details about the sale. While the content of this note is not validated by Wirecard (as soon as it is not empty), both Wechat and Alipay demands a brief description of the sale (ie. nature of it, or products sold) for regulatory reasons.","title":"The Sample Code"},{"location":"int-salerequest-card-authorize-capture/","text":"Sale Request - Card - Authorize and Capture Authorize and Capture is a two phase approach. The first step is to create the Sale with Authorization Request - this will block the requested amount on cardholder account. The next step is to Capture the amount from previous authorization by using Reference Sale and specifying the Capture request. The process of performing Sale with Card Authorization is similar to the one of Sale Request with the Card Payment . The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Authorize and Capture"},{"location":"int-salerequest-card-authorize-capture/#sale-request-card-authorize-and-capture","text":"Authorize and Capture is a two phase approach. The first step is to create the Sale with Authorization Request - this will block the requested amount on cardholder account. The next step is to Capture the amount from previous authorization by using Reference Sale and specifying the Capture request. The process of performing Sale with Card Authorization is similar to the one of Sale Request with the Card Payment .","title":"Sale Request - Card - Authorize and Capture"},{"location":"int-salerequest-card-authorize-capture/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salerequest-card-eft/","text":"Sale Request - SEPA EFT Card An alternative to regular card payments is using a Girocard/EFT compatible card. From an integrator's perspective, the user interface, object model and requirements are pretty much the same as those of a regular card payment, as seen in their request page (just the function to add the payment itself is changed from addCardPayment to addEFTCardPayment ). But the nature of the payment itself is different, so it is important to be aware of its behavior from an UI perspective: An Electronic funds transfer (EFT) is a banking process using debit/credit cards for electronic deposits and bill payments from two different bank accounts. Only the card's magnetic stripe is used for reading the IBAN, and for this reason, an EFT Card payment will always start requesting \"please, swipe the card\", with no fallback to chip or contacless payment allowed. Fortunately for you as an integrator, the flow of an EFT Card won't have any special steps, and you can reuse the confirmation, completion and all other callbacks of a regular card payment . The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"SEPA EFT Request"},{"location":"int-salerequest-card-eft/#sale-request-sepa-eft-card","text":"An alternative to regular card payments is using a Girocard/EFT compatible card. From an integrator's perspective, the user interface, object model and requirements are pretty much the same as those of a regular card payment, as seen in their request page (just the function to add the payment itself is changed from addCardPayment to addEFTCardPayment ). But the nature of the payment itself is different, so it is important to be aware of its behavior from an UI perspective: An Electronic funds transfer (EFT) is a banking process using debit/credit cards for electronic deposits and bill payments from two different bank accounts. Only the card's magnetic stripe is used for reading the IBAN, and for this reason, an EFT Card payment will always start requesting \"please, swipe the card\", with no fallback to chip or contacless payment allowed. Fortunately for you as an integrator, the flow of an EFT Card won't have any special steps, and you can reuse the confirmation, completion and all other callbacks of a regular card payment .","title":"Sale Request - SEPA EFT Card"},{"location":"int-salerequest-card-eft/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salerequest-card/","text":"Sale Request - Card You should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device. The User Interface Let's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user. The same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the previous chapter . Code Differences with Credit Sale Request The key differences between the cash code and the credit code presented in this topic are: Terminal Manager is used to discover Devices and the results are placed into: an array of terminals in the iOS code a terminalDevice object in the Android code. The add card payment method is used instead of the add cash payment method. The add card payment method uses the discovered terminal. That's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models. The iOS Object Model An expanded version of the iOS object model is shown below. It now shows the add card payment method and the Terminal Manager component and illustrates how they collaborate together. Tip If you are a little overwhelmed at this point, don't worry about it. The Payment Flow chapter provides a good review which covers card and cash payments on iOS a second time. Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it. The Android Object Model The Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the eventRelay takes over and handles various events that can take place on the terminal, such as Signature Request , Signature Confirmation and so forth. Note Signature Request and Signature Confirmation on iOS are covered in the Payment Flow chapter. In addition, a sample UI for handling these user actions is presented in that chapter. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Card Request"},{"location":"int-salerequest-card/#sale-request-card","text":"You should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device.","title":"Sale Request - Card"},{"location":"int-salerequest-card/#the-user-interface","text":"Let's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user. The same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the previous chapter .","title":"The User Interface"},{"location":"int-salerequest-card/#code-differences-with-credit-sale-request","text":"The key differences between the cash code and the credit code presented in this topic are: Terminal Manager is used to discover Devices and the results are placed into: an array of terminals in the iOS code a terminalDevice object in the Android code. The add card payment method is used instead of the add cash payment method. The add card payment method uses the discovered terminal. That's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models.","title":"Code Differences with Credit Sale Request"},{"location":"int-salerequest-card/#the-ios-object-model","text":"An expanded version of the iOS object model is shown below. It now shows the add card payment method and the Terminal Manager component and illustrates how they collaborate together. Tip If you are a little overwhelmed at this point, don't worry about it. The Payment Flow chapter provides a good review which covers card and cash payments on iOS a second time. Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it.","title":"The iOS Object Model"},{"location":"int-salerequest-card/#the-android-object-model","text":"The Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the eventRelay takes over and handles various events that can take place on the terminal, such as Signature Request , Signature Confirmation and so forth. Note Signature Request and Signature Confirmation on iOS are covered in the Payment Flow chapter. In addition, a sample UI for handling these user actions is presented in that chapter.","title":"The Android Object Model"},{"location":"int-salerequest-card/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salerequest-cash/","text":"Sale Request - Cash Let's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component. The User Interface The starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single Item 1 is being purchased at a price of 10.00 \u20ac and the tax rate is 20.00% . In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the Cash button. Tip For our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as EUR . Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale. The iOS Design The Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow. The iOS Object Model The diagram below shows the key objects involved in the processing of a cash sale request. Note The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is WDSaleRequest but that is tough to read, so we display it as Sale Request instead. We do the same with method names. For example, the method add cash payment , shown above, is implemented in Objective-C and Swift as addCashPayment . Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it. The iOS Process Flow The process flow in the code is as follows: Instantiate a Sale Request object. The type attribute of Sale Request defines the type of sale request, most commonly a Purchase . Add details to the Sale Request object with the add sale item method. For cash transactions, use the add cash payment method. Pass the full details of the Sale Request to the Payment Config object in the sale property. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter. The Android Design The Android design and process flow is described below. The Android Object Model The Sales Manager component in Android is implemented as the sales () method of the EposSDK class. The Sales Builder then does most of the work as shown: The Android Process Flow The process flow is: Create an items object with a Sale Item Type of Purchase . Use Sale Builder to create the sale request. Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with pay(Sales Builder) . The add cash payment method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac). A saleId string is returned which has the complete sale object. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter. The Sample Code Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI. ObjC Swift Universal Windows Platform SDK coming soon","title":"Cash Request"},{"location":"int-salerequest-cash/#sale-request-cash","text":"Let's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component.","title":"Sale Request - Cash"},{"location":"int-salerequest-cash/#the-user-interface","text":"The starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single Item 1 is being purchased at a price of 10.00 \u20ac and the tax rate is 20.00% . In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the Cash button. Tip For our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as EUR . Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.","title":"The User Interface"},{"location":"int-salerequest-cash/#the-ios-design","text":"The Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow.","title":"The iOS Design"},{"location":"int-salerequest-cash/#the-ios-object-model","text":"The diagram below shows the key objects involved in the processing of a cash sale request. Note The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the WDePos , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is WDSaleRequest but that is tough to read, so we display it as Sale Request instead. We do the same with method names. For example, the method add cash payment , shown above, is implemented in Objective-C and Swift as addCashPayment . Info When adding a payment method ( addCashPayment , addCardPayment , etc.), you can optionally include a notification callback URL in your payment request ( notifyUrl ). This URL will then be called once the payment is completed, if you chose to set it.","title":"The iOS Object Model"},{"location":"int-salerequest-cash/#the-ios-process-flow","text":"The process flow in the code is as follows: Instantiate a Sale Request object. The type attribute of Sale Request defines the type of sale request, most commonly a Purchase . Add details to the Sale Request object with the add sale item method. For cash transactions, use the add cash payment method. Pass the full details of the Sale Request to the Payment Config object in the sale property. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter.","title":"The iOS Process Flow"},{"location":"int-salerequest-cash/#the-android-design","text":"The Android design and process flow is described below.","title":"The Android Design"},{"location":"int-salerequest-cash/#the-android-object-model","text":"The Sales Manager component in Android is implemented as the sales () method of the EposSDK class. The Sales Builder then does most of the work as shown:","title":"The Android Object Model"},{"location":"int-salerequest-cash/#the-android-process-flow","text":"The process flow is: Create an items object with a Sale Item Type of Purchase . Use Sale Builder to create the sale request. Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with pay(Sales Builder) . The add cash payment method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac). A saleId string is returned which has the complete sale object. At this point, the Sales Manager component has everything it needs to process the payment in the sale property, and the next steps are described in The Payment Flow chapter.","title":"The Android Process Flow"},{"location":"int-salerequest-cash/#the-sample-code","text":"Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.","title":"The Sample Code"},{"location":"int-salerequest-modify/","text":"Modify Sale - Changes and Maintenance A sale that has not being fully settled (it remains in an incomplete or open status) can be modified an unlimited amount of times. There are, though, two parameters that are mandatory for modifying your sale: the original sale Id, and the current version of the sale (a numeric value to avoid parallel changes). The original sale Id will remain unchanged, while the version will increase once the modification succed. The following Sale parameters can be changed: The Note , by appending new content (removal of original note is not possible). Sending an empty note equals to leave it untouched. Also note that some constant text will be added to let know, within the note itself, that it was changed. The Tax Mode , either by setting Tax inclusive as true or false (tax exclusive). The Items . You can either add nor remove items in your sale, and even let the array of items empty as they are not mandatory. The Total Amount fot the sale. Note that the total amount is linked with the sale items: you can have zero items and a total amount, but if some items are present, the total must match the total price to pay from those the items. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Modify Sale"},{"location":"int-salerequest-modify/#modify-sale-changes-and-maintenance","text":"A sale that has not being fully settled (it remains in an incomplete or open status) can be modified an unlimited amount of times. There are, though, two parameters that are mandatory for modifying your sale: the original sale Id, and the current version of the sale (a numeric value to avoid parallel changes). The original sale Id will remain unchanged, while the version will increase once the modification succed. The following Sale parameters can be changed: The Note , by appending new content (removal of original note is not possible). Sending an empty note equals to leave it untouched. Also note that some constant text will be added to let know, within the note itself, that it was changed. The Tax Mode , either by setting Tax inclusive as true or false (tax exclusive). The Items . You can either add nor remove items in your sale, and even let the array of items empty as they are not mandatory. The Total Amount fot the sale. Note that the total amount is linked with the sale items: you can have zero items and a total amount, but if some items are present, the total must match the total price to pay from those the items.","title":"Modify Sale - Changes and Maintenance"},{"location":"int-salerequest-modify/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salerequest-reference/","text":"Reference Sale After the initial Sale was processed by one of the available Sale Requests ( Cash , Card , Alternative , Capture , etc.) and the full Sale ammount has not been settled yet, it is possible to process additional payments within the Original Sale. Reference Sale Request contains the Original Sale reference and the payment details related to specific payment method. The Original Sale will be completed once the summary of all completed payments amount equals the Original Sale total amount. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Reference Sale"},{"location":"int-salerequest-reference/#reference-sale","text":"After the initial Sale was processed by one of the available Sale Requests ( Cash , Card , Alternative , Capture , etc.) and the full Sale ammount has not been settled yet, it is possible to process additional payments within the Original Sale. Reference Sale Request contains the Original Sale reference and the payment details related to specific payment method. The Original Sale will be completed once the summary of all completed payments amount equals the Original Sale total amount.","title":"Reference Sale"},{"location":"int-salerequest-reference/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salereturns/","text":"Sale Return Sometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a full refund is required. If the consumer only wants to return a portion of their purchase, then a partial refund is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund. Note In the case of a card payment, the return amount is processed directly to the card that was used for payment. Tip At the time of a return, you may also want to look up the Sale History so you can see the full details of the sale. The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Return Sale"},{"location":"int-salereturns/#sale-return","text":"Sometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a full refund is required. If the consumer only wants to return a portion of their purchase, then a partial refund is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund. Note In the case of a card payment, the return amount is processed directly to the card that was used for payment. Tip At the time of a return, you may also want to look up the Sale History so you can see the full details of the sale.","title":"Sale Return"},{"location":"int-salereturns/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salereversals/","text":"Sale Cancel A sale cancellation is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported. This operation can be performed only for Sale in Unconfirmed state and only if all underlying payments are Reversed . The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Cancel Sale"},{"location":"int-salereversals/#sale-cancel","text":"A sale cancellation is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported. This operation can be performed only for Sale in Unconfirmed state and only if all underlying payments are Reversed .","title":"Sale Cancel"},{"location":"int-salereversals/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-saleshistory/","text":"Sales History The sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a query is constructed that includes attributes such as: paging information ordering information start date end date Tip Sales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as saleManager , whereas in Java it is implemented as sales () . The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Sales History"},{"location":"int-saleshistory/#sales-history","text":"The sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a query is constructed that includes attributes such as: paging information ordering information start date end date Tip Sales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as saleManager , whereas in Java it is implemented as sales () .","title":"Sales History"},{"location":"int-saleshistory/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-salesstatistics/","text":"Sales Statistics You frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics. To get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include: MIN - amount of the smallest sale MAX - amount of the largest sale Turnover Transaction Counts The sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the saleStatistics object has the results of the query. In the Android code, the salesStatistics has the results. Tip The Java code uses the term withFields while the Objective-C code uses the term query . The Sample Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Sales Statistics"},{"location":"int-salesstatistics/#sales-statistics","text":"You frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics. To get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include: MIN - amount of the smallest sale MAX - amount of the largest sale Turnover Transaction Counts The sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the saleStatistics object has the results of the query. In the Android code, the salesStatistics has the results. Tip The Java code uses the term withFields while the Objective-C code uses the term query .","title":"Sales Statistics"},{"location":"int-salesstatistics/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-scanner-discovery/","text":"Scanner Discovery The discover devices functionality of Scanner Manager: discovers any connected handheld barcode scanning devices registers to receive device status updates registers to receive action result updates prepares Scanner Manager for the reception of the data after the barcode is scanned So, related to the last point above, the main task for you is to implement a method that handles the dataReceived . The User Interface A typical user interface might look like this: The Sample Code For simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner. Warning In the iOS Code The base class needs to conform to WDScanning . ObjC Swift Universal Windows Platform SDK coming soon","title":"Scanner Discovery"},{"location":"int-scanner-discovery/#scanner-discovery","text":"The discover devices functionality of Scanner Manager: discovers any connected handheld barcode scanning devices registers to receive device status updates registers to receive action result updates prepares Scanner Manager for the reception of the data after the barcode is scanned So, related to the last point above, the main task for you is to implement a method that handles the dataReceived .","title":"Scanner Discovery"},{"location":"int-scanner-discovery/#the-user-interface","text":"A typical user interface might look like this:","title":"The User Interface"},{"location":"int-scanner-discovery/#the-sample-code","text":"For simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner. Warning In the iOS Code The base class needs to conform to WDScanning .","title":"The Sample Code"},{"location":"int-scanner-overview/","text":"Scanner Manager Overview This section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.","title":"Scanner Manager Overview"},{"location":"int-scanner-overview/#scanner-manager-overview","text":"This section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.","title":"Scanner Manager Overview"},{"location":"int-scannermanager/","text":"Scanner Manager xxx The Object Model xxx The Code Insert GIST here and remove Objective-C below. //The base class needs to conform to WDAcceptScanning //Discover active devices [[ sdk scannerManager ] discoverDevices : WDASocketExtensionUUID //Get the active SocketScanner handheld barcode scanner completion : ^ ( NSArray < WDAcceptTerminal *>* _Nullable devices , NSError * _Nullable devicesError ){ //Register for updates on device statuses and action results //Add Scanner delegate to receive the data after the barcode was read //Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived; [[ sdk scannerManager ] addScannerManagerDelegate : self forScanner :[ devices firstObject ]]; //for simplicity we will use the first active SocketScanner device }];","title":"Scanner Manager"},{"location":"int-scannermanager/#scanner-manager","text":"xxx","title":"Scanner Manager"},{"location":"int-scannermanager/#the-object-model","text":"xxx","title":"The Object Model"},{"location":"int-scannermanager/#the-code","text":"Insert GIST here and remove Objective-C below. //The base class needs to conform to WDAcceptScanning //Discover active devices [[ sdk scannerManager ] discoverDevices : WDASocketExtensionUUID //Get the active SocketScanner handheld barcode scanner completion : ^ ( NSArray < WDAcceptTerminal *>* _Nullable devices , NSError * _Nullable devicesError ){ //Register for updates on device statuses and action results //Add Scanner delegate to receive the data after the barcode was read //Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived; [[ sdk scannerManager ] addScannerManagerDelegate : self forScanner :[ devices firstObject ]]; //for simplicity we will use the first active SocketScanner device }];","title":"The Code"},{"location":"int-setup-android-gradle/","text":"Set up with Gradle Hassle-free setup on Android is now available with v2.0 of the SDK, using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build. Caution The minimum API level supported by this library is API 16 (Jelly Bean). Add the following lines to your root build . gradle file to include the SDK in your Android Studio project: Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Gradle"},{"location":"int-setup-android-gradle/#set-up-with-gradle","text":"Hassle-free setup on Android is now available with v2.0 of the SDK, using Gradle dependencies. The Gradle build system in Android Studio makes it easy to include external binaries or other library modules to your build as dependencies. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files are included in your build. Caution The minimum API level supported by this library is API 16 (Jelly Bean). Add the following lines to your root build . gradle file to include the SDK in your Android Studio project: Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Set up with Gradle"},{"location":"int-setup-android-manual/","text":"Set up Manually Caution Set up Manually is not recommended way, but it's still available. Definitely see Set up with Gradle section. The minimum API level supported by this library is API 16 (Jelly Bean). Follow the steps listed below to set up the Wirecard ePOS SDK for Android manually: Open JFrog Bintray repository website, where you can find all SDK's modules. For each library, in Files section, and appropriate version folder, locate an .aar files. Manually download those .aar files to the libs folder in your project. Make sure, you have flatDir { dirs 'libs' } in your project build.gradle file. Add a dependency in the module build.gradle file e.g. compile ( name : 'nameOfLibrary-version' , ext : 'aar' ) . Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Manually"},{"location":"int-setup-android-manual/#set-up-manually","text":"Caution Set up Manually is not recommended way, but it's still available. Definitely see Set up with Gradle section. The minimum API level supported by this library is API 16 (Jelly Bean). Follow the steps listed below to set up the Wirecard ePOS SDK for Android manually: Open JFrog Bintray repository website, where you can find all SDK's modules. For each library, in Files section, and appropriate version folder, locate an .aar files. Manually download those .aar files to the libs folder in your project. Make sure, you have flatDir { dirs 'libs' } in your project build.gradle file. Add a dependency in the module build.gradle file e.g. compile ( name : 'nameOfLibrary-version' , ext : 'aar' ) . Tip After set up of SDK, you can continue with SDK Initialization section.","title":"Set up Manually"},{"location":"int-setup-ios-cocoa/","text":"Set up with Cocoapods (Recommended) The setup process for the Wirecard ePOS SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to set up the SDK manually because all setup files are available on the Github repository for iOS . Before starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the CocoaPods site . To add the Wirecard ePOS SDK to your application, create a Podfile and then: Open the Podfile in a text editor. Add the below lines to the Podfile platform : ios , ' 9.0 ' use_frameworks ! target ' YourTarget ' do pod ' WDePOS/All ' end That's it. Only couple of lines are required to install the SDK into your app. Note: If you want to use more than one target then you must explicitly state this in your Podfile. Tip If you encounter issues with pod install please run 'pod repo update' to upgrade your cocoapods pod repo update In the folder where your podfile is stored, run pod install to install a new pod. Or run pod update to update your current one. This downloads and installs the SDK from Cocoapods and it creates the workspace for your application. The Example folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The iOS Integration Tests chapter has more information. Should you wish to use BlueTooth devices (Terminals, Printers, Cash Registers) you need to include UISupportedExternalAccessoryProtocols settings in your application plist file: Device Vendor Accessory protocol Spire com.thyron StarMicronics / StarIO jp.star-m.starpro Datecs com.datecs.printer.escpos SocketMobile com.socketmobile.chs Note The workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is WDePOS in the path in the directory one level above the current Example app project.","title":"Cocoapods (Recommended)"},{"location":"int-setup-ios-cocoa/#set-up-with-cocoapods-recommended","text":"The setup process for the Wirecard ePOS SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to set up the SDK manually because all setup files are available on the Github repository for iOS . Before starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the CocoaPods site . To add the Wirecard ePOS SDK to your application, create a Podfile and then: Open the Podfile in a text editor. Add the below lines to the Podfile platform : ios , ' 9.0 ' use_frameworks ! target ' YourTarget ' do pod ' WDePOS/All ' end That's it. Only couple of lines are required to install the SDK into your app. Note: If you want to use more than one target then you must explicitly state this in your Podfile. Tip If you encounter issues with pod install please run 'pod repo update' to upgrade your cocoapods pod repo update In the folder where your podfile is stored, run pod install to install a new pod. Or run pod update to update your current one. This downloads and installs the SDK from Cocoapods and it creates the workspace for your application. The Example folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The iOS Integration Tests chapter has more information. Should you wish to use BlueTooth devices (Terminals, Printers, Cash Registers) you need to include UISupportedExternalAccessoryProtocols settings in your application plist file: Device Vendor Accessory protocol Spire com.thyron StarMicronics / StarIO jp.star-m.starpro Datecs com.datecs.printer.escpos SocketMobile com.socketmobile.chs Note The workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is WDePOS in the path in the directory one level above the current Example app project.","title":"Set up with Cocoapods (Recommended)"},{"location":"int-setup-ios-manual/","text":"Set up using Carthage The SDK supports installation using the Carthage dependency manager . Just run the carthage update command in the SDK root directory and get the WDePOS and related frameworks from Carthage / Build /< platform > directory carthage update Set up Manually (Not Recommended) To manually install the SDK: Make sure you have cocoapods installed. Download the SDK from Wirecard ePOS SDK for iOS repository on Github . Unzip it and run 'pod install' within \"unzipped_SDK/Example\" folder. After the pods are installed, copy the Pods.xcodeproj from \"unzipped_SDK/Example/Pods\" into your own project. Make sure you are copying the xcodeproj and not the Pods folder; otherwise you may enter into duplicated definitions problems. After the Pods.xcodeproj is added to your project, manually add the following frameworks into your project's General section \"Embedded binaries\": AFNetworking.framework BerTlv.framework CocoaLumberjack.framework INTULocationManager.framework libextobjc.framework Lockbox.framework Mantle.framework Overcoat.framework ZipArchive.framework Other Wirecard ePOS SDK frameworks need to be added manually. Add to your project the WDePos.framework and the WDePosResources.bundle files, and other hardware frameworks you plan on using, from \"unzipped_SDK/Pod/Classes\". Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners are: Device Framework Accessory protocol [SPm2] Spire_SDK.framework com.thyron [StarMicronics , mPOP] Stario_SDK.framework jp.star-m.starpro [DPP-250] Datecs_SDK.framework com.datecs.printer.escpos [SocketScanner] Socket_SDK.framework com.socketmobile.chs Together with the step .5, your \"Embedded binaries\" section will look like: You also need to add the WDePosResources.bundle file into your project's Build Phases \"Copy Bundle Resources\u201d section: Now add the following Apple frameworks in your project's General \"Linked Frameworks and Libraries\" section: ExternalAccessory CoreFoundation CoreLocation CoreBluetooth UIKit CoreGraphics Security SystemConfiguration Foundation MobileCoreServices Together with the steps above, it will look like: Make sure your project Build Settings/Build Options has \u201cAlways Embed Swift Standard Libraries\u201d set to YES: And the last step: edit your project's info.plist (the faster way is as a text file) and copy paste the lines below. That way your project will include all needed keys/values and protocols for enabling hardware communication, permissions, etc. Make sure you don't have the following keys already defined with different values, and that you are going to use the UISupportedExternalAccessoryProtocols into your app (do not include the ones for hardware you don't plan on supporting, see point .6). < key > NSAppTransportSecurity </ key > < dict > < key > NSAllowsArbitraryLoads </ key > < true /> </ dict > < key > UIBackgroundModes </ key > < array > < string > audio </ string > < string > fetch </ string > < string > external - accessory </ string > < string > bluetooth - peripheral </ string > < string > bluetooth - central </ string > </ array > < key > NSBluetoothPeripheralUsageDescription </ key > < string > BlueTooth is required for Terminal and Printer communication </ string > < key > NSCameraUsageDescription </ key > < string > Camera will be used for barcode scanning and taking Photos for product catalogue </ string > < key > NSLocationWhenInUseUsageDescription </ key > < string > The terminal location will be used for all payments </ string > < key > NSMicrophoneUsageDescription </ key > < string > Audio jack is used for payment terminals such as BBPOS Chippers / Swippers </ string > < key > NSPhotoLibraryUsageDescription </ key > < string > Media Library will be used for adding pictures to catalogue products of your own </ string > < key > UISupportedExternalAccessoryProtocols </ key > < array > < string > com . socketmobile . chs </ string > < string > com . thyron </ string > < string > com . datecs . printer . escpos </ string > < string > jp . star - m . starpro </ string > </ array >","title":"Manually"},{"location":"int-setup-ios-manual/#set-up-using-carthage","text":"The SDK supports installation using the Carthage dependency manager . Just run the carthage update command in the SDK root directory and get the WDePOS and related frameworks from Carthage / Build /< platform > directory carthage update","title":"Set up using Carthage"},{"location":"int-setup-ios-manual/#set-up-manually-not-recommended","text":"To manually install the SDK: Make sure you have cocoapods installed. Download the SDK from Wirecard ePOS SDK for iOS repository on Github . Unzip it and run 'pod install' within \"unzipped_SDK/Example\" folder. After the pods are installed, copy the Pods.xcodeproj from \"unzipped_SDK/Example/Pods\" into your own project. Make sure you are copying the xcodeproj and not the Pods folder; otherwise you may enter into duplicated definitions problems. After the Pods.xcodeproj is added to your project, manually add the following frameworks into your project's General section \"Embedded binaries\": AFNetworking.framework BerTlv.framework CocoaLumberjack.framework INTULocationManager.framework libextobjc.framework Lockbox.framework Mantle.framework Overcoat.framework ZipArchive.framework Other Wirecard ePOS SDK frameworks need to be added manually. Add to your project the WDePos.framework and the WDePosResources.bundle files, and other hardware frameworks you plan on using, from \"unzipped_SDK/Pod/Classes\". Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners are: Device Framework Accessory protocol [SPm2] Spire_SDK.framework com.thyron [StarMicronics , mPOP] Stario_SDK.framework jp.star-m.starpro [DPP-250] Datecs_SDK.framework com.datecs.printer.escpos [SocketScanner] Socket_SDK.framework com.socketmobile.chs Together with the step .5, your \"Embedded binaries\" section will look like: You also need to add the WDePosResources.bundle file into your project's Build Phases \"Copy Bundle Resources\u201d section: Now add the following Apple frameworks in your project's General \"Linked Frameworks and Libraries\" section: ExternalAccessory CoreFoundation CoreLocation CoreBluetooth UIKit CoreGraphics Security SystemConfiguration Foundation MobileCoreServices Together with the steps above, it will look like: Make sure your project Build Settings/Build Options has \u201cAlways Embed Swift Standard Libraries\u201d set to YES: And the last step: edit your project's info.plist (the faster way is as a text file) and copy paste the lines below. That way your project will include all needed keys/values and protocols for enabling hardware communication, permissions, etc. Make sure you don't have the following keys already defined with different values, and that you are going to use the UISupportedExternalAccessoryProtocols into your app (do not include the ones for hardware you don't plan on supporting, see point .6). < key > NSAppTransportSecurity </ key > < dict > < key > NSAllowsArbitraryLoads </ key > < true /> </ dict > < key > UIBackgroundModes </ key > < array > < string > audio </ string > < string > fetch </ string > < string > external - accessory </ string > < string > bluetooth - peripheral </ string > < string > bluetooth - central </ string > </ array > < key > NSBluetoothPeripheralUsageDescription </ key > < string > BlueTooth is required for Terminal and Printer communication </ string > < key > NSCameraUsageDescription </ key > < string > Camera will be used for barcode scanning and taking Photos for product catalogue </ string > < key > NSLocationWhenInUseUsageDescription </ key > < string > The terminal location will be used for all payments </ string > < key > NSMicrophoneUsageDescription </ key > < string > Audio jack is used for payment terminals such as BBPOS Chippers / Swippers </ string > < key > NSPhotoLibraryUsageDescription </ key > < string > Media Library will be used for adding pictures to catalogue products of your own </ string > < key > UISupportedExternalAccessoryProtocols </ key > < array > < string > com . socketmobile . chs </ string > < string > com . thyron </ string > < string > com . datecs . printer . escpos </ string > < string > jp . star - m . starpro </ string > </ array >","title":"Set up Manually (Not Recommended)"},{"location":"int-terminal-avail/","text":"Check Available Updates You can check for available updates before performing an Update Firmware . This sample code discovers connected devices and for the first one found, checks for any available updates. Typically, you should provide the user with an information notice and option to update if there is new firmware available. Update types Wirecard ePOS SDK provides 3 types of terminal updates. firmware application configuration Every terminal can handle different types of update. For example, Spire's SPm2 uses application and configuration updates. Note You can specify which update type you can check, or you can leave parameter empty, and SDK will check all available update types for the selected terminal. The Code ObjC Swift Universal Windows Platform SDK coming soon","title":"Check Available Updates"},{"location":"int-terminal-avail/#check-available-updates","text":"You can check for available updates before performing an Update Firmware . This sample code discovers connected devices and for the first one found, checks for any available updates. Typically, you should provide the user with an information notice and option to update if there is new firmware available.","title":"Check Available Updates"},{"location":"int-terminal-avail/#update-types","text":"Wirecard ePOS SDK provides 3 types of terminal updates. firmware application configuration Every terminal can handle different types of update. For example, Spire's SPm2 uses application and configuration updates. Note You can specify which update type you can check, or you can leave parameter empty, and SDK will check all available update types for the selected terminal.","title":"Update types"},{"location":"int-terminal-avail/#the-code","text":"","title":"The Code"},{"location":"int-terminal-discovery/","text":"Terminal Discovery The discoverDevices method of Terminal Manager handles discovery of all paired and connected terminals. Spire manufactures the following terminals: SPm2 Pax terminal: A920 The User Interface A typical user interface might look like this: The Sample Code Once the terminal is selected from the list of available terminals it can be saved for later use as an instance variable or a user preference ObjC Swift Universal Windows Platform SDK coming soon","title":"Terminal Discovery"},{"location":"int-terminal-discovery/#terminal-discovery","text":"The discoverDevices method of Terminal Manager handles discovery of all paired and connected terminals. Spire manufactures the following terminals: SPm2 Pax terminal: A920","title":"Terminal Discovery"},{"location":"int-terminal-discovery/#the-user-interface","text":"A typical user interface might look like this:","title":"The User Interface"},{"location":"int-terminal-discovery/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-terminal-overview/","text":"Terminal Manager Overview This section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to: discover devices update firmware check for available devices","title":"Terminal Manager Overview"},{"location":"int-terminal-overview/#terminal-manager-overview","text":"This section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to: discover devices update firmware check for available devices","title":"Terminal Manager Overview"},{"location":"int-terminal-update/","text":"Update Firmware Card acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter. Tip You can check if any updates are available with the Check Available Updates sample code. The User Interface A typical interface might look like this: The Sample Code In the sample code, all terminals (Miura terminals are selected) are discovered and then the first one is updated. Both the firmware and payment application are updated. ObjC Swift Universal Windows Platform SDK coming soon","title":"Update Firmware"},{"location":"int-terminal-update/#update-firmware","text":"Card acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter. Tip You can check if any updates are available with the Check Available Updates sample code.","title":"Update Firmware"},{"location":"int-terminal-update/#the-user-interface","text":"A typical interface might look like this:","title":"The User Interface"},{"location":"int-terminal-update/#the-sample-code","text":"In the sample code, all terminals (Miura terminals are selected) are discovered and then the first one is updated. Both the firmware and payment application are updated.","title":"The Sample Code"},{"location":"int-tests-a/","text":"Android Integration Tests A variety of integration tests are provided in the examples directory, as shown below: Each of these is described briefly below. AuthenticationTest.java Provides sample code with a variety of functionality from the User Manager component that you can use for testing, including: get the current user get active cashiers change a password obtain the password policy PIN validation BaseDemoTest.java Provides a basic test of the demo application. CashTests.java Provides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes: request user and cash register information shift management including opening a new shift shift reporting for any closed shifts pay in/out reporting for shifts execution of a cash sale CatalogueTests.java Demonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including: obtaining catalogue data identifying changes in the data This includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app. InitializationTest.java Demonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the updateUserCredentials method. OtherTests.java Miscellaneous tests including getting the server time and date. PrinterTest.java Enables you to test the Printer Manager component, including: detecting available printers printing a receipt SalesTest.java Illustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the getSales () method. StatsTest.java Demonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including: maximum sale minimum sale sales turnover TerminalTest.java Helps you test features of the Terminal Manager component, including: discovery of terminals check for updates for the terminals carry out a card sale with a Spire terminal UserTest.java Shows how to use the User Manager component to: test credentials and get a user remind the user of their password help a user reset their password","title":"Integration Tests"},{"location":"int-tests-a/#android-integration-tests","text":"A variety of integration tests are provided in the examples directory, as shown below: Each of these is described briefly below.","title":"Android Integration Tests"},{"location":"int-tests-a/#authenticationtestjava","text":"Provides sample code with a variety of functionality from the User Manager component that you can use for testing, including: get the current user get active cashiers change a password obtain the password policy PIN validation","title":"AuthenticationTest.java"},{"location":"int-tests-a/#basedemotestjava","text":"Provides a basic test of the demo application.","title":"BaseDemoTest.java"},{"location":"int-tests-a/#cashtestsjava","text":"Provides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes: request user and cash register information shift management including opening a new shift shift reporting for any closed shifts pay in/out reporting for shifts execution of a cash sale","title":"CashTests.java"},{"location":"int-tests-a/#cataloguetestsjava","text":"Demonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including: obtaining catalogue data identifying changes in the data This includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app.","title":"CatalogueTests.java"},{"location":"int-tests-a/#initializationtestjava","text":"Demonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the updateUserCredentials method.","title":"InitializationTest.java"},{"location":"int-tests-a/#othertestsjava","text":"Miscellaneous tests including getting the server time and date.","title":"OtherTests.java"},{"location":"int-tests-a/#printertestjava","text":"Enables you to test the Printer Manager component, including: detecting available printers printing a receipt","title":"PrinterTest.java"},{"location":"int-tests-a/#salestestjava","text":"Illustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the getSales () method.","title":"SalesTest.java"},{"location":"int-tests-a/#statstestjava","text":"Demonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including: maximum sale minimum sale sales turnover","title":"StatsTest.java"},{"location":"int-tests-a/#terminaltestjava","text":"Helps you test features of the Terminal Manager component, including: discovery of terminals check for updates for the terminals carry out a card sale with a Spire terminal","title":"TerminalTest.java"},{"location":"int-tests-a/#usertestjava","text":"Shows how to use the User Manager component to: test credentials and get a user remind the user of their password help a user reset their password","title":"UserTest.java"},{"location":"int-tests-i/","text":"iOS Integration Tests A variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the Example folder below your project folder. These tests are useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK. Each Test file has detailed comments that walk you through the code. Each Test is described briefly below. CashTests Demonstrates a complete usage of the Cash Management feature including how to: login and request user data check for available cash registers and get one deal with various shift-related activities, such as open and close pay in and pay out The code also demonstrates how to process: a complete cash sale with a basket full of items a refund of a sale CatalogueTests Illustrates how to request: product catalogues product categories products product images This data can then be used to display a product catalogue within your payment acceptance app, including images of each product. DatecsPrinterTest Enables you to test a Datecs printer, including: get a sale detect a printer print a receipt The Datecs printer only works with the Receipt object. The StarIO printer works with: PDF UIImage ERP Tests This test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult Using an ERP . Before using this test, you must: have ERP enabled in your back-end ensure that you have actual data, such as product catalogue, members, products and so forth in your ERP Note Members is another term for Customers in some ERP systems. The code demonstrates how to: search for members request discount prices for specific members request stock levels for specific products Note Stock level refers to the quantity of products in inventory. See Product Stocks (ERP) for more information about retrieving and using product stock levels from your ERP system. SalesTests Provides a basic test of a sale, including: login and request user data request a sale from the current user save the sale response so it can be used by other tests, such as the Printer tests query the sale Tip If you dive in and start reading the code, note that objects are named with a prefix of WD . WD is short for Wirecard. So to read the object name, ignore this prefix. For example, WDSalesQuery is the Sales Query object. WDMerchantUser is the Merchant User object. SocketScannerTests The SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including: discover paired scanners listen for activity on the paired scanner process a scanned barcode handle battery level changes To use this test, a barcode - example . png image file is provided in the WDePOSDemo folder, as shown: Scan this barcode when running this test to validate that your scanner is functioning properly. SpireTests The SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly with the SDK. To use this test, you must: have an actual iOS device because device simulators do not work for this test have a Spire terminal paired to your iOS device through your iOS device settings Once your hardware is ready, you can use the code to: discover paired iOS device check for updates for the device handle firmware updates process a card sale refund a sale Tip The refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card. The code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end. StarIOTests The SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code: detects paired devices opens the cash drawer prints a receipt scans a barcode Note The StarMicronics device does not have a barcode scanner. StatsTests A simple implementation lets you test the statistics retrieval features of the SDK, including querying for: minimum, maximum and average sale amounts turnover transaction counts See the Sales Statistics chapter for complete information. UserTests Provides a variety of tests for user and credential management (i.e., username/password), including: get credentials for a user remind a user of their username handle a request by a user to reset their password allow the user to change their password This functionality is part of the User Manager component which is described in more detail in the User Manager component chapter .","title":"Integration Tests"},{"location":"int-tests-i/#ios-integration-tests","text":"A variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the Example folder below your project folder. These tests are useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK. Each Test file has detailed comments that walk you through the code. Each Test is described briefly below.","title":"iOS Integration Tests"},{"location":"int-tests-i/#cashtests","text":"Demonstrates a complete usage of the Cash Management feature including how to: login and request user data check for available cash registers and get one deal with various shift-related activities, such as open and close pay in and pay out The code also demonstrates how to process: a complete cash sale with a basket full of items a refund of a sale","title":"CashTests"},{"location":"int-tests-i/#cataloguetests","text":"Illustrates how to request: product catalogues product categories products product images This data can then be used to display a product catalogue within your payment acceptance app, including images of each product.","title":"CatalogueTests"},{"location":"int-tests-i/#datecsprintertest","text":"Enables you to test a Datecs printer, including: get a sale detect a printer print a receipt The Datecs printer only works with the Receipt object. The StarIO printer works with: PDF UIImage","title":"DatecsPrinterTest"},{"location":"int-tests-i/#erp-tests","text":"This test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult Using an ERP . Before using this test, you must: have ERP enabled in your back-end ensure that you have actual data, such as product catalogue, members, products and so forth in your ERP Note Members is another term for Customers in some ERP systems. The code demonstrates how to: search for members request discount prices for specific members request stock levels for specific products Note Stock level refers to the quantity of products in inventory. See Product Stocks (ERP) for more information about retrieving and using product stock levels from your ERP system.","title":"ERP Tests"},{"location":"int-tests-i/#salestests","text":"Provides a basic test of a sale, including: login and request user data request a sale from the current user save the sale response so it can be used by other tests, such as the Printer tests query the sale Tip If you dive in and start reading the code, note that objects are named with a prefix of WD . WD is short for Wirecard. So to read the object name, ignore this prefix. For example, WDSalesQuery is the Sales Query object. WDMerchantUser is the Merchant User object.","title":"SalesTests"},{"location":"int-tests-i/#socketscannertests","text":"The SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including: discover paired scanners listen for activity on the paired scanner process a scanned barcode handle battery level changes To use this test, a barcode - example . png image file is provided in the WDePOSDemo folder, as shown: Scan this barcode when running this test to validate that your scanner is functioning properly.","title":"SocketScannerTests"},{"location":"int-tests-i/#spiretests","text":"The SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly with the SDK. To use this test, you must: have an actual iOS device because device simulators do not work for this test have a Spire terminal paired to your iOS device through your iOS device settings Once your hardware is ready, you can use the code to: discover paired iOS device check for updates for the device handle firmware updates process a card sale refund a sale Tip The refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card. The code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end.","title":"SpireTests"},{"location":"int-tests-i/#stariotests","text":"The SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code: detects paired devices opens the cash drawer prints a receipt scans a barcode Note The StarMicronics device does not have a barcode scanner.","title":"StarIOTests"},{"location":"int-tests-i/#statstests","text":"A simple implementation lets you test the statistics retrieval features of the SDK, including querying for: minimum, maximum and average sale amounts turnover transaction counts See the Sales Statistics chapter for complete information.","title":"StatsTests"},{"location":"int-tests-i/#usertests","text":"Provides a variety of tests for user and credential management (i.e., username/password), including: get credentials for a user remind a user of their username handle a request by a user to reset their password allow the user to change their password This functionality is part of the User Manager component which is described in more detail in the User Manager component chapter .","title":"UserTests"},{"location":"int-ui/","text":"Sale UI The SDK comes with the standard UI covering the whole payment flow*: Sale Amount entry Payment method selection Cardholder Signature collection QR Payment scanner Terminal selection Cash Register selection Shop selection Cash Shift management (Open/Close) *This feature is available for iOS only at the moment Please see the example application using the Sale UI. The example application can be found in Wirecard - ePOS - iOS / eClear directory. You can download the Wirecard-ePOS-iOS if you did not install it already through cocoapods. The Sample Code ObjC Swift Coming soon ... Universal Windows Platform SDK coming soon","title":"Sale UI"},{"location":"int-ui/#sale-ui","text":"The SDK comes with the standard UI covering the whole payment flow*: Sale Amount entry Payment method selection Cardholder Signature collection QR Payment scanner Terminal selection Cash Register selection Shop selection Cash Shift management (Open/Close) *This feature is available for iOS only at the moment Please see the example application using the Sale UI. The example application can be found in Wirecard - ePOS - iOS / eClear directory. You can download the Wirecard-ePOS-iOS if you did not install it already through cocoapods.","title":"Sale UI"},{"location":"int-ui/#the-sample-code","text":"","title":"The Sample Code"},{"location":"int-usb/","text":"Spire SPm2 terminal via USB Terminal SPm2 by default communicates via Bluetooth. But, it's also able to do it via USB. Caution Be sure, Android device you're using supports USB OTG. Requirements To proper USB communication, several things are required: enable USB communication on terminal during discover devices, choose USB one USB Settings on terminal Enable USB communication directly on terminal: turn on terminal press yellow arrow select \"data bearer\" select \"USB\" connect terminal via USB cable to your Android device continue with terminal discovery Terminal discovery Terminal discovery for USB terminals is no different from regular Terminal Discovery . Spire extension tries to find bluetooth and USB devices all together. If you have paired bluetooth terminal and also connected USB device, SDK will return all available terminals. Just select terminal, which has CommunicationType set to USB. Note Every time, you attach terminal to Android device and select it in SDK, user has to confirm communication with this specific device by tapping OK to shown dialog. Everything else should work the same.","title":"Spire SPm2 terminal via USB"},{"location":"int-usb/#spire-spm2-terminal-via-usb","text":"Terminal SPm2 by default communicates via Bluetooth. But, it's also able to do it via USB. Caution Be sure, Android device you're using supports USB OTG.","title":"Spire SPm2 terminal via USB"},{"location":"int-usb/#requirements","text":"To proper USB communication, several things are required: enable USB communication on terminal during discover devices, choose USB one","title":"Requirements"},{"location":"int-usb/#usb-settings-on-terminal","text":"Enable USB communication directly on terminal: turn on terminal press yellow arrow select \"data bearer\" select \"USB\" connect terminal via USB cable to your Android device continue with terminal discovery","title":"USB Settings on terminal"},{"location":"int-usb/#terminal-discovery","text":"Terminal discovery for USB terminals is no different from regular Terminal Discovery . Spire extension tries to find bluetooth and USB devices all together. If you have paired bluetooth terminal and also connected USB device, SDK will return all available terminals. Just select terminal, which has CommunicationType set to USB. Note Every time, you attach terminal to Android device and select it in SDK, user has to confirm communication with this specific device by tapping OK to shown dialog. Everything else should work the same.","title":"Terminal discovery"},{"location":"int-usermanager/","text":"User Manager The merchant's staff who use the payment acceptance app that you create are referred to as the users . Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials: password policy - lets you access the password rules password reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available) remind username - sends the user name to a specified email address change password - enables an authenticated user to change their password The User Interface A typical interface might look like this: The Sample Code In the iOS code, there are three key methods that are used: passwordPolicy manageCredentials changePassword The manageCredentials method used is in three different ways, which correspond to three parameters you can pass it: remindUserName resetPassword changePassword Note In the sample code, the SDK is instantiated with a name of sdkNoUser , in contrast with the usual object name of sdk . This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the Wirecard ePOS SDK object when you have an authenticated user. ObjC Swift Universal Windows Platform SDK coming soon","title":"User Manager"},{"location":"int-usermanager/#user-manager","text":"The merchant's staff who use the payment acceptance app that you create are referred to as the users . Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials: password policy - lets you access the password rules password reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available) remind username - sends the user name to a specified email address change password - enables an authenticated user to change their password","title":"User Manager"},{"location":"int-usermanager/#the-user-interface","text":"A typical interface might look like this:","title":"The User Interface"},{"location":"int-usermanager/#the-sample-code","text":"In the iOS code, there are three key methods that are used: passwordPolicy manageCredentials changePassword The manageCredentials method used is in three different ways, which correspond to three parameters you can pass it: remindUserName resetPassword changePassword Note In the sample code, the SDK is instantiated with a name of sdkNoUser , in contrast with the usual object name of sdk . This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the Wirecard ePOS SDK object when you have an authenticated user.","title":"The Sample Code"},{"location":"integrating/","text":"Guide to Integrating the SDK Heading Here Another Heading Subheading Subheading","title":"Guide to Integrating the SDK"},{"location":"integrating/#guide-to-integrating-the-sdk","text":"","title":"Guide to Integrating the SDK"},{"location":"integrating/#heading-here","text":"","title":"Heading Here"},{"location":"integrating/#another-heading","text":"","title":"Another Heading"},{"location":"integrating/#subheading","text":"","title":"Subheading"},{"location":"integrating/#subheading_1","text":"","title":"Subheading"},{"location":"ios-reference/","text":"iOS SDK Reference Class Library","title":"iOS SDK Reference"},{"location":"ios-reference/#ios-sdk-reference","text":"Class Library","title":"iOS SDK Reference"},{"location":"mpos-architecture/","text":"The mPOS Architecture This chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard. Partners, Merchants and Consumers As illustrated below, the Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants . The resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit. The cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see SDK Architecture for overview information and Cash Manager Overview for detailed information. Extensive Hardware Support In addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running: a printer for printing receipts a pistol scanner for scanning QR codes and barcodes a cash register or cash drawer to enable the handling of cash payments The SDK has extensive support for all of these devices. See the Getting Started chapter for a list of currently supported hardware devices. The Integrating the SDK section of this website has complete information. Tip Four components of the SDK architecture handle the four different types of hardware, as described in the next chapter . Note To enable Cash Management, you require cash drawer hardware. See the Cash Manager Overview chapter for more information about Cash Management. Switch, Gateway and the Acquiring Platform The payment acceptance app is a front-end application. The corresponding back-end is Switch . Each merchant must first be set up on Switch before they can use Wirecard ePOS SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch. Switch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the Wirecard Gateway . The Gateway, in turn, does the initial processing and then routes transactions to the Acquiring Platform , as illustrated below: Note The mPOS division at Wirecard is responsible for the Wirecard ePOS SDK and the Switch back-end. The Payment & Risk division oversees the Wirecard Gateway and the Acquiring Platform. Using an ERP A key implementation decision that each merchant must make before implementing mPOS is whether or not to use an ERP tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system than to replace it with a new one. For example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores. Tip Getting Product Stocks information is covered later in this documentation, along with getting Product Prices (ERP) . Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in Customer Manager (ERP) . If a merchant chooses to augment their back-end with an ERP, the architecture looks like this: Card Schemes and the Issuer The Acquiring Platform handles the communication with the various Card Schemes . The Card Schemes process transactions through the Issuing Bank of the Issuer . Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer. Moreover, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.","title":"The mPOS Architecture"},{"location":"mpos-architecture/#the-mpos-architecture","text":"This chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard.","title":"The mPOS Architecture"},{"location":"mpos-architecture/#partners-merchants-and-consumers","text":"As illustrated below, the Wirecard ePOS SDK enables our partners to create payment acceptance app functionality for merchants . The resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit. The cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see SDK Architecture for overview information and Cash Manager Overview for detailed information.","title":"Partners, Merchants and Consumers"},{"location":"mpos-architecture/#extensive-hardware-support","text":"In addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running: a printer for printing receipts a pistol scanner for scanning QR codes and barcodes a cash register or cash drawer to enable the handling of cash payments The SDK has extensive support for all of these devices. See the Getting Started chapter for a list of currently supported hardware devices. The Integrating the SDK section of this website has complete information. Tip Four components of the SDK architecture handle the four different types of hardware, as described in the next chapter . Note To enable Cash Management, you require cash drawer hardware. See the Cash Manager Overview chapter for more information about Cash Management.","title":"Extensive Hardware Support"},{"location":"mpos-architecture/#switch-gateway-and-the-acquiring-platform","text":"The payment acceptance app is a front-end application. The corresponding back-end is Switch . Each merchant must first be set up on Switch before they can use Wirecard ePOS SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch. Switch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the Wirecard Gateway . The Gateway, in turn, does the initial processing and then routes transactions to the Acquiring Platform , as illustrated below: Note The mPOS division at Wirecard is responsible for the Wirecard ePOS SDK and the Switch back-end. The Payment & Risk division oversees the Wirecard Gateway and the Acquiring Platform.","title":"Switch, Gateway and the Acquiring Platform"},{"location":"mpos-architecture/#using-an-erp","text":"A key implementation decision that each merchant must make before implementing mPOS is whether or not to use an ERP tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system than to replace it with a new one. For example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores. Tip Getting Product Stocks information is covered later in this documentation, along with getting Product Prices (ERP) . Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in Customer Manager (ERP) . If a merchant chooses to augment their back-end with an ERP, the architecture looks like this:","title":"Using an ERP"},{"location":"mpos-architecture/#card-schemes-and-the-issuer","text":"The Acquiring Platform handles the communication with the various Card Schemes . The Card Schemes process transactions through the Issuing Bank of the Issuer . Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer. Moreover, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.","title":"Card Schemes and the Issuer"},{"location":"sdk-architecture/","text":"The SDK Architecture The Wirecard ePOS SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below: Note While the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as salesManager in the Objective-C code and sales () in the Java code. Each component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail. Note All nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information. Sales Manager Sales are the lifeblood of any merchant so the Sales Manager component is the centerpiece of the SDK. A sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not. Caution A sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash. Inventory Manager Inventory Manager enables you to: maintain product catalogues maintain product categories maintain products maintain product images In addition, if the merchant uses an ERP system, it also enables: use of product stock information stored in the ERP use of product price information stored in the ERP The Inventory Manager component is highlighted below: Cash Management Components The Wirecard ePOS SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components: The Cash Manager component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth. The Cash Drawer Manager component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired. These two components are highlighted below: Hardware Components Four of the nine components in the SDK architecture enable the management of hardware. They are highlighted below: Terminal Manager The Terminal Manager component enables the discovery and usage of paired terminal devices, as well as the updating of firmware. Cash Drawer Manager As described earlier, the Cash Drawer Manager component enables the discovery and usage of paired cash drawers and cash registers. Printer Manager The Printer Manager component enables the discovery and usage of paired printer devices, primarily for the printing of receipts. Scanner Manager This Scanner Manager component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes. Customer, User and File Management Few supplementary components assist with handling customers and users and their standards behavior Customer Manager (ERP) ERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The Customer Manager component enables the use of this information. User Manager Apps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the User Manager component has a variety of useful functionality, including: Password Policy checks Password Resets Reminder User of Password Change Password File Manager This File Manager enables handling of (usually brand-specific) files in app using support from backend side. Primary it's like branding support component natively build in SDK. Error management Almost all Wirecard ePOS SDK calls can have two results. First is positive, when everything is happy and second, something less-happy is the error result. See in categories below, which errors could appear. iOS Errors WDErrorBackendReturnedJSONDoesNotMatchMappedClass WDErrorUnauthorizedUser WDErrorUserPasswordExpired WDErrorUserPasswordChangeRequired WDErrorUserAccessForbidden WDErrorResourceNotFound WDErrorSessionExpired WDErrorRequestTimeOut WDErrorRequestNoProperResponse WDErrorRequestParameterRequired WDErrorRequestedResourceNotFound WDErrorRequestFailedValidation WDErrorPlugInTimeout WDErrorSignatureTimeout WDErrorInitialization WDErrorLowBatteryLevel WDErrorSwipeTimeout WDErrorBadSwipe WDErrorNotSupportedCardType WDErrorDataProcessing WDErrorOnlineProcessing WDErrorTransactionNotApproved WDErrorHardwareAccessPermission WDErrorTokenExpired WDErrorConnection WDErrorSignatureRequired WDErrorCantLoadTerminalConfiguration WDErrorTerminalDamaged WDErrorNoDUKPT WDErrorFailedToStartEMV WDErrorFailedToSendOfflineEMV WDErrorFailedToSendOnlineEMV WDErrorTerminalNotSetInMerchant WDErrorResponseLost WDErrorTransactionTerminated WDErrorTransactionDeclined WDErrorTransactionFailure WDErrorBlockedCardType WDErrorFailedBluetoothConnection WDErrorFailedPrinterBluetoothConnection WDErrorFailedTerminalBluetoothConnection WDErrorFailedDrawerBluetoothConnection WDErrorFailedPistolBluetoothConnection WDErrorTerminalNotReady WDErrorTerminalCommunication WDErrorTerminalTimeoutApplicationSelection WDErrorTerminalFailedToGetICCApplicationsList WDErrorTerminalFailedToTerminateCurrentTerminalPaymentFlow WDErrorLowPowerInAudioJack WDErrorMonoAudioEnabled WDErrorTerminalCommandTimeOut WDErrorTerminalTimeOut WDErrorTerminalWaitingUserTimeOut WDErrorTerminalCancelledFileUpload WDErrorWrongUserNameOrPassword WDErrorVendorNotFound WDErrorExternalAccessoriesProtocolInvalid application . plist file . WDErrorExternalIdNotFound WDErrorChangePasswordCriteriaNotMet WDErrorQueryStatsTokenExpired WDErrorForgotExternalIdNotFound WDErrorConfigFilesInfoTimeout WDErrorConfigFilesZipDownload WDErrorTerminalDisconnected WDErrorConfigFilesTerminalMayNotBeSet WDErrorConfigFilesTerminalCancelledFileDownload WDErrorConfigFilesProductionFirmwareOnDevelopmentTerminal WDErrorConfigFilesDevelopmentFirmwareOnProductionTerminal WDErrorConfigFilesTerminalUnsupported WDErrorConfigFilesTokenExpired WDErrorInventoryNoData WDErrorTerminalFirmwareDoesNotExist WDErrorTerminalConfigDoesNotExist WDErrorConfigFilesReading WDErrorPrinterTimeout WDErrorPrinterInitialization WDErrorPrinterLowBatteryLevel WDErrorPrinterNotConnected WDErrorPrinterOperation WDErrorPrinterUnsupportedDevice WDErrorDeviceDoesNotSupportPrinting WDErrorPrinterPaperLow WDErrorSignatureRejectedFromTerminal WDErrorInvalidPaymentConfiguration WDErrorInvalidAIDConfiguration WDErrorTransactionReversalRequired WDErrorTransactionReversedByTerminal WDErrorTransactionReversalFailed WDErrorTransactionUpdateFailed WDErrorExtensionClassDoesNotExist WDErrorExtensionDoesNotSupportMethod WDErrorInvalidParameter WDErrorDeviceRooted WDErrorActiveTerminalNotSet WDErrorActiveScanPistolNotSet WDErrorActivePrinterNotSet WDErrorPinLocked WDErrorPinInvalid WDErrorGeneral WDErrorServerSSLCertificateExpired WDErrorFailedTerminalBluetoothConnectionNotInPayment WDErrorMissingMerchant WDErrorAnotherTransactionIsInProgress Android Exceptions SDK will usually returns exception, which extends from EposException and can also contain another exception in cause. Hierarchy of exceptions: EposException ( de . wirecard . epos . exceptions ) NoInternetException ( de . wirecard . epos . exceptions ) DeviceSelectingCanceled ( de . wirecard . epos . exceptions . initialization ) EposBackendException ( de . wirecard . epos . exceptions ) UnknownException ( de . wirecard . epos . exceptions ) ValidationException ( de . wirecard . epos . exceptions ) AmountTooLowException ( de . wirecard . epos . exceptions . validation ) MissingParamException ( de . wirecard . epos . exceptions . validation ) NoDeviceTypeException ( de . wirecard . epos . exceptions . validation ) TerminalAidConfigurationException ( de . wirecard . epos . exceptions . validation ) TipQuantityException ( de . wirecard . epos . exceptions . validation ) TerminalProfileException ( de . wirecard . epos . exceptions . validation ) MandatoryParametersException ( de . wirecard . epos . exceptions . validation ) TerminalProfileForNetworkException ( de . wirecard . epos . exceptions . validation ) ServiceChargeQuantityException ( de . wirecard . epos . exceptions . validation ) SaleValidationException ( de . wirecard . epos . exceptions . validation ) TerminalApplicationFileException ( de . wirecard . epos . exceptions . validation ) InvalidTerminalUpdateException ( de . wirecard . epos . exceptions . validation ) ThereIsNoAvailableDevice ( de . wirecard . epos . exceptions . initialization ) NoNewTerminalUpdateException ( de . wirecard . epos . exceptions . validation ) MissingCurrencyException ( de . wirecard . epos . exceptions . validation ) ParallelSalesException ( de . wirecard . epos . exceptions . validation ) MissingConfigurationException ( de . wirecard . epos . exceptions . validation ) MissingCallbackException ( de . wirecard . epos . exceptions . validation ) MissingDeviceIdException ( de . wirecard . epos . exceptions . validation ) AmountTooHighException ( de . wirecard . epos . exceptions . validation ) MissingTerminalConfigurationException ( de . wirecard . epos . exceptions . validation ) NoPaymentMethodException ( de . wirecard . epos . exceptions . validation ) TerminalCapabilityException ( de . wirecard . epos . exceptions . validation ) NoSelectedDeviceException ( de . wirecard . epos . exceptions . validation ) MissingSaleException ( de . wirecard . epos . exceptions . validation ) NoPaymentConfigurationException ( de . wirecard . epos . exceptions . validation ) DeviceTypeMismatchException ( de . wirecard . epos . exceptions . validation ) MissingBackendException ( de . wirecard . epos . exceptions . validation ) ThereIsNoAvailableDeviceType ( de . wirecard . epos . exceptions . initialization ) TerminalConfigurationException ( de . wirecard . epos . exceptions . validation ) MissingContextException ( de . wirecard . epos . exceptions . validation ) TerminalConfigUpdateException ( de . wirecard . epos . exceptions . validation ) IncorrectUpdateFilesException ( de . wirecard . epos . exceptions . extension . general ) SaleFailedException ( de . wirecard . epos . exceptions ) UnknownSaleFailException ( de . wirecard . epos . exceptions . sale ) SignatureRequestCanceledException ( de . wirecard . epos . exceptions . sale ) SaleNotApprovedException ( de . wirecard . epos . exceptions . sale ) SignatureConfirmationCanceledException ( de . wirecard . epos . exceptions . sale ) PasswordConfirmationRequestCanceledException ( de . wirecard . epos . exceptions . sale ) DeviceTypesSelectingCanceled ( de . wirecard . epos . exceptions . initialization ) ExtensionException ( de . wirecard . epos . exceptions . extension ) TerminalApplicationMismatchException ( de . wirecard . epos . exceptions . validation ) InvalidFirmwareVersionException ( de . wirecard . epos . exceptions . extension . general ) UnknownExtensionException ( de . wirecard . epos . exceptions . extension . general ) TerminatePaymentException ( de . wirecard . epos . extension . terminal . exception ) CardEntryAbortException ( de . wirecard . epos . exceptions . extension . general ) InvalidTerminalAppVersionException ( de . wirecard . epos . exceptions . extension . general ) LoadTerminalUpdateException ( de . wirecard . epos . exceptions . extension . general ) PinEntryAbortedByUserException ( de . wirecard . epos . extension . bbpos . exceptions ) CommunicationException ( de . wirecard . epos . exceptions . extension ) NoBluetoothPermissionException ( de . wirecard . epos . exceptions . extension . communication ) ConnectionAfterRestartDeviceException ( de . wirecard . epos . exceptions . extension . communication ) NoBluetoothException ( de . wirecard . epos . exceptions . extension . communication ) BluetoothConnectionException ( de . wirecard . epos . exceptions . extension . communication ) UsbConnectionException ( de . wirecard . epos . exceptions . extension . communication ) CommunicationTimeoutException ( de . wirecard . epos . exceptions . extension . communication ) AmountConfirmationTimedOutException ( de . wirecard . epos . exceptions . extension . communication ) NoUsbException ( de . wirecard . epos . exceptions . extension . communication ) TerminateAfterConfirmException ( de . wirecard . epos . exceptions . extension . communication ) NoBluetoothAdminPermissionException ( de . wirecard . epos . exceptions . extension . communication ) UnknownCommunicationException ( de . wirecard . epos . exceptions . extension . communication ) WrongBluetoothDeviceAddressException ( de . wirecard . epos . exceptions . extension . communication ) ConnectionFailedException ( de . wirecard . epos . exceptions . extension . communication ) DeviceDisconnectedException ( de . wirecard . epos . exceptions . extension . communication ) PairingToTerminalException ( de . wirecard . epos . exceptions . extension . communication ) UsbPermissionDeniedException ( de . wirecard . epos . exceptions . extension . communication ) TerminalUpdateFileException ( de . wirecard . epos . exceptions . extension . general ) CardEntryAbortedByUserException ( de . wirecard . epos . extension . bbpos . exceptions ) UnauthorizedException ( de . wirecard . epos . exceptions )","title":"The SDK Architecture"},{"location":"sdk-architecture/#the-sdk-architecture","text":"The Wirecard ePOS SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below: Note While the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as salesManager in the Objective-C code and sales () in the Java code. Each component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail. Note All nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information.","title":"The SDK Architecture"},{"location":"sdk-architecture/#sales-manager","text":"Sales are the lifeblood of any merchant so the Sales Manager component is the centerpiece of the SDK. A sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not. Caution A sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash.","title":"Sales Manager"},{"location":"sdk-architecture/#inventory-manager","text":"Inventory Manager enables you to: maintain product catalogues maintain product categories maintain products maintain product images In addition, if the merchant uses an ERP system, it also enables: use of product stock information stored in the ERP use of product price information stored in the ERP The Inventory Manager component is highlighted below:","title":"Inventory Manager"},{"location":"sdk-architecture/#cash-management-components","text":"The Wirecard ePOS SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components: The Cash Manager component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth. The Cash Drawer Manager component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired. These two components are highlighted below:","title":"Cash Management Components"},{"location":"sdk-architecture/#hardware-components","text":"Four of the nine components in the SDK architecture enable the management of hardware. They are highlighted below:","title":"Hardware Components"},{"location":"sdk-architecture/#terminal-manager","text":"The Terminal Manager component enables the discovery and usage of paired terminal devices, as well as the updating of firmware.","title":"Terminal Manager"},{"location":"sdk-architecture/#cash-drawer-manager","text":"As described earlier, the Cash Drawer Manager component enables the discovery and usage of paired cash drawers and cash registers.","title":"Cash Drawer Manager"},{"location":"sdk-architecture/#printer-manager","text":"The Printer Manager component enables the discovery and usage of paired printer devices, primarily for the printing of receipts.","title":"Printer Manager"},{"location":"sdk-architecture/#scanner-manager","text":"This Scanner Manager component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes.","title":"Scanner Manager"},{"location":"sdk-architecture/#customer-user-and-file-management","text":"Few supplementary components assist with handling customers and users and their standards behavior","title":"Customer, User and File Management"},{"location":"sdk-architecture/#customer-manager-erp","text":"ERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The Customer Manager component enables the use of this information.","title":"Customer Manager (ERP)"},{"location":"sdk-architecture/#user-manager","text":"Apps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the User Manager component has a variety of useful functionality, including: Password Policy checks Password Resets Reminder User of Password Change Password","title":"User Manager"},{"location":"sdk-architecture/#file-manager","text":"This File Manager enables handling of (usually brand-specific) files in app using support from backend side. Primary it's like branding support component natively build in SDK.","title":"File Manager"},{"location":"sdk-architecture/#error-management","text":"Almost all Wirecard ePOS SDK calls can have two results. First is positive, when everything is happy and second, something less-happy is the error result. See in categories below, which errors could appear.","title":"Error management"},{"location":"sdk-architecture/#ios-errors","text":"WDErrorBackendReturnedJSONDoesNotMatchMappedClass WDErrorUnauthorizedUser WDErrorUserPasswordExpired WDErrorUserPasswordChangeRequired WDErrorUserAccessForbidden WDErrorResourceNotFound WDErrorSessionExpired WDErrorRequestTimeOut WDErrorRequestNoProperResponse WDErrorRequestParameterRequired WDErrorRequestedResourceNotFound WDErrorRequestFailedValidation WDErrorPlugInTimeout WDErrorSignatureTimeout WDErrorInitialization WDErrorLowBatteryLevel WDErrorSwipeTimeout WDErrorBadSwipe WDErrorNotSupportedCardType WDErrorDataProcessing WDErrorOnlineProcessing WDErrorTransactionNotApproved WDErrorHardwareAccessPermission WDErrorTokenExpired WDErrorConnection WDErrorSignatureRequired WDErrorCantLoadTerminalConfiguration WDErrorTerminalDamaged WDErrorNoDUKPT WDErrorFailedToStartEMV WDErrorFailedToSendOfflineEMV WDErrorFailedToSendOnlineEMV WDErrorTerminalNotSetInMerchant WDErrorResponseLost WDErrorTransactionTerminated WDErrorTransactionDeclined WDErrorTransactionFailure WDErrorBlockedCardType WDErrorFailedBluetoothConnection WDErrorFailedPrinterBluetoothConnection WDErrorFailedTerminalBluetoothConnection WDErrorFailedDrawerBluetoothConnection WDErrorFailedPistolBluetoothConnection WDErrorTerminalNotReady WDErrorTerminalCommunication WDErrorTerminalTimeoutApplicationSelection WDErrorTerminalFailedToGetICCApplicationsList WDErrorTerminalFailedToTerminateCurrentTerminalPaymentFlow WDErrorLowPowerInAudioJack WDErrorMonoAudioEnabled WDErrorTerminalCommandTimeOut WDErrorTerminalTimeOut WDErrorTerminalWaitingUserTimeOut WDErrorTerminalCancelledFileUpload WDErrorWrongUserNameOrPassword WDErrorVendorNotFound WDErrorExternalAccessoriesProtocolInvalid application . plist file . WDErrorExternalIdNotFound WDErrorChangePasswordCriteriaNotMet WDErrorQueryStatsTokenExpired WDErrorForgotExternalIdNotFound WDErrorConfigFilesInfoTimeout WDErrorConfigFilesZipDownload WDErrorTerminalDisconnected WDErrorConfigFilesTerminalMayNotBeSet WDErrorConfigFilesTerminalCancelledFileDownload WDErrorConfigFilesProductionFirmwareOnDevelopmentTerminal WDErrorConfigFilesDevelopmentFirmwareOnProductionTerminal WDErrorConfigFilesTerminalUnsupported WDErrorConfigFilesTokenExpired WDErrorInventoryNoData WDErrorTerminalFirmwareDoesNotExist WDErrorTerminalConfigDoesNotExist WDErrorConfigFilesReading WDErrorPrinterTimeout WDErrorPrinterInitialization WDErrorPrinterLowBatteryLevel WDErrorPrinterNotConnected WDErrorPrinterOperation WDErrorPrinterUnsupportedDevice WDErrorDeviceDoesNotSupportPrinting WDErrorPrinterPaperLow WDErrorSignatureRejectedFromTerminal WDErrorInvalidPaymentConfiguration WDErrorInvalidAIDConfiguration WDErrorTransactionReversalRequired WDErrorTransactionReversedByTerminal WDErrorTransactionReversalFailed WDErrorTransactionUpdateFailed WDErrorExtensionClassDoesNotExist WDErrorExtensionDoesNotSupportMethod WDErrorInvalidParameter WDErrorDeviceRooted WDErrorActiveTerminalNotSet WDErrorActiveScanPistolNotSet WDErrorActivePrinterNotSet WDErrorPinLocked WDErrorPinInvalid WDErrorGeneral WDErrorServerSSLCertificateExpired WDErrorFailedTerminalBluetoothConnectionNotInPayment WDErrorMissingMerchant WDErrorAnotherTransactionIsInProgress","title":"iOS Errors"},{"location":"sdk-architecture/#android-exceptions","text":"SDK will usually returns exception, which extends from EposException and can also contain another exception in cause. Hierarchy of exceptions: EposException ( de . wirecard . epos . exceptions ) NoInternetException ( de . wirecard . epos . exceptions ) DeviceSelectingCanceled ( de . wirecard . epos . exceptions . initialization ) EposBackendException ( de . wirecard . epos . exceptions ) UnknownException ( de . wirecard . epos . exceptions ) ValidationException ( de . wirecard . epos . exceptions ) AmountTooLowException ( de . wirecard . epos . exceptions . validation ) MissingParamException ( de . wirecard . epos . exceptions . validation ) NoDeviceTypeException ( de . wirecard . epos . exceptions . validation ) TerminalAidConfigurationException ( de . wirecard . epos . exceptions . validation ) TipQuantityException ( de . wirecard . epos . exceptions . validation ) TerminalProfileException ( de . wirecard . epos . exceptions . validation ) MandatoryParametersException ( de . wirecard . epos . exceptions . validation ) TerminalProfileForNetworkException ( de . wirecard . epos . exceptions . validation ) ServiceChargeQuantityException ( de . wirecard . epos . exceptions . validation ) SaleValidationException ( de . wirecard . epos . exceptions . validation ) TerminalApplicationFileException ( de . wirecard . epos . exceptions . validation ) InvalidTerminalUpdateException ( de . wirecard . epos . exceptions . validation ) ThereIsNoAvailableDevice ( de . wirecard . epos . exceptions . initialization ) NoNewTerminalUpdateException ( de . wirecard . epos . exceptions . validation ) MissingCurrencyException ( de . wirecard . epos . exceptions . validation ) ParallelSalesException ( de . wirecard . epos . exceptions . validation ) MissingConfigurationException ( de . wirecard . epos . exceptions . validation ) MissingCallbackException ( de . wirecard . epos . exceptions . validation ) MissingDeviceIdException ( de . wirecard . epos . exceptions . validation ) AmountTooHighException ( de . wirecard . epos . exceptions . validation ) MissingTerminalConfigurationException ( de . wirecard . epos . exceptions . validation ) NoPaymentMethodException ( de . wirecard . epos . exceptions . validation ) TerminalCapabilityException ( de . wirecard . epos . exceptions . validation ) NoSelectedDeviceException ( de . wirecard . epos . exceptions . validation ) MissingSaleException ( de . wirecard . epos . exceptions . validation ) NoPaymentConfigurationException ( de . wirecard . epos . exceptions . validation ) DeviceTypeMismatchException ( de . wirecard . epos . exceptions . validation ) MissingBackendException ( de . wirecard . epos . exceptions . validation ) ThereIsNoAvailableDeviceType ( de . wirecard . epos . exceptions . initialization ) TerminalConfigurationException ( de . wirecard . epos . exceptions . validation ) MissingContextException ( de . wirecard . epos . exceptions . validation ) TerminalConfigUpdateException ( de . wirecard . epos . exceptions . validation ) IncorrectUpdateFilesException ( de . wirecard . epos . exceptions . extension . general ) SaleFailedException ( de . wirecard . epos . exceptions ) UnknownSaleFailException ( de . wirecard . epos . exceptions . sale ) SignatureRequestCanceledException ( de . wirecard . epos . exceptions . sale ) SaleNotApprovedException ( de . wirecard . epos . exceptions . sale ) SignatureConfirmationCanceledException ( de . wirecard . epos . exceptions . sale ) PasswordConfirmationRequestCanceledException ( de . wirecard . epos . exceptions . sale ) DeviceTypesSelectingCanceled ( de . wirecard . epos . exceptions . initialization ) ExtensionException ( de . wirecard . epos . exceptions . extension ) TerminalApplicationMismatchException ( de . wirecard . epos . exceptions . validation ) InvalidFirmwareVersionException ( de . wirecard . epos . exceptions . extension . general ) UnknownExtensionException ( de . wirecard . epos . exceptions . extension . general ) TerminatePaymentException ( de . wirecard . epos . extension . terminal . exception ) CardEntryAbortException ( de . wirecard . epos . exceptions . extension . general ) InvalidTerminalAppVersionException ( de . wirecard . epos . exceptions . extension . general ) LoadTerminalUpdateException ( de . wirecard . epos . exceptions . extension . general ) PinEntryAbortedByUserException ( de . wirecard . epos . extension . bbpos . exceptions ) CommunicationException ( de . wirecard . epos . exceptions . extension ) NoBluetoothPermissionException ( de . wirecard . epos . exceptions . extension . communication ) ConnectionAfterRestartDeviceException ( de . wirecard . epos . exceptions . extension . communication ) NoBluetoothException ( de . wirecard . epos . exceptions . extension . communication ) BluetoothConnectionException ( de . wirecard . epos . exceptions . extension . communication ) UsbConnectionException ( de . wirecard . epos . exceptions . extension . communication ) CommunicationTimeoutException ( de . wirecard . epos . exceptions . extension . communication ) AmountConfirmationTimedOutException ( de . wirecard . epos . exceptions . extension . communication ) NoUsbException ( de . wirecard . epos . exceptions . extension . communication ) TerminateAfterConfirmException ( de . wirecard . epos . exceptions . extension . communication ) NoBluetoothAdminPermissionException ( de . wirecard . epos . exceptions . extension . communication ) UnknownCommunicationException ( de . wirecard . epos . exceptions . extension . communication ) WrongBluetoothDeviceAddressException ( de . wirecard . epos . exceptions . extension . communication ) ConnectionFailedException ( de . wirecard . epos . exceptions . extension . communication ) DeviceDisconnectedException ( de . wirecard . epos . exceptions . extension . communication ) PairingToTerminalException ( de . wirecard . epos . exceptions . extension . communication ) UsbPermissionDeniedException ( de . wirecard . epos . exceptions . extension . communication ) TerminalUpdateFileException ( de . wirecard . epos . exceptions . extension . general ) CardEntryAbortedByUserException ( de . wirecard . epos . extension . bbpos . exceptions ) UnauthorizedException ( de . wirecard . epos . exceptions )","title":"Android Exceptions"},{"location":"setup-publictest/","text":"Set up Public Test","title":"Set up Public Test"},{"location":"setup-publictest/#set-up-public-test","text":"","title":"Set up Public Test"},{"location":"setup-terminals/","text":"Guide to Setting up Terminals","title":"Guide to Setting up Terminals"},{"location":"setup-terminals/#guide-to-setting-up-terminals","text":"","title":"Guide to Setting up Terminals"},{"location":"start/","text":"Welcome to the Wirecard ePOS SDK Partner Documentation The Wirecard ePOS SDK is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see Wirecard mPOS SDK Integration . The Wirecard ePOS SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay and WeChatPay. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the Wirecard ePOS SDK. Note A Windows Mobile version of the Wirecard ePOS SDK will be available shortly. Talk to your Wirecard representative for more information. Who is this for? Wirecard works with partners who use the Wirecard ePOS SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the functionality that you create with the SDK as the payment acceptance app , even though it may not be a standalone app. Tip If you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the Glossary to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others. How much is covered? Everything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The Using This Documentation chapter shows you how to use each section of this documentation site. How technical is it? A partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical. What do I need to know? Project managers on the technical team do not require any specific skills. Developers should have these skills: iOS developers - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift) Android developers - basic understanding of your Android development environment and the Java programming language For both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended. Where should I start? We recommend you take a few minutes to read The Basics chapter and then the Using this Documentation chapter. Or, if you just want to jump in to the more technical information, you can read the The mPOS Architecture first. Tip For developers who want to dive directly into the code, see the Set up on iOS or the Set up on Android .","title":"Getting Started"},{"location":"start/#welcome-to-the-wirecard-epos-sdk-partner-documentation","text":"The Wirecard ePOS SDK is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see Wirecard mPOS SDK Integration . The Wirecard ePOS SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay and WeChatPay. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the Wirecard ePOS SDK. Note A Windows Mobile version of the Wirecard ePOS SDK will be available shortly. Talk to your Wirecard representative for more information.","title":"Welcome to the Wirecard ePOS SDK Partner Documentation"},{"location":"start/#who-is-this-for","text":"Wirecard works with partners who use the Wirecard ePOS SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the functionality that you create with the SDK as the payment acceptance app , even though it may not be a standalone app. Tip If you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the Glossary to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others.","title":"Who is this for?"},{"location":"start/#how-much-is-covered","text":"Everything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The Using This Documentation chapter shows you how to use each section of this documentation site.","title":"How much is covered?"},{"location":"start/#how-technical-is-it","text":"A partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical.","title":"How technical is it?"},{"location":"start/#what-do-i-need-to-know","text":"Project managers on the technical team do not require any specific skills. Developers should have these skills: iOS developers - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift) Android developers - basic understanding of your Android development environment and the Java programming language For both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended.","title":"What do I need to know?"},{"location":"start/#where-should-i-start","text":"We recommend you take a few minutes to read The Basics chapter and then the Using this Documentation chapter. Or, if you just want to jump in to the more technical information, you can read the The mPOS Architecture first. Tip For developers who want to dive directly into the code, see the Set up on iOS or the Set up on Android .","title":"Where should I start?"},{"location":"switch-reference/","text":"Switch Back-end Reference","title":"Switch Back-end Reference"},{"location":"switch-reference/#switch-back-end-reference","text":"","title":"Switch Back-end Reference"},{"location":"using/","text":"Using This Documentation This topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the Overall Table of Contents because there is also a table of contents on the right side of the window and this is referred to as the Chapter Table of Contents . The Chapter Table of Contents lists the headings that make up each individual chapter. Note On smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this: Start The Start section helps you get oriented. After this topic, there are two more really important ones you should read: The mPOS Architecture topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the Wirecard ePOS SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment. The SDK Architecture topic introduces the nine components that comprise the Wirecard ePOS SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code. Setup The Setup section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs. Integrate The Integrate section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the Wirecard ePOS SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed. It also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in GIST . Code is available in the following languages: Swift for iOS Objective-C for iOS Java for Android References The References section actually has hundreds of pages of useful information, particularly for developers. The Reference - Android SDK topic, which is below the References section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a sub-site that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java. The Reference - iOS SDK topic, which is below the References section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a sub-site that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift. Glossary If you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The Glossary addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.","title":"Using this Documentation"},{"location":"using/#using-this-documentation","text":"This topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the Overall Table of Contents because there is also a table of contents on the right side of the window and this is referred to as the Chapter Table of Contents . The Chapter Table of Contents lists the headings that make up each individual chapter. Note On smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this:","title":"Using This Documentation"},{"location":"using/#start","text":"The Start section helps you get oriented. After this topic, there are two more really important ones you should read: The mPOS Architecture topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the Wirecard ePOS SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment. The SDK Architecture topic introduces the nine components that comprise the Wirecard ePOS SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code.","title":"Start"},{"location":"using/#setup","text":"The Setup section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs.","title":"Setup"},{"location":"using/#integrate","text":"The Integrate section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the Wirecard ePOS SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed. It also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in GIST . Code is available in the following languages: Swift for iOS Objective-C for iOS Java for Android","title":"Integrate"},{"location":"using/#references","text":"The References section actually has hundreds of pages of useful information, particularly for developers. The Reference - Android SDK topic, which is below the References section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a sub-site that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java. The Reference - iOS SDK topic, which is below the References section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a sub-site that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift.","title":"References"},{"location":"using/#glossary","text":"If you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The Glossary addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.","title":"Glossary"}]}